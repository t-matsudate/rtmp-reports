(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{121:function(n,l,e){"use strict";var t=e(49);e.n(t).a},122:function(n,l,e){(l=e(5)(!1)).push([n.i,"#grids #main main article {\n  padding: 1em;\n}\n#grids #main main article .markdown-body {\n  font-family: serif;\n}\n#grids #main main article .markdown-body strong {\n  font-weight: bold;\n}\n#grids #main main article .markdown-body em {\n  font-style: italic;\n}\n#grids #main main article .markdown-body .footnotes {\n  word-break: break-word;\n}\n#grids #main main article .markdown-body .hljs {\n  /* 4K */\n  /* WQHD */\n  /* Desktop or Laptop (Full HD) */\n  /* iPad (up to 12 inchs) */\n  /* iPhone (up to X) */\n  /* Android (based on Pixel XL) */\n}\n@media (orientation: landscape) and (max-width: 3840px) {\n#grids #main main article .markdown-body .hljs {\n    max-width: 3340.8px;\n}\n}\n@media (orientation: portrait) and (max-width: 2160px) {\n#grids #main main article .markdown-body .hljs {\n    max-width: 1879.2px;\n}\n}\n@media (orientation: landscape) and (max-width: 2560px) {\n#grids #main main article .markdown-body .hljs {\n    max-width: 2227.2px;\n}\n}\n@media (orientation: portrait) and (max-width: 1440px) {\n#grids #main main article .markdown-body .hljs {\n    max-width: 1252.8px;\n}\n}\n@media (orientation: landscape) and (max-width: 1920px) {\n#grids #main main article .markdown-body .hljs {\n    max-width: 1670.4px;\n}\n}\n@media (orientation: portrait) and (max-width: 1080px) {\n#grids #main main article .markdown-body .hljs {\n    max-width: 939.6px;\n}\n}\n@media (orientation: landscape) and (max-width: 1366px) {\n#grids #main main article .markdown-body .hljs {\n    max-width: 1188.42px;\n}\n}\n@media (orientation: portrait) and (max-width: 1024px) {\n#grids #main main article .markdown-body .hljs {\n    max-width: 890.88px;\n}\n}\n@media (orientation: landscape) and (max-width: 812px) {\n#grids #main main article .markdown-body .hljs {\n    max-width: 706.44px;\n}\n}\n@media (orientation: portrait) and (max-width: 375px) {\n#grids #main main article .markdown-body .hljs {\n    max-width: 326.25px;\n}\n}\n@media (orientation: landscape) and (max-width: 640px) {\n#grids #main main article .markdown-body .hljs {\n    max-width: 556.8px;\n}\n}\n@media (orientation: portrait) and (max-width: 360px) {\n#grids #main main article .markdown-body .hljs {\n    max-width: 313.2px;\n}\n}\n#grids #main main article .markdown-body #rtmp-invoke-connect-sequences,\n#grids #main main article .markdown-body #rtmp-invoke-publish-sequences {\n  text-align: center;\n}\n#grids #main main article .markdown-body #caption-rtmp-invoke-connect-sequences,\n#grids #main main article .markdown-body #caption-rtmp-invoke-publish-sequences {\n  text-align: center;\n}\n",""]),n.exports=l},139:function(n,l,e){"use strict";e.r(l);var t=e(44),c=e(45),h=e(53),r=e(46),m={components:{Author:t.a,ReportTitle:c.a,Markdown:h.a,ShareButtons:r.a},data:()=>({author:"T.Matsudate",published:"2020-02-13",title:"ハンドシェイクと Invoke 処理の実装",description:"RTMP サーバをどのように実装していけばよいかについて, 接続開始から映像/音声の送受信直前までの実装で説明していく.",source:'<p><div class="table-of-contents"><ul><li><a href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB">はじめに</a></li><li><a href="#rtmp-%E6%8E%A5%E7%B6%9A%E3%81%A8%E3%83%8F%E3%83%B3%E3%83%89%E3%82%B7%E3%82%A7%E3%82%A4%E3%82%AF">RTMP 接続とハンドシェイク</a><ul><li><a href="#c0%2C-c1-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%2Fs0%2C-s1%2C-s2-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF">C0, C1 チャンク/S0, S1, S2 チャンク</a></li><li><a href="#c2-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF">C2 チャンク</a></li></ul></li><li><a href="#invoke-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E5%87%A6%E7%90%86">Invoke チャンクの処理</a><ul><li><a href="#connect">connect</a><ul><li><a href="#%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E5%9F%BA%E6%9C%AC%E6%A7%8B%E9%80%A0">チャンクの基本構造</a></li><li><a href="#%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%83%98%E3%83%83%E3%83%80%E3%81%AE%E8%AA%AD%E3%81%BF%E5%8F%96%E3%82%8A">チャンクヘッダの読み取り</a></li><li><a href="#%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E8%AA%AD%E3%81%BF%E5%8F%96%E3%82%8A">チャンクデータの読み取り</a></li><li><a href="#%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E3%81%B8%E3%81%AE%E5%A4%89%E6%8F%9B">データ構造への変換</a></li><li><a href="#connect-%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E8%A6%81%E6%B1%82%E3%81%B8%E3%81%AE%E8%BF%94%E9%80%81%E6%89%8B%E9%A0%86">connect コマンド要求への返送手順</a><ul><li><a href="#%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E9%95%B7%E3%81%AE%E6%B1%82%E3%82%81%E6%96%B9">メッセージ長の求め方</a></li><li><a href="#%E3%83%90%E3%82%A4%E3%83%88%E5%88%97%E3%81%B8%E3%81%AE%E5%A4%89%E6%8F%9B">バイト列への変換</a></li><li><a href="#%E8%BF%94%E9%80%81%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E9%80%81%E4%BF%A1">返送チャンクの送信</a></li></ul></li></ul></li><li><a href="#releasestream%2C-fcpublish%2C-createstream">releaseStream, FCPublish, createStream</a><ul><li><a href="#releasestream%2C-fcpublish%2C-createstream-%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%81%AE%E5%8F%97%E4%BF%A1%E3%81%A8%E8%BF%94%E9%80%81%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E9%80%81%E4%BF%A1">releaseStream, FCPublish, createStream コマンドの受信と返送チャンクの送信</a></li><li><a href="#%E7%9B%B4%E5%89%8D%E3%81%AE%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E6%83%85%E5%A0%B1%E3%81%AE%E4%BF%9D%E5%AD%98">直前のチャンクの情報の保存</a><ul><li><a href="#%E5%8F%97%E4%BF%A1%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E5%A0%B4%E5%90%88">受信チャンクの場合</a></li><li><a href="#%E9%80%81%E4%BF%A1%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E5%A0%B4%E5%90%88">送信チャンクの場合</a></li></ul></li></ul></li><li><a href="#publish">publish</a><ul><li><a href="#publish-%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%81%AE%E5%8F%97%E4%BF%A1">publish コマンドの受信</a></li><li><a href="#publish-%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E8%A6%81%E6%B1%82%E3%81%B8%E3%81%AE%E8%BF%94%E9%80%81%E6%89%8B%E9%A0%86">publish コマンド要求への返送手順</a></li></ul></li></ul></li><li><a href="#%E3%81%BE%E3%81%A8%E3%82%81">まとめ</a></li><li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">参考文献</a></li></ul></div></p>\n<h2 id="%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB"><a class="header-anchor" href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB">¶</a> はじめに</h2>\n<p><a href="https://t-matsudate.github.io/rtmp-reports/overview">前頁</a>では RTMP の概要と当該プロトコルにおける通信手順について, 既存 OSS 製品の実装を参照しながら説明した. 本頁では前頁での説明を踏まえつつ, プログラミング言語を用いた実装を行っていく. ここで, 本実装に際して用いるツールを以下に記す.</p>\n<ul>\n<li>プログラミング言語: Rust 1.40.0\n<ul>\n<li>rand 0.7.3</li>\n<li>rust-crypto 0.2.36</li>\n</ul>\n</li>\n<li>クライアントツール: FFmpeg 4.2.2</li>\n</ul>\n<h2 id="rtmp-%E6%8E%A5%E7%B6%9A%E3%81%A8%E3%83%8F%E3%83%B3%E3%83%89%E3%82%B7%E3%82%A7%E3%82%A4%E3%82%AF"><a class="header-anchor" href="#rtmp-%E6%8E%A5%E7%B6%9A%E3%81%A8%E3%83%8F%E3%83%B3%E3%83%89%E3%82%B7%E3%82%A7%E3%82%A4%E3%82%AF">¶</a> RTMP 接続とハンドシェイク</h2>\n<p>RTMP では, サーバ側はクライアント側からの接続を TCP の 1935 番ポートで待ち受ける.\nこれは Rust では以下のように書く.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    io::{\n        <span class="hljs-comment">// prelude にある Result 型との衝突および混同を避けるため.</span>\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult,\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    }\n};\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-comment">// リスナのインスタンス生成の成否を Result&lt;TcpListener&gt; 型で返す.</span>\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-comment">// TCP 接続を待ち受け, Incoming 型にラップする.</span>\n    <span class="hljs-comment">// Incoming 型はイテレータを実装している.</span>\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n    <span class="hljs-comment">// Incoming 型はイテレータから Result&lt;TcpStream&gt; 型を返す.</span>\n    <span class="hljs-keyword">let</span> stream = incoming?;\n\n    <span class="hljs-comment">// Do something.</span>\n    }\n\n    <span class="hljs-comment">// 返り値の型を合わせるため.</span>\n    <span class="hljs-literal">Ok</span>(())\n}\n</code></pre>\n<p>もしくは <code>accept()</code> メソッドを用いて以下のようにも書くことができる.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    io::{\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    }\n};\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-comment">// accept() はイテレータを実装した型を返さないので, loop で待ち受けを維持する必要がある.</span>\n    <span class="hljs-keyword">loop</span> {\n        <span class="hljs-comment">// accept() は TCP 接続の成否を Result&lt;(TcpStream, SocketAddr)&gt; 型で返す.</span>\n        <span class="hljs-comment">// 待ち受けに失敗すると Err を返すが, incoming() と同様に常時待ち受けるため, 基本的には気にしなくていいだろう.</span>\n        <span class="hljs-keyword">let</span> (stream, addr) = listener.accept()?;\n\n        <span class="hljs-comment">// Do something.</span>\n    }\n}\n</code></pre>\n<p>なお, 本頁では <code>incoming()</code> から接続を待ち受ける前提で例を示す.</p>\n<h3 id="c0%2C-c1-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%2Fs0%2C-s1%2C-s2-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF"><a class="header-anchor" href="#c0%2C-c1-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%2Fs0%2C-s1%2C-s2-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF">¶</a> C0, C1 チャンク/S0, S1, S2 チャンク</h3>\n<p>クライアント側からの TCP 接続要求を受け入れたなら, 次にクライアント側との間でハンドシェイクを行う. RTMP におけるハンドシェイクは二段階ある. 以下に記すのは一段階目における実装である. ここで, 当該段階でのハンドシェイクデータの容量は受信時 1537 bytes (C0C1 チャンク), 送信時 3073 bytes (S0S1S2 チャンク) である.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    io::{\n        <span class="hljs-comment">// ::std::error にある Error トレイトとの衝突および混同を避けるため,</span>\n        Error <span class="hljs-keyword">as</span> IOError,\n        ErrorKind,\n        <span class="hljs-comment">// クライアント側からのデータを読み取るために Read トレイトのメソッドが必要である.</span>\n        Read,\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IO <span class="hljs-built_in">Result</span>,\n        <span class="hljs-comment">// クライアント側へデータを送信するために Write トレイトのメソッドが必要である.</span>\n        Write\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    },\n    time::{\n        SystemTime\n    }\n};\n<span class="hljs-keyword">use</span> crypto::{\n    hmac::{\n        Hmac\n    },\n    sha2::{\n        Sha256\n    }\n};\n<span class="hljs-keyword">use</span> rand::prelude::*;\n\n<span class="hljs-keyword">const</span> GENUINE_FP_KEY: &amp;[<span class="hljs-built_in">u8</span>] = &amp;[\n    <span class="hljs-comment">// "Genuine Adobe Flash Player 001" (クライアント側がサーバ側に C1 チャンクを送信する時はこの部分のみを使う)</span>\n    <span class="hljs-number">0x47</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x4d</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x76</span>,\n    <span class="hljs-comment">// クライアント側がサーバ側から受信した S2 チャンクのダイジェストを確認する時にはこの部分も使う.</span>\n    <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-number">0xee</span>, <span class="hljs-number">0xc2</span>, <span class="hljs-number">0x4a</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0xe8</span>, <span class="hljs-number">0x2e</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xd0</span>, <span class="hljs-number">0xd1</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x9e</span>, <span class="hljs-number">0x7e</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0xec</span>, <span class="hljs-number">0x5d</span>, <span class="hljs-number">0x2d</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0xab</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xb8</span>, <span class="hljs-number">0xe6</span>, <span class="hljs-number">0x36</span>, <span class="hljs-number">0xcf</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xae</span>\n];\n<span class="hljs-keyword">const</span> GENUINE_FMS_KEY: &amp;[<span class="hljs-built_in">u8</span>] = &amp;[\n    <span class="hljs-comment">// "Genuine Adobe Flash Media Server 001" (サーバ側がクライアント側に S1 チャンクを送信する時はこの部分のみを使う)</span>\n    <span class="hljs-number">0x47</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x4d</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x76</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x31</span>,\n    <span class="hljs-comment">// サーバ側がクライアント側から受信した C2 チャンクのダイジェストを確認する時にはこの部分も使う.</span>\n    <span class="hljs-number">0xf0</span>, <span class="hljs-number">0xee</span>, <span class="hljs-number">0xc2</span>, <span class="hljs-number">0x4a</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0xe8</span>, <span class="hljs-number">0x2e</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xd0</span>, <span class="hljs-number">0xd1</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x9e</span>, <span class="hljs-number">0x7e</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0xec</span>, <span class="hljs-number">0x5d</span>, <span class="hljs-number">0x2d</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0xab</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xb8</span>, <span class="hljs-number">0xe6</span>, <span class="hljs-number">0x36</span>, <span class="hljs-number">0xcf</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xae</span>\n];\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-comment">// 読み書きでストリームを消費するため.</span>\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n\n        <span class="hljs-comment">/* C0 チャンクおよび C1 チャンクの受信を開始する. */</span>\n\n        <span class="hljs-comment">// read() は可変なスライスを要求するが, 配列もまた参照にすることでスライスと同じ振る舞いをすることができる.</span>\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> c0c1: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1537</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1537</span>];\n\n        <span class="hljs-comment">// read() は成功時にその時点で読み取ったデータの容量を返し, すべてを読み切ると Ok(0) を返す.</span>\n        <span class="hljs-comment">// ここでは所定の容量を一度で読み切っているため, バッファしたサイズを気にする必要はない.</span>\n        stream.read(&amp;<span class="hljs-keyword">mut</span> c0c1)?;\n\n        <span class="hljs-comment">// 仕様書には C0 チャンクの値はデフォルトで 3 (生の RTMP) であると指定されており, クライアント側もサーバ側もこのバージョンでなければ接続を閉じと良いとされている.</span>\n        <span class="hljs-comment">// ただし, 必須の処理ではないため, この部分は実装しなくてもよい.</span>\n        <span class="hljs-keyword">if</span> c0c1[<span class="hljs-number">0</span>] != <span class="hljs-number">3</span> {\n            <span class="hljs-comment">// ::std::io::Error::from() :: ErrorKind -&gt; std::io::Error</span>\n            <span class="hljs-comment">// into() は内部で from() を暗黙に呼ぶように実装されているため, From の実装がある型であれば変換元の型から into() を呼ぶことで変換することができる.</span>\n            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidInput.into());\n        }\n\n        <span class="hljs-comment">// usize 型の初期化値, つまり 0 が束縛される.</span>\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset_client = <span class="hljs-built_in">usize</span>::default();\n\n        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">4</span> {\n            <span class="hljs-comment">// C0 チャンク (1 byte), タイムスタンプ (4 bytes) および Flash Player のバージョン (4 bytes) を飛ばす.</span>\n            offset_client += c0c1[<span class="hljs-number">9</span> + i] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n        }\n\n        offset_client = offset_client % <span class="hljs-number">728</span> + <span class="hljs-number">12</span>;\n\n        <span class="hljs-comment">// サーバ側がクライアント側から受信した C1 チャンクに入力されている HMAC(SHA-256) ダイジェスト.</span>\n        <span class="hljs-keyword">let</span> digest_client_sent = &amp;c0c1[offset_client..(offset_client + <span class="hljs-number">32</span>)];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hmac_client = Hmac::new(Sha256::new(), &amp;GENUINE_FP_KEY[..<span class="hljs-number">30</span>]);\n\n        <span class="hljs-comment">// C1 チャンク中にある HMAC(SHA-256) のダイジェスト部分(と C0 チャンクを含めた最初の 9 bytes)を除く.</span>\n        hmac_client.input(&amp;c0c1[<span class="hljs-number">9</span>..(<span class="hljs-number">9</span> + offset_client)]);\n        hmac_client.input(&amp;c0c1[(<span class="hljs-number">9</span> + offset_client + <span class="hljs-number">32</span>)..]);\n\n        <span class="hljs-comment">// Hmac.result() :: &amp;Hmac -&gt; MacResult</span>\n        <span class="hljs-keyword">let</span> digest_client_expected = hmac_client.result();\n\n        <span class="hljs-comment">// サーバ側がクライアント側から受信した C1 チャンクのダイジェストが実際に求めた結果と違う場合は, エラーとして接続を終了する.</span>\n        <span class="hljs-comment">// MacResult.code() :: &amp;MacResult -&gt; &amp;[u8]</span>\n        <span class="hljs-keyword">if</span> digest_client_sent != digest_client_expected.code() {\n            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidData.into());\n        }\n\n        <span class="hljs-comment">/* S0 チャンクおよび S1 チャンクの生成を開始する. */</span>\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s0s1s2: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n        <span class="hljs-comment">// SystemTime::now() :: SystemTime,</span>\n        <span class="hljs-comment">// SystemTime.duration_since() :: SystemTime -&gt; Result&lt;Duration, SystemTimeError&gt;,</span>\n        <span class="hljs-comment">// Duration.as_secs() :: &amp;Duration -&gt; u64</span>\n        <span class="hljs-comment">// 注:</span>\n        <span class="hljs-comment">//</span>\n        <span class="hljs-comment">// * ハンドシェイクチャンクのタイムスタンプは 4 bytes であるため, ビット幅を 8 bytes から小さくする必要がある.</span>\n        <span class="hljs-comment">// * SystemTime.duration_since() から返される SystemTimeError は ::std::io::Error 型ではないため, ? 演算子ではコンテキストが一致しない.</span>\n        <span class="hljs-keyword">let</span> timestamp_bytes = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap().as_secs() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>;\n\n        <span class="hljs-comment">// S0 チャンク(つまり, RTMP のバージョン)</span>\n        s0s1s2.push(<span class="hljs-number">3</span>);\n        s0s1s2.extend_from_slice(&amp;timestamp_bytes.to_be_bytes());\n        <span class="hljs-comment">// Adobe Media Server の最新バージョン (5.0.10.0).</span>\n        <span class="hljs-comment">// 前頁の通り, Flash Player 9/Adobe Media Server 3 の前後で違う処理を行う製品が存在する.</span>\n        <span class="hljs-comment">// メジャーバージョン(先頭 1 byte)にさえ気をつけていればよいが, ハンドシェイクの段階で送受信した結果が噛み合わない場合はこの 4 bytes も注視すること.</span>\n        s0s1s2.extend_from_slice(&amp;[<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>]);\n\n        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">1528</span> {\n            s0s1s2.push(random());\n        }\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset_server = <span class="hljs-built_in">usize</span>::default();\n\n        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">4</span> {\n            offset_server += s0s1s2[<span class="hljs-number">9</span> + i] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n        }\n\n        offset_server = offset_server % <span class="hljs-number">728</span> + <span class="hljs-number">12</span>;\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hmac_server = Hmac::new(Sha256::new(), &amp;GENUINE_FMS_KEY[..<span class="hljs-number">36</span>]);\n\n        hmac_server.input(&amp;s0s1s2[<span class="hljs-number">9</span>..(<span class="hljs-number">9</span> + offset_server)]);\n        hmac_server.input(&amp;s0s1s2[(<span class="hljs-number">9</span> + offset_server + <span class="hljs-number">32</span>)..]);\n\n        <span class="hljs-keyword">let</span> digest_server = hmac.result().code();\n\n        <span class="hljs-comment">// HMAC(SHA-256) のダイジェストを所定の位置に上書きする.</span>\n        <span class="hljs-comment">// これは以下のコードに置き換えることができる.</span>\n        <span class="hljs-comment">//</span>\n        <span class="hljs-comment">// for i in 0..digest_server.len() {</span>\n        <span class="hljs-comment">//     s0s1s2[9 + offset_server + i] = digest_server[i];</span>\n        <span class="hljs-comment">// }</span>\n        <span class="hljs-comment">// </span>\n        <span class="hljs-comment">// 注: copy_from_slice() は双方のスライスの長さが一致していないと panic する.</span>\n        s0s1s2[(<span class="hljs-number">9</span> + offset_server)..(<span class="hljs-number">9</span> + offset_server + <span class="hljs-number">32</span>)].copy_from_slice(digest_server);\n\n        <span class="hljs-comment">/* S2 チャンクの生成を開始する. */</span>\n\n        hmac_client = Hmac::new(Sha256::new(), &amp;GENUINE_FP_KEY);\n        <span class="hljs-comment">// サーバ側はクライアント側から受信した C1 チャンクに書き込まれたダイジェストを元に S2 チャンク用のダイジェストを生成する.</span>\n        hmac_client.input(digest_client_sent);\n\n        <span class="hljs-keyword">let</span> digest_s2 = hmac_client.result();\n\n        <span class="hljs-comment">// サーバ側は生成したダイジェストを鍵にして, S2 チャンクに書き込む署名を生成する.</span>\n        hmac_client = Hmac::new(Sha256::new(), digest_s2.code());\n        <span class="hljs-comment">// 署名を書き込む最後の 32 bytes を飛ばす.</span>\n        hmac_client.input(c0c1[<span class="hljs-number">9</span>..(c0c1.len() - <span class="hljs-number">32</span>)]);\n\n        <span class="hljs-keyword">let</span> signature_s2 = hmac_client.result();\n\n        <span class="hljs-comment">// C1 チャンクの最後の 32 bytes を署名で上書きすることで S2 チャンクとする.</span>\n        c0c1[(c0c1.len() - <span class="hljs-number">32</span>)..].copy_from_slice(signature_s2.code());\n        <span class="hljs-comment">// S2 チャンクをサーバ側のハンドシェイクデータに付け加える.</span>\n        s0s1s2.extend_from_slice(&amp;c0c1[<span class="hljs-number">1</span>..]);\n        <span class="hljs-comment">// write() も成功時にその時点で書き込んだデータの容量を返し, すべてを書き切ると Ok(0) を返す.</span>\n        stream.write(s0s1s2.as_slice())?;\n    }\n\n    <span class="hljs-literal">Ok</span>(())\n}\n</code></pre>\n<p>上記の通信の結果としてクライアント側との通信が閉じられなければ, サーバ側がクライアント側に送信したハンドシェイクデータは正しいということになる. ここで, コードの見やすさのために当該処理に名前を付ける.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    io::{\n        Error <span class="hljs-keyword">as</span> IOError,\n        ErrorKind,\n        Read,\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult,\n        Write\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    },\n    time::{\n        SystemTime\n    }\n};\n<span class="hljs-keyword">use</span> crypto::{\n    hmac::{\n        Hmac\n    },\n    sha2::{\n        Sha256\n    }\n};\n<span class="hljs-keyword">use</span> rand::prelude::*;\n\n<span class="hljs-keyword">const</span> GENUINE_FP_KEY: &amp;[<span class="hljs-built_in">u8</span>] = &amp;[\n    <span class="hljs-number">0x47</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x4d</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x76</span>,\n    <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-number">0xee</span>, <span class="hljs-number">0xc2</span>, <span class="hljs-number">0x4a</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0xe8</span>, <span class="hljs-number">0x2e</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xd0</span>, <span class="hljs-number">0xd1</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x9e</span>, <span class="hljs-number">0x7e</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0xec</span>, <span class="hljs-number">0x5d</span>, <span class="hljs-number">0x2d</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0xab</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xb8</span>, <span class="hljs-number">0xe6</span>, <span class="hljs-number">0x36</span>, <span class="hljs-number">0xcf</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xae</span>\n];\n<span class="hljs-keyword">const</span> GENUINE_FMS_KEY: &amp;[<span class="hljs-built_in">u8</span>] = &amp;[\n    <span class="hljs-number">0x47</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x4d</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x76</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x31</span>,\n    <span class="hljs-number">0xf0</span>, <span class="hljs-number">0xee</span>, <span class="hljs-number">0xc2</span>, <span class="hljs-number">0x4a</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0xe8</span>, <span class="hljs-number">0x2e</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xd0</span>, <span class="hljs-number">0xd1</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x9e</span>, <span class="hljs-number">0x7e</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0xec</span>, <span class="hljs-number">0x5d</span>, <span class="hljs-number">0x2d</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0xab</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xb8</span>, <span class="hljs-number">0xe6</span>, <span class="hljs-number">0x36</span>, <span class="hljs-number">0xcf</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xae</span>\n];\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">handle_first_handshake</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream) -&gt; IOResult&lt;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> c0c1: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1537</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1537</span>];\n\n    stream.read(&amp;<span class="hljs-keyword">mut</span> c0c1)?;\n\n    <span class="hljs-keyword">if</span> c0c1[<span class="hljs-number">0</span>] != <span class="hljs-number">3</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidInput.into());\n    }\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset_client = <span class="hljs-built_in">usize</span>::default();\n\n    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">4</span> {\n        offset_client += c0c1[<span class="hljs-number">9</span> + i] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n    }\n\n    offset_client = offset_client % <span class="hljs-number">728</span> + <span class="hljs-number">12</span>;\n\n    <span class="hljs-keyword">let</span> digest_client_sent = &amp;c0c1[offset_client..(offset_client + <span class="hljs-number">32</span>)];\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hmac_client = Hmac::new(Sha256::new(), &amp;GENUINE_FP_KEY[..<span class="hljs-number">30</span>]);\n\n    hmac_client.input(&amp;c0c1[<span class="hljs-number">9</span>..(<span class="hljs-number">9</span> + offset_client)]);\n    hmac_client.input(&amp;c0c1[(<span class="hljs-number">9</span> + offset_client + <span class="hljs-number">32</span>)..]);\n\n    <span class="hljs-keyword">let</span> digest_client_expected = hmac_client.result();\n\n    <span class="hljs-keyword">if</span> digest_client_sent != digest_client_expected.code() {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidData.into());\n    }\n\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s0s1s2: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> timestamp = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap().as_secs() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>;\n\n    s0s1s2.push(<span class="hljs-number">3</span>);\n    s0s1s2.extend_from_slice(&amp;timestamp.to_be_bytes());\n    s0s1s2.extend_from_slice(&amp;[<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>]);\n\n    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">1528</span> {\n        s0s1s2.push(random());\n    }\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset_server = <span class="hljs-built_in">usize</span>::default();\n\n    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">4</span> {\n        offset_server += s0s1s2[<span class="hljs-number">9</span> + i] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n    }\n\n    offset_server = offset_server % <span class="hljs-number">728</span> + <span class="hljs-number">12</span>;\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hmac_server = Hmac::new(Sha256::new(), &amp;GENUINE_FMS_KEY[..<span class="hljs-number">36</span>]);\n\n    hmac_server.input(&amp;s0s1s2[<span class="hljs-number">9</span>..(<span class="hljs-number">9</span> + offset_server)]);\n    hmac_server.input(&amp;s0s1s2[(<span class="hljs-number">9</span> + offset_server + <span class="hljs-number">32</span>)..]);\n\n    <span class="hljs-keyword">let</span> digest_server = hmac.result().code();\n\n    s0s1s2[(<span class="hljs-number">9</span> + offset_server)..(<span class="hljs-number">9</span> + offset_server + <span class="hljs-number">32</span>)].copy_from_slice(digest_server);\n    hmac_client = Hmac::new(Sha256::new(), &amp;GENUINE_FP_KEY);\n    hmac_client.input(digest_client_sent);\n\n    <span class="hljs-keyword">let</span> digest_s2 = hmac_client.result();\n\n    hmac_client = Hmac::new(Sha256::new(), digest_s2.code());\n    hmac_client.input(c0c1[<span class="hljs-number">9</span>..(c0c1.len() - <span class="hljs-number">32</span>)]);\n\n    <span class="hljs-keyword">let</span> signature_s2 = hmac_client.result();\n\n    <span class="hljs-comment">// 二段階目のハンドシェイクは S1 チャンクと C2 チャンクの照合を必要とする.</span>\n    <span class="hljs-comment">// 前のコードは for ループでやり切っていたが, 関数化したことによりこのままでは S0S1S2 チャンクのデータは破棄されてしまう.</span>\n    <span class="hljs-comment">// そこで, S1 チャンクに相当する部分を S0S1S2 チャンクから切り出して呼び出し元に返すことにする.</span>\n    <span class="hljs-comment">// スライス（実態は参照経由で扱う）のままではなく Vec に変換して返しているのも同様の理由である.</span>\n    stream.write(s0s1s2.as_slice()).map(|_| s0s1s2[<span class="hljs-number">1</span>..(s0s1s2.len() - <span class="hljs-number">1536</span>)].to_vec())\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n        <span class="hljs-comment">// ? 演算子で Result を unwrap した状態で束縛できる.</span>\n        <span class="hljs-keyword">let</span> s1 = handle_first_handshake(stream)?;\n    }\n\n    <span class="hljs-literal">Ok</span>(())\n}\n</code></pre>\n<h3 id="c2-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF"><a class="header-anchor" href="#c2-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF">¶</a> C2 チャンク</h3>\n<p>次に二段階目のハンドシェイクの例を記す. ここで, 当該段階でのハンドシェイクデータの容量は 1536 bytes (C2 チャンク) である. 当該処理の成功後すぐに後述の Invoke 処理の段階に移るため, ハンドシェイクデータの返送について考慮する必要はない.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    io::{\n        Error <span class="hljs-keyword">as</span> IOError,\n        ErrorKind,\n        Read,\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IO <span class="hljs-built_in">Result</span>,\n        Write\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    },\n    time::{\n        SystemTime\n    }\n};\n<span class="hljs-keyword">use</span> crypto::{\n    hmac::{\n        Hmac\n    },\n    sha2::{\n        Sha256\n    }\n};\n<span class="hljs-keyword">use</span> rand::prelude::*;\n\n<span class="hljs-keyword">const</span> GENUINE_FP_KEY: &amp;[<span class="hljs-built_in">u8</span>] = &amp;[\n    <span class="hljs-number">0x47</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x4d</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x76</span>,\n    <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-number">0xee</span>, <span class="hljs-number">0xc2</span>, <span class="hljs-number">0x4a</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0xe8</span>, <span class="hljs-number">0x2e</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xd0</span>, <span class="hljs-number">0xd1</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x9e</span>, <span class="hljs-number">0x7e</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0xec</span>, <span class="hljs-number">0x5d</span>, <span class="hljs-number">0x2d</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0xab</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xb8</span>, <span class="hljs-number">0xe6</span>, <span class="hljs-number">0x36</span>, <span class="hljs-number">0xcf</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xae</span>\n];\n<span class="hljs-keyword">const</span> GENUINE_FMS_KEY: &amp;[<span class="hljs-built_in">u8</span>] = &amp;[\n    <span class="hljs-number">0x47</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x4d</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x76</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x31</span>,\n    <span class="hljs-number">0xf0</span>, <span class="hljs-number">0xee</span>, <span class="hljs-number">0xc2</span>, <span class="hljs-number">0x4a</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0xe8</span>, <span class="hljs-number">0x2e</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xd0</span>, <span class="hljs-number">0xd1</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x9e</span>, <span class="hljs-number">0x7e</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0xec</span>, <span class="hljs-number">0x5d</span>, <span class="hljs-number">0x2d</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0xab</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xb8</span>, <span class="hljs-number">0xe6</span>, <span class="hljs-number">0x36</span>, <span class="hljs-number">0xcf</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xae</span>\n];\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">handle_first_handshake</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream) -&gt; IOResult&lt;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> c0c1: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1537</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1537</span>];\n\n    stream.read(&amp;<span class="hljs-keyword">mut</span> c0c1)?;\n\n    <span class="hljs-keyword">if</span> c0c1[<span class="hljs-number">0</span>] != <span class="hljs-number">3</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidInput.into());\n    }\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset_client = <span class="hljs-built_in">usize</span>::default();\n\n    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">4</span> {\n        offset_client += c0c1[<span class="hljs-number">9</span> + i] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n    }\n\n    offset_client = offset_client % <span class="hljs-number">728</span> + <span class="hljs-number">12</span>;\n\n    <span class="hljs-keyword">let</span> digest_client_sent = &amp;c0c1[offset_client..(offset_client + <span class="hljs-number">32</span>)];\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hmac_client = Hmac::new(Sha256::new(), &amp;GENUINE_FP_KEY[..<span class="hljs-number">30</span>]);\n\n    hmac_client.input(&amp;c0c1[<span class="hljs-number">9</span>..(<span class="hljs-number">9</span> + offset_client)]);\n    hmac_client.input(&amp;c0c1[(<span class="hljs-number">9</span> + offset_client + <span class="hljs-number">32</span>)..]);\n\n    <span class="hljs-keyword">let</span> digest_client_expected = hmac_client.result();\n\n    <span class="hljs-keyword">if</span> digest_client_sent != digest_client_expected.code() {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidData.into());\n    }\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s0s1s2: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> timestamp = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap().as_secs() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>;\n\n    s0s1s2.push(<span class="hljs-number">3</span>);\n    s0s1s2.extend_from_slice(&amp;timestamp.to_be_bytes());\n    s0s1s2.extend_from_slice(&amp;[<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>]);\n\n    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">1528</span> {\n        s0s1s2.push(random());\n    }\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset_server = <span class="hljs-built_in">usize</span>::default();\n\n    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">4</span> {\n        offset_server += s0s1s2[<span class="hljs-number">9</span> + i] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n    }\n\n    offset_server = offset_server % <span class="hljs-number">728</span> + <span class="hljs-number">12</span>;\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hmac_server = Hmac::new(Sha256::new(), &amp;GENUINE_FMS_KEY[..<span class="hljs-number">36</span>]);\n\n    hmac_server.input(&amp;s0s1s2[<span class="hljs-number">9</span>..(<span class="hljs-number">9</span> + offset_server)]);\n    hmac_server.input(&amp;s0s1s2[(<span class="hljs-number">9</span> + offset_server + <span class="hljs-number">32</span>)..]);\n\n    <span class="hljs-keyword">let</span> digest_server = hmac.result().code();\n\n    s0s1s2[(<span class="hljs-number">9</span> + offset_server)..(<span class="hljs-number">9</span> + offset_server + <span class="hljs-number">32</span>)].copy_from_slice(digest_server);\n\n\n    hmac_client = Hmac::new(Sha256::new(), &amp;GENUINE_FP_KEY);\n    hmac_client.input(digest_client_sent);\n\n    <span class="hljs-keyword">let</span> digest_s2 = hmac_client.result();\n\n    hmac_client = Hmac::new(Sha256::new(), digest_s2.code());\n    hmac_client.input(c0c1[<span class="hljs-number">9</span>..(c0c1.len() - <span class="hljs-number">32</span>)]);\n\n    <span class="hljs-keyword">let</span> signature_s2 = hmac_client.result();\n\n    c0c1[(c0c1.len() - <span class="hljs-number">32</span>)..].copy_from_slice(signature_s2.code());\n    s0s1s2.extend_from_slice(&amp;c0c1[<span class="hljs-number">1</span>..]);\n    stream.write(s0s1s2.as_slice()).map(|_| s0s1s2[<span class="hljs-number">1</span>..(s0s1s2.len() - <span class="hljs-number">1536</span>)].to_vec())\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n        <span class="hljs-keyword">let</span> s1 = handle_first_handshake(&amp;<span class="hljs-keyword">mut</span> stream)?;\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> c2: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1536</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1536</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> c2)?;\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset_server_s1 = <span class="hljs-built_in">usize</span>::default();\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset_server_c2 = <span class="hljs-built_in">usize</span>::default();\n\n        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">4</span> {\n            offset_server_s1 += s1[<span class="hljs-number">8</span> + i] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n            offset_server_c2 += c2[<span class="hljs-number">8</span> + i] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n        }\n\n        offset_server_s1 = offset_server_s1 % <span class="hljs-number">728</span> + <span class="hljs-number">12</span>;\n        offset_server_c2 = offset_server_c2 % <span class="hljs-number">728</span> + <span class="hljs-number">12</span>;\n\n        <span class="hljs-keyword">let</span> digest_s1 = &amp;s1[offset_server_s1..(offset_server_s1 + <span class="hljs-number">32</span>)];\n        <span class="hljs-keyword">let</span> digest_c2 = &amp;c2[offset_server_c2..(offset_server_c2 + <span class="hljs-number">32</span>)];\n\n        <span class="hljs-keyword">if</span> digest_s1 != digest_c2 {\n            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidData.into());\n        }\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hmac = Hmac::new(Sha256::new(), GENUINE_FMS_KEY);\n\n        hmac.input(&amp;s1[..offset_server_s1]);\n        hmac.input(&amp;s1[(offset_server_s1 + <span class="hljs-number">32</span>)..]);\n\n        <span class="hljs-keyword">let</span> digest = hmac.result();\n\n        hmac = Hmac::new(Sha256::new(), digest.code());\n        hmac.input(&amp;s1[..(s1.len() - <span class="hljs-number">32</span>)]);\n\n        <span class="hljs-keyword">let</span> signature_s1 = hmac.result();\n        <span class="hljs-keyword">let</span> signature_c2 = &amp;c2[(c2.len() - <span class="hljs-number">32</span>)..];\n\n        <span class="hljs-comment">// 注: FFmpeg は何故か C2 チャンクに署名を上書きしていないようであり, FFmpeg からの応答に対してこの処理を行うと必ずエラーになる.</span>\n        <span class="hljs-keyword">if</span> signature_s1 != signature_c2 {\n            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidData.into());\n        }\n\n        <span class="hljs-comment">/* Invoke チャンクの処理に移る. */</span>\n    }\n\n    <span class="hljs-literal">Ok</span>(())\n}\n</code></pre>\n<p>上記の処理の結果, S1 チャンクの署名と C2 チャンクの署名が一致していれば二段階目のハンドシェイクは完了である. ここで, 二段階目のハンドシェイク処理にも名前をつけ以下のように変更を加えることにする.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    io::{\n        Error <span class="hljs-keyword">as</span> IOError,\n        ErrorKind,\n        Read,\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IO <span class="hljs-built_in">Result</span>,\n        Write\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    },\n    time::{\n        SystemTime\n    }\n};\n<span class="hljs-keyword">use</span> crypto::{\n    hmac::{\n        Hmac\n    },\n    sha2::{\n        Sha256\n    }\n};\n<span class="hljs-keyword">use</span> rand::prelude::*;\n\n<span class="hljs-keyword">const</span> GENUINE_FP_KEY: &amp;[<span class="hljs-built_in">u8</span>] = &amp;[\n    <span class="hljs-number">0x47</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x4d</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x76</span>,\n    <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-number">0xee</span>, <span class="hljs-number">0xc2</span>, <span class="hljs-number">0x4a</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0xe8</span>, <span class="hljs-number">0x2e</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xd0</span>, <span class="hljs-number">0xd1</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x9e</span>, <span class="hljs-number">0x7e</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0xec</span>, <span class="hljs-number">0x5d</span>, <span class="hljs-number">0x2d</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0xab</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xb8</span>, <span class="hljs-number">0xe6</span>, <span class="hljs-number">0x36</span>, <span class="hljs-number">0xcf</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xae</span>\n];\n<span class="hljs-keyword">const</span> GENUINE_FMS_KEY: &amp;[<span class="hljs-built_in">u8</span>] = &amp;[\n    <span class="hljs-number">0x47</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x4d</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x76</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x31</span>,\n    <span class="hljs-number">0xf0</span>, <span class="hljs-number">0xee</span>, <span class="hljs-number">0xc2</span>, <span class="hljs-number">0x4a</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0xe8</span>, <span class="hljs-number">0x2e</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xd0</span>, <span class="hljs-number">0xd1</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x9e</span>, <span class="hljs-number">0x7e</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0xec</span>, <span class="hljs-number">0x5d</span>, <span class="hljs-number">0x2d</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0xab</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xb8</span>, <span class="hljs-number">0xe6</span>, <span class="hljs-number">0x36</span>, <span class="hljs-number">0xcf</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xae</span>\n];\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">handle_first_handshake</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream) -&gt; IOResult&lt;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> c0c1: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1537</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1537</span>];\n\n    stream.read(&amp;<span class="hljs-keyword">mut</span> c0c1)?;\n\n    <span class="hljs-keyword">if</span> c0c1[<span class="hljs-number">0</span>] != <span class="hljs-number">3</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidInput.into());\n    }\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset_client = <span class="hljs-built_in">usize</span>::default();\n\n    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">4</span> {\n        offset_client += c0c1[<span class="hljs-number">9</span> + i] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n    }\n\n    offset_client = offset_client % <span class="hljs-number">728</span> + <span class="hljs-number">12</span>;\n\n    <span class="hljs-keyword">let</span> digest_client_sent = &amp;c0c1[offset_client..(offset_client + <span class="hljs-number">32</span>)];\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hmac_client = Hmac::new(Sha256::new(), &amp;GENUINE_FP_KEY[..<span class="hljs-number">30</span>]);\n\n    hmac_client.input(&amp;c0c1[<span class="hljs-number">9</span>..(<span class="hljs-number">9</span> + offset_client)]);\n    hmac_client.input(&amp;c0c1[(<span class="hljs-number">9</span> + offset_client + <span class="hljs-number">32</span>)..]);\n\n    <span class="hljs-keyword">let</span> digest_client_expected = hmac_client.result();\n\n    <span class="hljs-keyword">if</span> digest_client_sent != digest_client_expected.code() {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidData.into());\n    }\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s0s1s2: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> timestamp = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap().as_secs() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>;\n\n    s0s1s2.push(<span class="hljs-number">3</span>);\n    s0s1s2.extend_from_slice(&amp;timestamp.to_be_bytes());\n    s0s1s2.extend_from_slice(&amp;[<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>]);\n\n    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">1528</span> {\n        s0s1s2.push(random());\n    }\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset_server = <span class="hljs-built_in">usize</span>::default();\n\n    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">4</span> {\n        offset_server += s0s1s2[<span class="hljs-number">9</span> + i] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n    }\n\n    offset_server = offset_server % <span class="hljs-number">728</span> + <span class="hljs-number">12</span>;\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hmac_server = Hmac::new(Sha256::new(), &amp;GENUINE_FMS_KEY[..<span class="hljs-number">36</span>]);\n\n    hmac_server.input(&amp;s0s1s2[<span class="hljs-number">9</span>..(<span class="hljs-number">9</span> + offset_server)]);\n    hmac_server.input(&amp;s0s1s2[(<span class="hljs-number">9</span> + offset_server + <span class="hljs-number">32</span>)..]);\n\n    <span class="hljs-keyword">let</span> digest_server = hmac.result().code();\n\n    s0s1s2[(<span class="hljs-number">9</span> + offset_server)..(<span class="hljs-number">9</span> + offset_server + <span class="hljs-number">32</span>)].copy_from_slice(digest_server);\n\n\n    hmac_client = Hmac::new(Sha256::new(), &amp;GENUINE_FP_KEY);\n    hmac_client.input(digest_client_sent);\n\n    <span class="hljs-keyword">let</span> digest_s2 = hmac_client.result();\n\n    hmac_client = Hmac::new(Sha256::new(), digest_s2.code());\n    hmac_client.input(c0c1[<span class="hljs-number">9</span>..(c0c1.len() - <span class="hljs-number">32</span>)]);\n\n    <span class="hljs-keyword">let</span> signature_s2 = hmac_client.result();\n\n    c0c1[(c0c1.len() - <span class="hljs-number">32</span>)..].copy_from_slice(signature_s2.code());\n    s0s1s2.extend_from_slice(&amp;c0c1[<span class="hljs-number">1</span>..]);\n    stream.write(s0s1s2.as_slice()).map(|_| s0s1s2[<span class="hljs-number">1</span>..(s0s1s2.len() - <span class="hljs-number">1536</span>)].to_vec())\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">handle_second_handshake</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, s1: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> c2: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1536</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1536</span>];\n\n    stream.read(&amp;<span class="hljs-keyword">mut</span> c2)?;\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset_server_s1 = <span class="hljs-built_in">usize</span>::default();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset_server_c2 = <span class="hljs-built_in">usize</span>::default();\n\n    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">4</span> {\n        offset_server_s1 += s1[<span class="hljs-number">8</span> + i] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n        offset_server_c2 += c2[<span class="hljs-number">8</span> + i] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n    }\n\n    offset_server_s1 = offset_server_s1 % <span class="hljs-number">728</span> + <span class="hljs-number">12</span>;\n    offset_server_c2 = offset_server_c2 % <span class="hljs-number">728</span> + <span class="hljs-number">12</span>;\n\n    <span class="hljs-keyword">let</span> digest_s1 = &amp;s1[offset_server_s1..(offset_server_s1 + <span class="hljs-number">32</span>)];\n    <span class="hljs-keyword">let</span> digest_c2 = &amp;c2[offset_server_c2..(offset_server_c2 + <span class="hljs-number">32</span>)];\n\n    <span class="hljs-keyword">if</span> digest_s1 != digest_c2 {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidData.into());\n    }\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hmac = Hmac::new(Sha256::new(), GENUINE_FMS_KEY);\n\n    hmac.input(&amp;s1[..offset_server_s1]);\n    hmac.input(&amp;s1[(offset_server_s1 + <span class="hljs-number">32</span>)..]);\n\n    <span class="hljs-keyword">let</span> digest = hmac.result();\n\n    hmac = Hmac::new(Sha256::new(), digest.code());\n    hmac.input(&amp;s1[..(s1.len() - <span class="hljs-number">32</span>)]);\n\n    <span class="hljs-keyword">let</span> signature_s1 = hmac.result();\n    <span class="hljs-keyword">let</span> signature_c2 = &amp;c2[(c2.len() - <span class="hljs-number">32</span>)..];\n\n    <span class="hljs-comment">// 注: FFmpeg は何故か C2 チャンクに署名を上書きしていないようであり, FFmpeg からの応答に対してこの処理を行うと必ずエラーになる.</span>\n    <span class="hljs-keyword">if</span> signature_s1 != signature_c2 {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidData.into());\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Ok</span>(());\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n        <span class="hljs-keyword">let</span> s1 = handle_first_handshake(&amp;<span class="hljs-keyword">mut</span> stream)?;\n\n        handle_second_handshake(&amp;<span class="hljs-keyword">mut</span> stream, s1)?;\n\n        <span class="hljs-comment">/* Invoke チャンクの処理に移る. */</span>\n    }\n\n    <span class="hljs-literal">Ok</span>(())\n}\n</code></pre>\n<h2 id="invoke-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E5%87%A6%E7%90%86"><a class="header-anchor" href="#invoke-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E5%87%A6%E7%90%86">¶</a> Invoke チャンクの処理</h2>\n<p>ハンドシェイクが完了したら, 実際の RTMP パケットをサーバ側とクライアント側で相互に送受信しあう. ここで, この段階で実際に送受信される Invoke チャンクの種類を以下に記す.</p>\n<ol>\n<li>connect</li>\n<li>releaseStream</li>\n<li>onFCPublish</li>\n<li>createStream</li>\n<li>publish</li>\n</ol>\n<h3 id="connect"><a class="header-anchor" href="#connect">¶</a> connect</h3>\n<p>二段階目のハンドシェイクが完了した後, サーバ側はクライアント側から以下の構造を持つチャンクを受信する.</p>\n<p>チャンク基本ヘッダ:</p>\n<ul>\n<li>チャンクストリームID: 3</li>\n<li>チャンクメッセージヘッダのフォーマット: 0</li>\n</ul>\n<p>チャンクメッセージヘッダ:</p>\n<ul>\n<li>タイムスタンプ: 0</li>\n<li>メッセージ長: 不定（クライアント側が指定した接続先 URL 等によって変動する）</li>\n<li>メッセージ種別ID: 20</li>\n<li>チャンクメッセージ ID: 0</li>\n</ul>\n<p>拡張タイムスタンプ:</p>\n<p>なし.</p>\n<p>チャンクデータ:</p>\n<ul>\n<li>コマンド名: connect</li>\n<li>トランザクション ID: 1</li>\n<li>AMFオブジェクト (AMF 型番号: 3)\n<ul>\n<li>app: 不定</li>\n<li>type: nonprivate</li>\n<li>flashVer: FMLE/3.0 (compatible; Lavf 58.29.100)</li>\n<li>tcUrl: 不定</li>\n<li>オブジェクト型終了マーカ（空の AMF 文字列のフィールド名と型番号 9 の値のペア）</li>\n</ul>\n</li>\n</ul>\n<p>ここで, app および tcUrl の値が依存する部分を以下に記す.</p>\n<ul>\n<li>app: rtmp://example.com/appName/instance 中の <em>appName</em></li>\n<li>tcUrl: rtmp://example.com/appName/instance (クライアント側が指定する接続先 URL そのもの)</li>\n</ul>\n<h4 id="%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E5%9F%BA%E6%9C%AC%E6%A7%8B%E9%80%A0"><a class="header-anchor" href="#%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E5%9F%BA%E6%9C%AC%E6%A7%8B%E9%80%A0">¶</a> チャンクの基本構造</h4>\n<p>上記の構造を Rust で表現する例を以下に記す.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    collections::{\n        HashMap\n    }\n};\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MessageHeader</span></span> {\n    timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    <span class="hljs-comment">// Rust の言語仕様を考慮すると usize が好ましいのだが, 3 bytes の上限を可能な限り超えさせないようにしつつ, 受信データの変換効率を考慮するため u32 型を選択する.</span>\n    message_length: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_type: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt;,\n    message_id: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InvokeCommand</span></span> {\n    command_name: <span class="hljs-built_in">String</span>,\n    transaction_id: <span class="hljs-built_in">u64</span>,\n    command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ChunkData</span></span> {\n    Invoke(InvokeCommand)\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span></span> {\n    basic_header: BasicHeader,\n    message_header: MessageHeader,\n    <span class="hljs-comment">// 拡張タイムスタンプがない場合もあるため.</span>\n    extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    data: ChunkData\n}\n</code></pre>\n<h4 id="%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%83%98%E3%83%83%E3%83%80%E3%81%AE%E8%AA%AD%E3%81%BF%E5%8F%96%E3%82%8A"><a class="header-anchor" href="#%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%83%98%E3%83%83%E3%83%80%E3%81%AE%E8%AA%AD%E3%81%BF%E5%8F%96%E3%82%8A">¶</a> チャンクヘッダの読み取り</h4>\n<p>次に, ストリームからパケットを読み取りチャンクに変換していく処理を以下に記す.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    io::{\n        Error <span class="hljs-keyword">as</span> IOError,\n        ErrorKind,\n        Read,\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    };\n};\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MessageHeader</span></span> {\n    timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_length: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_type: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt;,\n    message_id: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n\n        <span class="hljs-comment">/* ハンドシェイクは完了しているとみなす. */</span>\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> first_byte: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> first_byte)?;\n\n        <span class="hljs-comment">// 先頭 2 bits がチャンクメッセージヘッダの形式を表す番号でる.</span>\n        <span class="hljs-keyword">let</span> message_header_format = (first_byte[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0xc0</span>) &gt;&gt; <span class="hljs-number">6</span>;\n        <span class="hljs-comment">// 残りの 6 bits の値でチャンクストリーム ID の位置を特定する.</span>\n        <span class="hljs-keyword">let</span> chunk_id = <span class="hljs-keyword">match</span> first_byte[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x3f</span> {\n            <span class="hljs-comment">// 0 ならば, 次の 1 byte がそれである.</span>\n            <span class="hljs-number">0</span> =&gt; {\n                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> chunk_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n                stream.read(&amp;<span class="hljs-keyword">mut</span> chunk_id_bytes)?;\n                <span class="hljs-comment">// 直前の 6 bits の値が 0 の場合は実際の値より 64 少ないものとして受信するので, 正しい値に修正する.</span>\n                <span class="hljs-comment">// この場合はビッグエンディアンであることに注意する.</span>\n                (<span class="hljs-built_in">u8</span>::from_be_bytes(chunk_id_bytes) + <span class="hljs-number">64</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>\n            },\n            <span class="hljs-comment">// 1 の場合は, 次の 2 bytes がそれである.</span>\n            <span class="hljs-number">1</span> =&gt; {\n                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> chunk_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">2</span>];\n\n                stream.read(&amp;<span class="hljs-keyword">mut</span> chunk_id_bytes)?;\n                <span class="hljs-comment">// 実際の値より 64 少ないものとして受信するのは前段と同様であるが, この場合はリトルエンディアンであることに注意する.</span>\n                <span class="hljs-built_in">u16</span>::from_le_bytes(chunk_id_bytes) + <span class="hljs-number">64</span>\n            },\n            <span class="hljs-comment">// 1 より大きいなら, それ自体がチャンクストリーム ID である. </span>\n            n =&gt; n\n        };\n        <span class="hljs-keyword">let</span> basic_header = BasicHeader {\n            message_header_format,\n            chunk_id\n        };\n        <span class="hljs-keyword">let</span> timestamp;\n        <span class="hljs-keyword">let</span> message_length;\n        <span class="hljs-keyword">let</span> message_type;\n        <span class="hljs-keyword">let</span> message_header = <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">0</span> {\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_type_byte: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n            stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n            stream.read(&amp;<span class="hljs-keyword">mut</span> message_length_bytes)?;\n            stream.read(&amp;<span class="hljs-keyword">mut</span> message_type_byte)?;\n            stream.read(&amp;<span class="hljs-keyword">mut</span> message_id_bytes)?;\n\n            <span class="hljs-comment">// from_*_bytes/to_*_bytes はそれぞれ配列とプリミティブ型を相互に変換するための transmute() のラッパであるが, プリミティブ型と同じサイズの配列を受け取るように実装されているため, ここでサイズを調整しておく.</span>\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n            timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n            message_length_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;message_length_bytes);\n\n            timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n            message_length = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(message_length_tmp));\n            message_type = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u8</span>::from_be_bytes(message_type_byte));\n\n            <span class="hljs-keyword">let</span> message_id = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_le_bytes(message_id_bytes));\n\n            MessageHeader {\n                timestamp,\n                message_length,\n                message_type,\n                message_id\n            }\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">1</span> {\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_type_byte: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n            stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n            stream.read(&amp;<span class="hljs-keyword">mut</span> message_length_bytes)?;\n            stream.read(&amp;<span class="hljs-keyword">mut</span> message_type_byte)?;\n\n            <span class="hljs-comment">// 前段と同様の理由である.</span>\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n            timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n            message_length_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;message_length_bytes);\n\n            timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n            message_length = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(message_length_tmp));\n            message_type = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u8</span>::from_be_bytes(message_type_byte));\n\n            MessageHeader {\n                timestamp,\n                message_length,\n                message_type,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">2</span> {\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n\n            stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n\n            <span class="hljs-comment">// こちらも同様である.</span>\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n            timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n\n            timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n            message_length = <span class="hljs-literal">None</span>;\n            message_type = <span class="hljs-literal">None</span>;\n\n            MessageHeader {\n                timestamp,\n                message_length,\n                message_type,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        } <span class="hljs-keyword">else</span> {\n            timestamp = <span class="hljs-literal">None</span>;\n            message_length = <span class="hljs-literal">None</span>;\n            message_type = <span class="hljs-literal">None</span>;\n\n            MessageHeader {\n                timestamp,\n                message_length,\n                message_type,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        };\n        <span class="hljs-keyword">let</span> extended_timestamp = <span class="hljs-keyword">match</span> timestamp {\n            <span class="hljs-literal">Some</span>(n) <span class="hljs-keyword">if</span> n == <span class="hljs-number">0x00ffffff</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span> =&gt; {\n                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> extended_timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n                stream.read(&amp;<span class="hljs-keyword">mut</span> extended_timestamp_bytes)?;\n                <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(extended_timestamp_bytes))\n            },\n            _ =&gt; <span class="hljs-literal">None</span>\n        };\n\n        <span class="hljs-comment">/* チャンクデータの読み取り処理へ移る. */</span>\n    }\n\n    <span class="hljs-literal">Ok</span>(())\n}\n</code></pre>\n<p>上記の処理過程でエラーが一つも発生しなければ, チャンクデータまでのパケットの読み取りは成功である.</p>\n<h4 id="%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E8%AA%AD%E3%81%BF%E5%8F%96%E3%82%8A"><a class="header-anchor" href="#%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E8%AA%AD%E3%81%BF%E5%8F%96%E3%82%8A">¶</a> チャンクデータの読み取り</h4>\n<p>次に, チャンクデータを読み取る例を以下に記す. ここで, 送信されるチャンクデータのパターンを改めて以下に記す.</p>\n<p>チャンクメッセージヘッダ中のメッセージ長の値が:</p>\n<ul>\n<li>所定のチャンクサイズ以下の場合は, メッセージ長と丁度同じサイズのチャンクデータが送信される.</li>\n<li>そうでない場合は, チャンクデータが所定のチャンクサイズ単位で区切られ, それらの区切られたチャンクの間にはチャンク基本ヘッダと形式 3 のチャンクメッセージヘッダが挿入される. (つまりチャンク基本ヘッダのみのヘッダが挿入される)</li>\n</ul>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    io::{\n        Error <span class="hljs-keyword">as</span> IOError,\n        ErrorKind,\n        Read,\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    }\n};\n\n<span class="hljs-comment">// 公式仕様書が指定しているデフォルトのチャンクサイズである. 実際のチャンクサイズの指定の仕方については後述する.</span>\n<span class="hljs-keyword">const</span> DEFAULT_CHUNK_SIZE: <span class="hljs-built_in">u32</span> = <span class="hljs-number">128</span>;\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n\n        <span class="hljs-comment">/* 拡張タイムスタンプの読み取りまでは完了しているとみなす. */</span>\n        <span class="hljs-comment">// message_length は前段のチャンクメッセージヘッダから読み取ったものを使う.</span>\n        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = message_length {\n            <span class="hljs-keyword">let</span> splits = <span class="hljs-keyword">if</span> message_length &lt;= DEFAULT_CHUNK_SIZE {\n                <span class="hljs-comment">// チャンクデータのメッセージ長が所定のチャンクサイズに収まっている場合は, 間のヘッダのことは考慮しなくてよい.</span>\n                <span class="hljs-number">0</span>\n            } <span class="hljs-keyword">else</span> {\n                <span class="hljs-comment">// 以下のチャンクデータが流れてくることを想定する.</span>\n                <span class="hljs-comment">//</span>\n                <span class="hljs-comment">// chunk_data[0] + headers[1] + chunk_data[1] + ... + chunk_data[n]</span>\n                <span class="hljs-comment">//</span>\n                <span class="hljs-comment">// ここで,</span>\n                <span class="hljs-comment">//</span>\n                <span class="hljs-comment">// * chunk_data[0]: 128 bytes</span>\n                <span class="hljs-comment">// * headers[1]: 1 byte</span>\n                <span class="hljs-comment">// * chunk_data[1]: 128 bytes</span>\n                <span class="hljs-comment">// * chunk_data[n]: less than 128 bytes</span>\n                <span class="hljs-comment">//</span>\n                <span class="hljs-comment">// である. 除算で単純に区切ろうとすると, 最後にある n 個目のチャンクデータを無視してしまう. したがって、剰余が存在するかどうかを加味しておく.</span>\n                <span class="hljs-comment">// (bool は整数型にキャストが可能であり, false なら 0, true なら 1 となる)</span>\n                message_length / DEFAULT_CHUNK_SIZE + (message_length % DEFAULT_CHUNK_SIZE != <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>;\n            }\n            <span class="hljs-keyword">let</span> actual_message_length = (message_length + splits) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::with_capacity(actual_message_length);\n\n            <span class="hljs-comment">// set_len() は Vec の長さを強制的に固定してしまうのでメモリ安全ではないが, Vec を固定長 slice として渡すための措置である.</span>\n            <span class="hljs-keyword">unsafe</span> {\n                data_bytes.set_len(actual_message_length);\n            }\n\n            <span class="hljs-comment">// read_to_end() を呼べば Vec のまま渡せるが, あちらは終端に辿り着くまでストリームをブロックしてしまう.</span>\n            <span class="hljs-comment">// そしてネットワークストリームには終端がないため, それはいつまでも解放されなくなってしまう.</span>\n            stream.read(data_bytes.as_mut_slice())?;\n\n            <span class="hljs-comment">/* 受信したチャンクデータの中から間に挟まっているヘッダを取り除く処理. */</span>\n            <span class="hljs-keyword">if</span> splits &gt; <span class="hljs-number">0</span> {\n                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> split_data: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..splits {\n                    <span class="hljs-keyword">let</span> start = <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> {\n                        (DEFAULT_CHUNK_SIZE * i) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>\n                    } <span class="hljs-keyword">else</span> {\n                        <span class="hljs-comment">// 間に挟まっているヘッダを無視するために 1 byte ずらす.</span>\n                        (DEFAULT_CHUNK_SIZE * i + <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>\n                    };\n                    <span class="hljs-keyword">let</span> end = start + DEFAULT_CHUNK_SIZE <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n\n                    split_data.extend_from_slice(&amp;data_bytes[start..end]);\n                }\n\n                <span class="hljs-comment">// 詰まりものが無事に取れたら, 再代入してスコープの外に出す.</span>\n                data_bytes = split_data;\n            }\n\n            <span class="hljs-comment">/* 読み取ったチャンクデータをデコードする処理へ移る. */</span>\n        }\n    }\n\n    <span class="hljs-literal">Ok</span>(())\n}\n</code></pre>\n<p>上記の過程でエラーが発生しなければ, チャンクデータのパケットの読み取りは成功である.</p>\n<h4 id="%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E3%81%B8%E3%81%AE%E5%A4%89%E6%8F%9B"><a class="header-anchor" href="#%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%E3%81%B8%E3%81%AE%E5%A4%89%E6%8F%9B">¶</a> データ構造への変換</h4>\n<p>次に, 読み取ったチャンクデータを Invoke コマンドにデコードする例を以下に示す. Invoke コマンドの内容は AMF0 (Action Message Format version 0) によりエンコードされており, パケットをデコードする際には当該メッセージフォーマットをデコードすることも考慮する必要がある. ここで, Invoke チャンクのデータに使われている AMF0 のデータ型を以下に記す.</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">フィールド</th>\n<th style="text-align:right">マーカの数字</th>\n<th style="text-align:left">AMF0 のデータ型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left">コマンド名</td>\n<td style="text-align:right">2</td>\n<td style="text-align:left"><code>String</code></td>\n</tr>\n<tr>\n<td style="text-align:left">トランザクション ID</td>\n<td style="text-align:right">0</td>\n<td style="text-align:left"><code>Number</code></td>\n</tr>\n<tr>\n<td style="text-align:left">コマンドオブジェクト</td>\n<td style="text-align:right">3</td>\n<td style="text-align:left"><code>Object</code></td>\n</tr>\n</tbody>\n</table>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    collections::{\n        HashMap\n    },\n    io::{\n        Error <span class="hljs-keyword">as</span> IOError,\n        ErrorKind,\n        Read,\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    }\n};\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    Unknown\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InvokeCommand</span></span> {\n    command_name: <span class="hljs-built_in">String</span>,\n    transaction_id: <span class="hljs-built_in">f64</span>,\n    command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    Invoke(InvokeCommand)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n\n        <span class="hljs-comment">/* チャンクデータの読み取りまでは完了しているとみなす. */</span>\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset = <span class="hljs-built_in">usize</span>::default();\n        <span class="hljs-comment">// Command Name が AMF String 型だということは明確である.</span>\n        <span class="hljs-keyword">let</span> command_name_type = data_bytes[offset];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> command_name_length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">2</span>];\n\n        offset += <span class="hljs-number">1</span>;\n        command_name_length_bytes.copy_from_slice(&amp;data_bytes[offset..(offset + <span class="hljs-number">2</span>)]);\n        offset += <span class="hljs-number">2</span>;\n\n        <span class="hljs-keyword">let</span> command_name_length = <span class="hljs-built_in">u16</span>::from_be_bytes(command_name_length_bytes) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n        <span class="hljs-comment">// data_bytes は前段で読み取ったチャンクデータである.</span>\n        <span class="hljs-keyword">let</span> command_name = <span class="hljs-built_in">String</span>::from_utf8(data_bytes[offset..(offset + command_name_length)].to_vec()).map_err(\n            |_| IOError::from(ErrorKind::InvalidData)\n        )?;\n\n        offset += command_name_length;\n\n        <span class="hljs-comment">// トランザクション ID についても AMF Number 型であるということは明確である.</span>\n        <span class="hljs-keyword">let</span> transaction_id_type = data_bytes[offset];\n\n        offset += <span class="hljs-number">1</span>;\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> transaction_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">8</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">8</span>];\n\n        transaction_id_bytes.copy_from_slice(&amp;data_bytes[offset..(offset + <span class="hljs-number">8</span>)]);\n        offset += <span class="hljs-number">8</span>;\n\n        <span class="hljs-keyword">let</span> transaction_id = <span class="hljs-built_in">f64</span>::from_bits(<span class="hljs-built_in">u64</span>::from_be_bytes(transaction_id_bytes));\n        <span class="hljs-comment">// Command Object についても AMF Object 型であるということは明確である.</span>\n        <span class="hljs-keyword">let</span> command_object_type = data_bytes[offset];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n        <span class="hljs-comment">// AMF Object End 型（マーカ）は空の AMF String 型の後に続く.</span>\n        <span class="hljs-keyword">while</span> &amp;data_bytes[offset..(offset + <span class="hljs-number">3</span>)] != &amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>] {\n            <span class="hljs-comment">// AMF Object 型のフィールド名はマーカのない AMF String 型である.</span>\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> name_length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">2</span>];\n\n            name_length_bytes.copy_from_slice(&amp;data_bytes[offset..(offset + <span class="hljs-number">2</span>)]);\n            offset += <span class="hljs-number">2</span>;\n\n            <span class="hljs-keyword">let</span> name_length = <span class="hljs-built_in">u16</span>::from_be_bytes(name_length_bytes) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n            <span class="hljs-keyword">let</span> name = <span class="hljs-built_in">String</span>::from_utf8(data_bytes[offset..(offset + name_length)].to_vec()).map_err(\n                |_| IOError::from(ErrorKind::InvalidData)\n            )?;\n\n            offset += name_length;\n\n            <span class="hljs-comment">// AMF Object 型のフィールド値は何らかの AMF 型である. 従って, マーカに応じてデコードする内容を切り替える必要がある.</span>\n            <span class="hljs-comment">// ここで, Command Object が持っているフィールドの型は以下の三種類である:</span>\n            <span class="hljs-comment">//</span>\n            <span class="hljs-comment">// * Number</span>\n            <span class="hljs-comment">// * Boolean</span>\n            <span class="hljs-comment">// * String</span>\n            <span class="hljs-keyword">let</span> value = <span class="hljs-keyword">match</span> data[offset] {\n                <span class="hljs-comment">// AMF Number 型である場合</span>\n                <span class="hljs-number">0</span> =&gt; {\n                    <span class="hljs-comment">// 読み終えたマーカの位置から先に進める.</span>\n                    offset += <span class="hljs-number">1</span>;\n\n                    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> number_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">8</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">8</span>];\n\n                    number_bytes.copy_from_slice(&amp;data_bytes[offset..(offset + <span class="hljs-number">8</span>)]);\n                    offset += <span class="hljs-number">8</span>;\n\n                    <span class="hljs-keyword">let</span> number = <span class="hljs-built_in">f64</span>::from_bits(<span class="hljs-built_in">u64</span>::from_be_bytes());\n\n                    AmfData::Number(number)\n                },\n                <span class="hljs-comment">// AMF Boolean 型である場合</span>\n                <span class="hljs-number">1</span> =&gt; {\n                    <span class="hljs-comment">// 読み終えたマーカの位置から先に進める.</span>\n                    offset += <span class="hljs-number">1</span>;\n\n                    <span class="hljs-keyword">let</span> boolean = data_bytes[offset] &gt; <span class="hljs-number">0</span>;\n\n                    offset += <span class="hljs-number">1</span>;\n                    AmfData::Boolean(boolean)\n                },\n                <span class="hljs-comment">// AMF String 型である場合</span>\n                <span class="hljs-number">2</span> =&gt; {\n                    <span class="hljs-comment">// 読み終えたマーカの位置から先に進める.</span>\n                    offset += <span class="hljs-number">1</span>;\n\n                    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> string_length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">2</span>];\n\n                    string_length_bytes.copy_from_slice(&amp;data_bytes[offset..(offset + <span class="hljs-number">2</span>)]);\n                    offset += <span class="hljs-number">2</span>;\n\n                    <span class="hljs-keyword">let</span> string_length = <span class="hljs-built_in">u16</span>::from_be_bytes(string_length_bytes) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n                    <span class="hljs-keyword">let</span> string = <span class="hljs-built_in">String</span>::from_utf8(data_bytes[offset..(offset + string_length)]).map_err(\n                        |_| IOError::from(ErrorKind::InvalidData)\n                    )?;\n\n                    offset += string_length;\n                    AmfData::<span class="hljs-built_in">String</span>(string)\n                },\n                _ =&gt; {\n                    <span class="hljs-comment">/* 残りの AMF データ型の実装は後述する. */</span>\n                    AmfData::Unknown\n                }\n            };\n\n            command_object.insert(name, value);\n        }\n\n        <span class="hljs-keyword">let</span> data = Data::Invoke(\n            InvokeCommand {\n                command_name,\n                transaction_id,\n                command_object\n            }\n        );\n\n        <span class="hljs-comment">/* Invoke の返送チャンクを送信する処理に移る. */</span>\n    }\n\n    <span class="hljs-literal">Ok</span>(())\n}\n</code></pre>\n<p>上記の実装より, AMF 型のデコード処理は重複しうることがわかる. 従って, 当該部分を関数化して処理の分岐を容易にする.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    collections::{\n        HashMap\n    },\n    io::{\n        Error <span class="hljs-keyword">as</span> IOError,\n        ErrorKind,\n        Read,\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    }\n};\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    Unknown\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InvokeCommand</span></span> {\n    command_name: <span class="hljs-built_in">String</span>,\n    transaction_id: <span class="hljs-built_in">f64</span>,\n    command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    Invoke(InvokeCommand)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_number</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> number_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">8</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">8</span>];\n\n    number_bytes.copy_from_slice(&amp;data[*offset..(*offset + <span class="hljs-number">8</span>)]);\n    *offset += <span class="hljs-number">8</span>;\n\n    <span class="hljs-keyword">let</span> number = <span class="hljs-built_in">f64</span>::from_bits(<span class="hljs-built_in">u64</span>::from_be_bytes(number_bytes));\n\n    <span class="hljs-literal">Ok</span>(AmfData::Number(number))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_boolean</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> boolean = data[*offset] &gt; <span class="hljs-number">0</span>;\n\n    *offset += <span class="hljs-number">1</span>;\n    <span class="hljs-literal">Ok</span>(AmfData::Boolean(boolean))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_string</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">2</span>];\n\n    length_bytes.copy_from_slice(&amp;data[*offset..(*offset + <span class="hljs-number">2</span>)]);\n    *offset += <span class="hljs-number">2</span>;\n\n    <span class="hljs-keyword">let</span> string = <span class="hljs-built_in">String</span>::from_utf8(data[*offset..(*offset + length)].to_vec()).map_err(\n        |_| IOError::from(ErrorKind::InvalidData)\n    )?;\n\n    *offset += length;\n    <span class="hljs-literal">Ok</span>(AmfData::<span class="hljs-built_in">String</span>(string))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_object</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n    <span class="hljs-keyword">while</span> &amp;data[*offset..(*offset + <span class="hljs-number">3</span>)] != &amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>] {\n        <span class="hljs-keyword">let</span> name = decode_amf_string(data, offset)?.string().unwrap();\n        <span class="hljs-keyword">let</span> value = decode_amf_data(data, offset)?;\n\n        object.insert(name, value);\n    }\n\n    <span class="hljs-literal">Ok</span>(AmfData::Object(object))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_unknown</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-comment">/* 当該部分の実装は後述する. */</span>\n    <span class="hljs-literal">Ok</span>(AmfData::Unknown)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_data</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">match</span> data[*offset] {\n        <span class="hljs-number">0</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_number(data, offset)\n        },\n        <span class="hljs-number">1</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_boolean(data, offset)\n        },\n        <span class="hljs-number">2</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_string(data, offset)\n        },\n        <span class="hljs-number">3</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_object(data, offset)\n        },\n        _ =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_unknown()\n        }\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n\n        <span class="hljs-comment">/* チャンクデータの読み取りまでは完了しているとみなす. */</span>\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset = <span class="hljs-built_in">usize</span>::default();\n        <span class="hljs-keyword">let</span> command_name = decode_amf_data(&amp;data_bytes, &amp;<span class="hljs-keyword">mut</span> offset)?;\n        <span class="hljs-keyword">let</span> transaction_id = decode_amf_data(&amp;data_bytes, &amp;<span class="hljs-keyword">mut</span> offset)?;\n        <span class="hljs-keyword">let</span> command_object = decode_amf_data(&amp;data_bytes, &amp;<span class="hljs-keyword">mut</span> offset)?;\n        <span class="hljs-keyword">let</span> data = Data::Invoke(\n            InvokeCommand {\n                command_name,\n                transaction_id,\n                command_object\n            }\n        );\n\n        <span class="hljs-comment">/* Invoke の返送チャンクを送信する処理に移る. */</span>\n    }\n\n    <span class="hljs-literal">Ok</span>(())\n}\n</code></pre>\n<p>Invoke チャンクのデコードが完了したなら, それを前段で読み取った各ヘッダと共に一つのチャンクにする.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    collections::{\n        HashMap\n    },\n    io::{\n        Error <span class="hljs-keyword">as</span> IOError,\n        ErrorKind,\n        Read,\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    }\n};\n\n<span class="hljs-keyword">const</span> DEFAULT_CHUNK_SIZE: <span class="hljs-built_in">u32</span> = <span class="hljs-number">128</span>;\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MessageHeader</span></span> {\n    timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_length: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_type: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt;,\n    message_id: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    Unknown\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InvokeCommand</span></span> {\n    command_name: <span class="hljs-built_in">String</span>,\n    transaction_id: <span class="hljs-built_in">f64</span>,\n    command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    Invoke(InvokeCommand)\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span></span> {\n    basic_header: BasicHeader,\n    message_header: MessageHeader,\n    extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    data: Data\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_number</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> number_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">8</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">8</span>];\n\n    number_bytes.copy_from_slice(&amp;data[*offset..(*offset + <span class="hljs-number">8</span>)]);\n    *offset += <span class="hljs-number">8</span>;\n\n    <span class="hljs-keyword">let</span> number = <span class="hljs-built_in">f64</span>::from_bits(<span class="hljs-built_in">u64</span>::from_be_bytes(number_bytes));\n\n    <span class="hljs-literal">Ok</span>(AmfData::Number(number))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_boolean</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> boolean = data[*offset] &gt; <span class="hljs-number">0</span>;\n\n    *offset += <span class="hljs-number">1</span>;\n    <span class="hljs-literal">Ok</span>(AmfData::Boolean(boolean))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_string</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">2</span>];\n\n    length_bytes.copy_from_slice(&amp;data[*offset..(*offset + <span class="hljs-number">2</span>)]);\n    *offset += <span class="hljs-number">2</span>;\n\n    <span class="hljs-keyword">let</span> string = <span class="hljs-built_in">String</span>::from_utf8(data[*offset..(*offset + length)].to_vec()).map_err(\n        |_| IOError::from(ErrorKind::InvalidData)\n    )?;\n\n    *offset += length;\n    <span class="hljs-literal">Ok</span>(AmfData::<span class="hljs-built_in">String</span>(string))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_object</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n    <span class="hljs-keyword">while</span> &amp;data[*offset..(*offset + <span class="hljs-number">3</span>)] != &amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>] {\n        <span class="hljs-keyword">let</span> name = decode_amf_string(data, offset)?.string().unwrap();\n        <span class="hljs-keyword">let</span> value = decode_amf_data(data, offset)?;\n\n        object.insert(name, value);\n    }\n\n    <span class="hljs-literal">Ok</span>(AmfData::Object(object))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_unknown</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-comment">/* 当該部分の実装は後述する. */</span>\n    <span class="hljs-literal">Ok</span>(AmfData::Unknown)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_data</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">match</span> data[*offset] {\n        <span class="hljs-number">0</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_number(data, offset)\n        },\n        <span class="hljs-number">1</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_boolean(data, offset)\n        },\n        <span class="hljs-number">2</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_string(data, offset)\n        },\n        <span class="hljs-number">3</span> =&gt; {\n            offset += <span class="hljs-number">1</span>;\n            decode_amf_object(data, offset)\n        },\n        _ =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_unknown()\n        }\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n\n        <span class="hljs-comment">/* ハンドシェイクは完了しているとみなす. */</span>\n        <span class="hljs-comment">/* チャンク基本ヘッダの読み取り処理 */</span>\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> first_byte: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> first_byte)?;\n\n        <span class="hljs-keyword">let</span> message_header_format = (first_byte[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0xc0</span>) &gt;&gt; <span class="hljs-number">6</span>;\n        <span class="hljs-keyword">let</span> chunk_id = <span class="hljs-keyword">match</span> first_byte[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x3f</span> {\n            <span class="hljs-number">0</span> =&gt; {\n                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> chunk_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n                stream.read(&amp;<span class="hljs-keyword">mut</span> chunk_id_bytes)?;\n                (<span class="hljs-built_in">u8</span>::from_be_bytes(chunk_id_bytes) + <span class="hljs-number">64</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>\n            },\n            <span class="hljs-number">1</span> =&gt; {\n                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> chunk_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">2</span>];\n\n                stream.read(&amp;<span class="hljs-keyword">mut</span> chunk_id_bytes)?;\n                <span class="hljs-built_in">u16</span>::from_le_bytes(chunk_id_bytes) + <span class="hljs-number">64</span>\n            },\n            n =&gt; n\n        };\n        <span class="hljs-keyword">let</span> basic_header = BasicHeader {\n            message_header_format,\n            chunk_id\n        };\n        <span class="hljs-comment">/* チャンクメッセージヘッダの読み取り処理. */</span>\n        <span class="hljs-keyword">let</span> timestamp;\n        <span class="hljs-keyword">let</span> message_length;\n        <span class="hljs-keyword">let</span> message_type;\n        <span class="hljs-keyword">let</span> message_header = <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">0</span> {\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_type_byte: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n            stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n            stream.read(&amp;<span class="hljs-keyword">mut</span> message_length_bytes)?;\n            stream.read(&amp;<span class="hljs-keyword">mut</span> message_type_byte)?;\n            stream.read(&amp;<span class="hljs-keyword">mut</span> message_id_bytes)?;\n\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n            timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n            message_length_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;message_length_bytes);\n\n            timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n            message_length = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(message_length_tmp));\n            message_type = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u8</span>::from_be_bytes(message_type_byte));\n\n            <span class="hljs-keyword">let</span> message_id = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_le_bytes(message_id_bytes));\n\n            MessageHeader {\n                timestamp,\n                message_length,\n                message_type,\n                message_id\n            }\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">1</span> {\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_type_byte: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n            stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n            stream.read(&amp;<span class="hljs-keyword">mut</span> message_length_bytes)?;\n            stream.read(&amp;<span class="hljs-keyword">mut</span> message_type_byte)?;\n\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n            timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n            message_length_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;message_length_bytes);\n\n            timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n            message_length = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(message_length_tmp));\n            message_type = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u8</span>::from_be_bytes(message_type_byte));\n\n            MessageHeader {\n                timestamp,\n                message_length,\n                message_type,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">2</span> {\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n\n            stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n            timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n\n            timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n            message_length = <span class="hljs-literal">None</span>;\n            message_type = <span class="hljs-literal">None</span>;\n\n            MessageHeader {\n                timestamp,\n                message_length,\n                message_type,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        } <span class="hljs-keyword">else</span> {\n            timestamp = <span class="hljs-literal">None</span>;\n            message_length = <span class="hljs-literal">None</span>;\n            message_type = <span class="hljs-literal">None</span>;\n\n            MessageHeader {\n                timestamp,\n                message_length,\n                message_type,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        };\n        <span class="hljs-comment">/* 拡張タイムスタンプの読み取り処理. (もしあれば) */</span>\n        <span class="hljs-keyword">let</span> extended_timestamp = <span class="hljs-keyword">match</span> timestamp {\n            <span class="hljs-literal">Some</span>(n) <span class="hljs-keyword">if</span> n == <span class="hljs-number">0x00ffffff</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span> =&gt; {\n                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> extended_timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n                stream.read(&amp;<span class="hljs-keyword">mut</span> extended_timestamp_bytes)?;\n                <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(extended_timestamp_bytes))\n            },\n            _ =&gt; <span class="hljs-literal">None</span>\n        };\n\n        <span class="hljs-comment">/* チャンクデータの読み取り処理. */</span>\n        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = message_length {\n            <span class="hljs-keyword">let</span> splits = <span class="hljs-keyword">if</span> message_length &lt;= DEFAULT_CHUNK_SIZE {\n                <span class="hljs-number">0</span>\n            } <span class="hljs-keyword">else</span> {\n                message_length / DEFAULT_CHUNK_SIZE + (message_length % DEFAULT_CHUNK_SIZE != <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>;\n            }\n\n            <span class="hljs-keyword">let</span> actual_message_length = (message_length + splits) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::with_capacity(actual_message_length);\n\n            <span class="hljs-keyword">unsafe</span> {\n                data_bytes.set_len(actual_message_length);\n            }\n\n            stream.read(data_bytes.as_mut_slice())?;\n\n            <span class="hljs-keyword">if</span> splits &gt; <span class="hljs-number">0</span> {\n                <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> split_data: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..splits {\n                    <span class="hljs-keyword">let</span> start = <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> {\n                        (DEFAULT_CHUNK_SIZE * i) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>\n                    } <span class="hljs-keyword">else</span> {\n                        (DEFAULT_CHUNK_SIZE * i + <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>\n                    };\n                    <span class="hljs-keyword">let</span> end = start + DEFAULT_CHUNK_SIZE <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n\n                    split_data.extend_from_slice(&amp;data_bytes[start..end]);\n                }\n\n                data_bytes = split_data;\n            }\n        }\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset = <span class="hljs-built_in">usize</span>::default();\n        <span class="hljs-keyword">let</span> command_name = decode_amf_data(&amp;data_bytes, &amp;<span class="hljs-keyword">mut</span> offset)?;\n        <span class="hljs-keyword">let</span> transaction_id = decode_amf_data(&amp;data_bytes, &amp;<span class="hljs-keyword">mut</span> offset)?;\n        <span class="hljs-keyword">let</span> command_object = decode_amf_data(&amp;data_bytes, &amp;<span class="hljs-keyword">mut</span> offset)?;\n        <span class="hljs-keyword">let</span> data = Data::Invoke(\n            InvokeCommand {\n                command_name,\n                transaction_id,\n                command_object\n            }\n        );\n        <span class="hljs-keyword">let</span> chunk = Chunk {\n            basic_header,\n            message_header,\n            extended_timestamp,\n            data\n        };\n\n        <span class="hljs-comment">/* Invoke の返送チャンクを送信する処理に移る. */</span>\n    }\n\n    <span class="hljs-literal">Ok</span>(())\n}\n</code></pre>\n<p>ここで, 後述のチャンク返送処理や他のチャンクの受信処理のために上記の実装をさらに関数化して全体を見やすくしておく.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    collections::{\n        HashMap\n    },\n    io::{\n        Error <span class="hljs-keyword">as</span> IOError,\n        ErrorKind,\n        Read,\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    }\n};\n\n<span class="hljs-keyword">const</span> DEFAULT_CHUNK_SIZE: <span class="hljs-built_in">u32</span> = <span class="hljs-number">128</span>;\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-keyword">impl</span> BasicHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header_format</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u8</span> {\n        <span class="hljs-keyword">self</span>.message_header_format\n    }\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MessageHeader</span></span> {\n    timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_length: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_type: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt;,\n    message_id: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;\n}\n\n<span class="hljs-keyword">impl</span> MessageHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_length</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_length\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_type</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_type\n    }\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    Unknown\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InvokeCommand</span></span> {\n    command_name: <span class="hljs-built_in">String</span>,\n    transaction_id: <span class="hljs-built_in">f64</span>,\n    command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    Invoke(InvokeCommand),\n    Unknown(<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;)\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span></span> {\n    basic_header: BasicHeader,\n    message_header: MessageHeader,\n    extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    data: Data\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_number</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> number_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">8</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">8</span>];\n\n    number_bytes.copy_from_slice(&amp;data[*offset..(*offset + <span class="hljs-number">8</span>)]);\n    *offset += <span class="hljs-number">8</span>;\n\n    <span class="hljs-keyword">let</span> number = <span class="hljs-built_in">f64</span>::from_bits(<span class="hljs-built_in">u64</span>::from_be_bytes(number_bytes));\n\n    <span class="hljs-literal">Ok</span>(AmfData::Number(number))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_boolean</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> boolean = data[*offset] &gt; <span class="hljs-number">0</span>;\n\n    *offset += <span class="hljs-number">1</span>;\n    <span class="hljs-literal">Ok</span>(AmfData::Boolean(boolean))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_string</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">2</span>];\n\n    length_bytes.copy_from_slice(&amp;data[*offset..(*offset + <span class="hljs-number">2</span>)]);\n    *offset += <span class="hljs-number">2</span>;\n\n    <span class="hljs-keyword">let</span> string = <span class="hljs-built_in">String</span>::from_utf8(data[*offset..(*offset + length)].to_vec()).map_err(\n        |_| IOError::from(ErrorKind::InvalidData)\n    )?;\n\n    *offset += length;\n    <span class="hljs-literal">Ok</span>(AmfData::<span class="hljs-built_in">String</span>(string))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_object</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n    <span class="hljs-keyword">while</span> &amp;data[*offset..(*offset + <span class="hljs-number">3</span>)] != &amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>] {\n        <span class="hljs-keyword">let</span> name = decode_amf_string(data, offset)?.string().unwrap();\n        <span class="hljs-keyword">let</span> value = decode_amf_data(data, offset)?;\n\n        object.insert(name, value);\n    }\n\n    <span class="hljs-literal">Ok</span>(AmfData::Object(object))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_unknown</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-comment">/* 当該部分の実装は後述する. */</span>\n    <span class="hljs-literal">Ok</span>(AmfData::Unknown)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_data</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">match</span> data[*offset] {\n        <span class="hljs-number">0</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_number(data, offset)\n        },\n        <span class="hljs-number">1</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_boolean(data, offset)\n        },\n        <span class="hljs-number">2</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_string(data, offset)\n        },\n        <span class="hljs-number">3</span> =&gt; {\n            offset += <span class="hljs-number">1</span>;\n            decode_amf_object(data, offset)\n        },\n        _ =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_unknown()\n        }\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_basic_header</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream) -&gt; IOResult&lt;BasicHeader&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> first_byte: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n    stream.read(&amp;<span class="hljs-keyword">mut</span> first_byte)?;\n\n    <span class="hljs-keyword">let</span> message_header_format = (first_byte[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0xc0</span>) &gt;&gt; <span class="hljs-number">6</span>;\n    <span class="hljs-keyword">let</span> chunk_id = <span class="hljs-keyword">match</span> first_byte[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x3f</span> {\n        <span class="hljs-number">0</span> =&gt; {\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> chunk_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n            stream.read(&amp;<span class="hljs-keyword">mut</span> chunk_id_bytes)?;\n            (<span class="hljs-built_in">u8</span>::from_be_bytes(chunk_id_bytes) + <span class="hljs-number">64</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>\n        },\n        <span class="hljs-number">1</span> =&gt; {\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> chunk_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">2</span>];\n\n            stream.read(&amp;<span class="hljs-keyword">mut</span> chunk_id_bytes)?;\n            <span class="hljs-built_in">u16</span>::from_le_bytes(chunk_id_bytes) + <span class="hljs-number">64</span>\n        },\n        n =&gt; n\n    };\n\n    <span class="hljs-literal">Ok</span>(\n        BasicHeader {\n            message_header_format,\n            chunk_id\n        }\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_message_header</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, message_header_format: <span class="hljs-built_in">u8</span>) -&gt; IOResult&lt;MessageHeader&gt; {\n    <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">0</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_type_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_length_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_type_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_id_bytes)?;\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n        message_length_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;message_length_bytes);\n\n        <span class="hljs-keyword">let</span> timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n        <span class="hljs-keyword">let</span> message_length = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(message_length_tmp));\n        <span class="hljs-keyword">let</span> message_type = <span class="hljs-literal">Some</span>(message_type_bytes[<span class="hljs-number">0</span>]);\n        <span class="hljs-keyword">let</span> message_id = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_le_bytes(message_id_bytes));\n\n        <span class="hljs-literal">Ok</span>(\n            MessageHeader {\n                timestamp,\n                message_length,\n                message_type,\n                message_id\n            }\n        )\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">1</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_type_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_length_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_type_bytes)?;\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n        message_length_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;message_length_bytes);\n\n        <span class="hljs-keyword">let</span> timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n        <span class="hljs-keyword">let</span> message_length = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(message_length_tmp));\n        <span class="hljs-keyword">let</span> message_type = <span class="hljs-literal">Some</span>(message_type_bytes[<span class="hljs-number">0</span>]);\n\n        <span class="hljs-literal">Ok</span>(\n            MessageHeader {\n                timestamp,\n                message_length,\n                message_type,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        )\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">2</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n\n        <span class="hljs-keyword">let</span> timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n\n        <span class="hljs-literal">Ok</span>(\n            MessageHeader {\n                timestamp,\n                message_length: <span class="hljs-literal">None</span>,\n                message_type: <span class="hljs-literal">None</span>,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        )\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-literal">Ok</span>(\n            MessageHeader {\n                timestamp: <span class="hljs-literal">None</span>,\n                message_length: <span class="hljs-literal">None</span>,\n                message_type: <span class="hljs-literal">None</span>,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        )\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_extended_timestamp</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, timestamp: <span class="hljs-built_in">u32</span>) -&gt; IOResult&lt;<span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;&gt; {\n    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0x00ffffff</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> extended_timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> extended_timestamp_bytes)?;\n        <span class="hljs-literal">Ok</span>(<span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(extended_timestamp_bytes)))\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-literal">Ok</span>(<span class="hljs-literal">None</span>)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_invoke</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset = <span class="hljs-built_in">usize</span>::default();\n    <span class="hljs-keyword">let</span> command_name = decode_amf_data(data, &amp;<span class="hljs-keyword">mut</span> offset)?;\n    <span class="hljs-keyword">let</span> transaction_id = decode_amf_data(data, &amp;<span class="hljs-keyword">mut</span> offset)?;\n    <span class="hljs-keyword">let</span> command_object = decode_amf_data(data, &amp;<span class="hljs-keyword">mut</span> offset)?;\n\n    <span class="hljs-literal">Ok</span>(\n        Data::Invoke(\n            InvokeCommand {\n                command_name,\n                transaction_id,\n                command_object\n            }\n        )\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_data</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, message_type: <span class="hljs-built_in">u8</span>, message_length: <span class="hljs-built_in">u32</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> splits = <span class="hljs-keyword">if</span> message_length &lt;= DEFAULT_CHUNK_SIZE {\n        <span class="hljs-number">0</span>\n    } <span class="hljs-keyword">else</span> {\n        message_length / DEFAULT_CHUNK_SIZE + (message_length % DEFAULT_CHUNK_SIZE &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>\n    };\n    <span class="hljs-keyword">let</span> actual_message_length = (message_length + splits) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::with_capacity(actual_message_length);\n\n    <span class="hljs-keyword">unsafe</span> {\n        data_bytes.set_len(actual_message_length);\n    }\n\n    stream.read(data_bytes.as_mut_slice())?;\n\n    <span class="hljs-keyword">if</span> splits &gt; <span class="hljs-number">0</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> split_data: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..splits {\n            <span class="hljs-keyword">let</span> start = <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> {\n                (DEFAULT_CHUNK_SIZE * i) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>\n            } <span class="hljs-keyword">else</span> {\n                (DEFAULT_CHUNK_SIZE * i + <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n            };\n            <span class="hljs-keyword">let</span> end = start + DEFAULT_CHUNK_SIZE <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n\n            split_data.extend_from_slice(&amp;data_bytes[start..end]);\n        }\n\n        data_bytes = split_data;\n    }\n\n    <span class="hljs-keyword">match</span> message_type {\n        <span class="hljs-number">20</span> =&gt; decode_invoke(data_bytes),\n        _ =&gt; <span class="hljs-literal">Ok</span>(Data::Unknown(data_bytes))\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_chunk</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream) -&gt; IOResult&lt;Chunk&gt; {\n    <span class="hljs-keyword">let</span> basic_header = receive_basic_header(stream)?;\n    <span class="hljs-keyword">let</span> message_header = receive_message_header(stream, basic_header.get_message_header_format())?;\n    <span class="hljs-comment">// 今のところ, 必ず Some が返されると仮定する.</span>\n    <span class="hljs-keyword">let</span> extended_timestamp = receive_extended_timestamp(stream, message_header.get_timestamp().unwrap())?;\n    <span class="hljs-keyword">let</span> data = receive_data(stream, message_header.get_message_type().unwrap(), message_header.get_message_length().unwrap())?;\n\n    <span class="hljs-literal">Ok</span>(\n        Chunk {\n            basic_header,\n            message_header,\n            extended_timestamp,\n            data\n        }\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n\n        <span class="hljs-comment">/* ハンドシェイクは完了しているとみなす. */</span>\n        <span class="hljs-keyword">let</span> received_chunk = receive_chunk(&amp;<span class="hljs-keyword">mut</span> stream)?;\n\n        <span class="hljs-comment">/* Invoke の返送チャンクを送信する処理に移る. */</span>\n    }\n\n    <span class="hljs-literal">Ok</span>(())\n}\n</code></pre>\n<p>サーバ側はクライアント側からのチャンクの受信が完了したなら, クライアント側に受信結果を伝えるための返送チャンクを送信する.</p>\n<h4 id="connect-%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E8%A6%81%E6%B1%82%E3%81%B8%E3%81%AE%E8%BF%94%E9%80%81%E6%89%8B%E9%A0%86"><a class="header-anchor" href="#connect-%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E8%A6%81%E6%B1%82%E3%81%B8%E3%81%AE%E8%BF%94%E9%80%81%E6%89%8B%E9%A0%86">¶</a> connect コマンド要求への返送手順</h4>\n<p>ここで, 当該返送処理に必要な通信の手順を以下に改めて記す.</p>\n<div id="rtmp-invoke-connect-sequences">\n<a href="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuRArLNZStF-uUVFZvix7JTiVDor_tBJaSTFwnuqzJzVrFDdLzhXn-kF6-NeAjhPS8E7cbM3vHM0T7GgwTWgFcxO-Rjxpk7c2bO9dNbb-Tgf6SdvUNcfoYIONN0gY3bqtN4DyKMfnQGun6i8pyrBoonKSaxFpyijpKbFIKtDJyqeKWZEhKXNq5O9JYyfIYnIS4lDImZDJIZ88cnUSMg8Ga8gi1sYCSquco50IZ0aj1XhXd9zNKfIVen5SKfIQcAlWb9gUcKU4bvmpIlEomJuWFRmSKlDIWB480000" target="_self"><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuRArLNZStF-uUVFZvix7JTiVDor_tBJaSTFwnuqzJzVrFDdLzhXn-kF6-NeAjhPS8E7cbM3vHM0T7GgwTWgFcxO-Rjxpk7c2bO9dNbb-Tgf6SdvUNcfoYIONN0gY3bqtN4DyKMfnQGun6i8pyrBoonKSaxFpyijpKbFIKtDJyqeKWZEhKXNq5O9JYyfIYnIS4lDImZDJIZ88cnUSMg8Ga8gi1sYCSquco50IZ0aj1XhXd9zNKfIVen5SKfIQcAlWb9gUcKU4bvmpIlEomJuWFRmSKlDIWB480000" alt=""></a></div>\n<p id="caption-rtmp-invoke-connect-sequences">図1. Invoke(connect) チャンクの送受信手順</p>\n<p>次に, 各返送チャンクに必要な値を以下に記す.</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">メッセージの種類</th>\n<th style="text-align:right">チャンクストリーム ID</th>\n<th style="text-align:right">タイムスタンプ</th>\n<th style="text-align:right">メッセージ長</th>\n<th style="text-align:right">メッセージ種類 ID</th>\n<th style="text-align:right">メッセージストリーム ID</th>\n<th style="text-align:left">チャンクデータ</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left">Window Acknowledgement Size / Server Bandwidth</td>\n<td style="text-align:right">2</td>\n<td style="text-align:right">0</td>\n<td style="text-align:right">4</td>\n<td style="text-align:right">5</td>\n<td style="text-align:right">0</td>\n<td style="text-align:left">サーバ側の帯域幅</td>\n</tr>\n<tr>\n<td style="text-align:left">Set Peer Bandwidth / Client Bandwidth</td>\n<td style="text-align:right">2</td>\n<td style="text-align:right">0</td>\n<td style="text-align:right">5</td>\n<td style="text-align:right">6</td>\n<td style="text-align:right">0</td>\n<td style="text-align:left">クライアント側の帯域幅 + 帯域幅の調整方法 (Dynamic)</td>\n</tr>\n<tr>\n<td style="text-align:left">User Control / Ping</td>\n<td style="text-align:right">2</td>\n<td style="text-align:right">0</td>\n<td style="text-align:right">6</td>\n<td style="text-align:right">4</td>\n<td style="text-align:right">0</td>\n<td style="text-align:left">イベント ID (0) + メッセージストリーム ID (この時はまだ 0)</td>\n</tr>\n<tr>\n<td style="text-align:left">Chunk Size</td>\n<td style="text-align:right">2</td>\n<td style="text-align:right">0</td>\n<td style="text-align:right">4</td>\n<td style="text-align:right">1</td>\n<td style="text-align:right">0</td>\n<td style="text-align:left">通信一度あたりのチャンクのデータ量</td>\n</tr>\n<tr>\n<td style="text-align:left">Invoke(_result)</td>\n<td style="text-align:right">3</td>\n<td style="text-align:right">0</td>\n<td style="text-align:right">?</td>\n<td style="text-align:right">20</td>\n<td style="text-align:right">0</td>\n<td style="text-align:left">Invoke リクエストの返送メッセージ</td>\n</tr>\n</tbody>\n</table>\n<h5 id="%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E9%95%B7%E3%81%AE%E6%B1%82%E3%82%81%E6%96%B9"><a class="header-anchor" href="#%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E9%95%B7%E3%81%AE%E6%B1%82%E3%82%81%E6%96%B9">¶</a> メッセージ長の求め方</h5>\n<p>Invoke(_result) チャンクのメッセージ長はサーバ側がどのような値を入力していくかによって変動するため, 不定である. その実際の長さは, バイト列に変換した後のチャンクデータの大きさとして求める.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    collections::{\n        HashMap\n    },\n    io::{\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    }\n};\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    Unknown\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InvokeCommand</span></span> {\n    Request {\n        command_name: <span class="hljs-built_in">String</span>,\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    },\n    Response {\n        command_name: <span class="hljs-built_in">String</span>,\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;,\n        information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    }\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    ChunkSize(<span class="hljs-built_in">u32</span>),\n    Ping(<span class="hljs-built_in">u16</span>, PingData),\n    ServerBandwidth(<span class="hljs-built_in">u32</span>),\n    ClientBandwidth(<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u8</span>),\n    Invoke(InvokeCommand),\n    Unknown(<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n        <span class="hljs-comment">/* Invoke(connect) チャンクの受信までは完了しているとみなす. */</span>\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n        properties.insert(<span class="hljs-string">"fmsVer"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"FMS/3,0,1,123"</span>.to_string()));\n        properties.insert(<span class="hljs-string">"capabilities"</span>.to_string(), AmfData::Number(<span class="hljs-number">31</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n        information.insert(<span class="hljs-string">"level"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"status"</span>.to_string()));\n        information.insert(<span class="hljs-string">"code"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"NetConnection.Connect.Success"</span>.to_string()));\n        information.insert(<span class="hljs-string">"description"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"Connection succeeded."</span>.to_string()));\n        information.insert(<span class="hljs-string">"objectEncoding"</span>.to_string(), AmfData::Number(<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n\n        <span class="hljs-keyword">let</span> data = Data::Invoke(\n            InvokeCommand::Response {\n                command_name: <span class="hljs-string">"_result"</span>.to_string(),\n                transaction_id: <span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>,\n                properties,\n                information\n            }\n        );\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n        <span class="hljs-comment">// この名前とシグネチャでチャンクデータをバイト列に変換する関数があると仮定する.</span>\n        encode_data(&amp;<span class="hljs-keyword">mut</span> data_bytes, data);\n\n        <span class="hljs-keyword">let</span> message_length = data_bytes.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>;\n    }\n\n    <span class="hljs-literal">Ok</span>(())\n}\n</code></pre>\n<p>そして, <code>encode_data</code> を以下のように実装する.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    collections::{\n        HashMap\n    }\n};\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PingData</span></span> {\n    StreamBegin(<span class="hljs-built_in">u32</span>)\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    Unknown\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InvokeCommand</span></span> {\n    Request {\n        command_name: <span class="hljs-built_in">String</span>,\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    },\n    Response {\n        command_name: <span class="hljs-built_in">String</span>,\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;,\n        information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    }\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    ChunkSize(<span class="hljs-built_in">u32</span>),\n    Ping(<span class="hljs-built_in">u16</span>, PingData),\n    ServerBandwidth(<span class="hljs-built_in">u32</span>),\n    ClientBandwidth(<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u8</span>),\n    Invoke(InvokeCommand),\n    Unknown(<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_data</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, data: Data) -&gt; <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; {\n    <span class="hljs-keyword">match</span> data {\n        Data::ChunkSize(chunk_size) =&gt; v.extend_from_slice(&amp;chunk_size.to_be_bytes()),\n        Data::Ping(ping_type, ping_data) =&gt; {\n            v.extend_from_slice(&amp;ping_type.to_be_bytes());\n\n            <span class="hljs-keyword">match</span> ping_data {\n                PingData::StreamBegin(message_id) =&gt; v.extend_from_slice(&amp;message_id.to_be_bytes())\n            }\n        },\n        Data::ServerBandwidth(server_bandwidth) =&gt; v.extend_from_slice(&amp;server_bandwidth.to_be_bytes()),\n        Data::ClientBandwidth(client_bandwidth, limit) =&gt; {\n            v.extend_from_slice(&amp;client_bandwidth.to_be_bytes());\n            v.push(limit);\n        },\n        Data::Invoke(invoke_command) =&gt; {\n            <span class="hljs-keyword">match</span> invoke_command {\n                InvokeCommand::Response {\n                    <span class="hljs-keyword">mut</span> command_name,\n                    transaction_id,\n                    properties,\n                    information\n                } =&gt; {\n                    v.push(<span class="hljs-number">2</span>);\n                    v.extend_from_slice(&amp;(command_name.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n                    v.append(command_name.as_mut_vec());\n                    v.push(<span class="hljs-number">0</span>);\n                    v.extend_from_slice(&amp;transaction_id.to_bits().to_be_bytes());\n                    v.push(<span class="hljs-number">3</span>);\n\n                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">mut</span> name, value) <span class="hljs-keyword">in</span> properties {\n                        v.extend_from_slice(&amp;(name.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n                        v.append(name.as_mut_vec());\n\n                        <span class="hljs-keyword">match</span> value {\n                            AmfData::Number(number) =&gt; {\n                                v.push(<span class="hljs-number">0</span>);\n                                v.extend_from_slice(&amp;number.to_bits().to_be_bytes());\n                                },\n                            AmfData::Boolean(boolean) =&gt; {\n                                v.push(<span class="hljs-number">1</span>);\n                                v.push(boolean <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);\n                            },\n                            AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-keyword">mut</span> string) =&gt; {\n                                v.push(<span class="hljs-number">2</span>);\n                                v.extend_from_slice(&amp;(string.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n                                v.append(string.as_mut_vec());\n                            },\n                            AmfData::Object(object) =&gt; {\n                                <span class="hljs-comment">// この部分も込みで後で関数化して再帰させる.</span>\n                            }\n                        }\n                    }\n\n                    v.extend_from_slice(&amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>]);\n                    v.push(<span class="hljs-number">3</span>);\n\n                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">mut</span> name, value) <span class="hljs-keyword">in</span> information {\n                        v.extend_from_slice(&amp;(name.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n                        v.append(name.as_mut_vec());\n\n                        <span class="hljs-keyword">match</span> value {\n                            AmfData::Number(number) =&gt; {\n                                v.push(<span class="hljs-number">0</span>);\n                                v.extend_from_slice(&amp;number.to_bits().to_be_bytes());\n                            },\n                            AmfData::Boolean(boolean) =&gt; {\n                                v.push(<span class="hljs-number">1</span>);\n                                v.push(boolean <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);\n                            },\n                            AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-keyword">mut</span> string) =&gt; {\n                                v.push(<span class="hljs-number">2</span>);\n                                v.extend_from_slice(&amp;(string.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n                                v.append(string.as_mut_vec());\n                            },\n                            AmfData::Object(object) =&gt; {\n                                <span class="hljs-comment">// 同上.</span>\n                            },\n                            AmfData::Unknown =&gt; {\n                                <span class="hljs-comment">// 未定義の AMF データ型については, 現段階では何もしないこととする.</span>\n                            }\n                        }\n                    }\n\n                    v.extend_from_slice(&amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>]);\n                },\n                <span class="hljs-comment">// 現時点では InvokeCommand::Request のエンコードについて考えないものとする.</span>\n                _ =&gt; {}\n            }\n        }\n    }\n}\n</code></pre>\n<p>上記の実装も変換過程に重複が見られるため, 以下のように関数化して処理の分岐を容易にしていく.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    collections::{\n        HashMap\n    }\n};\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PingData</span></span> {\n    StreamBegin(<span class="hljs-built_in">u32</span>)\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    Unknown\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InvokeCommand</span></span> {\n    Request {\n        command_name: <span class="hljs-built_in">String</span>,\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    },\n    Response {\n        command_name: <span class="hljs-built_in">String</span>,\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;,\n        information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    }\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    ChunkSize(<span class="hljs-built_in">u32</span>),\n    Ping(<span class="hljs-built_in">u16</span>, PingData),\n    ServerBandwidth(<span class="hljs-built_in">u32</span>),\n    ClientBandwidth(<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u8</span>),\n    Invoke(InvokeCommand),\n    Unknown(<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_chunk_size</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, chunk_size: <span class="hljs-built_in">u32</span>) {\n    v.extend_from_slice(&amp;chunk_size.to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_ping</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, ping_type: <span class="hljs-built_in">u16</span>, ping_data: PingData) {\n    v.extend_from_slice(&amp;ping_type.to_be_bytes());\n\n    <span class="hljs-keyword">match</span> ping_data {\n        PingData::StreamBegin(message_id) =&gt; v.extend_from_slice(&amp;message_id.to_be_bytes())\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_server_bandwidth</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, server_bandwidth: <span class="hljs-built_in">u32</span>) {\n    v.extend_from_slice(&amp;server_bandwidth.to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_client_bandwidth</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, client_bandwidth: <span class="hljs-built_in">u32</span>, limit: <span class="hljs-built_in">u8</span>) {\n    v.extend_from_slice(&amp;client_bandwidth.to_be_bytes());\n    v.push(limit);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_number</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, number: <span class="hljs-built_in">f64</span>) {\n    v.push(<span class="hljs-number">0</span>);\n    v.extend_from_slice(&amp;number.to_bits().to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_boolean</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, boolean: <span class="hljs-built_in">bool</span>) {\n    v.push(<span class="hljs-number">1</span>);\n    v.push(boolean <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_string</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, <span class="hljs-keyword">mut</span> string: <span class="hljs-built_in">String</span>) {\n    v.push(<span class="hljs-number">2</span>);\n    v.extend_from_slice(&amp;(string.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n    v.append(string.as_mut_vec());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_object</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;) {\n    v.push(<span class="hljs-number">3</span>);\n\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">mut</span> name, value) <span class="hljs-keyword">in</span> object {\n        v.extend_from_slice(&amp;(name.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n        v.append(name.as_mut_vec());\n        encode_amf_data(v, value);\n    }\n\n    v.extend_from_slice(&amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>]);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_data</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, data: AmfData) {\n    <span class="hljs-keyword">match</span> data {\n        AmfData::Number(number) =&gt; encode_amf_number(v, number),\n        AmfData::Boolean(boolean) =&gt; encode_amf_boolean(v, boolean),\n        AmfData::<span class="hljs-built_in">String</span>(string) =&gt; encode_amf_string(v, string),\n        AmfData::Object(object) =&gt; encode_amf_object(v, object),\n        <span class="hljs-comment">// まだ上記以外の AMF 型のデータを特定できていないため, 現段階では無視することとする.</span>\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_invoke</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, invoke_command: InvokeCommand) {\n    <span class="hljs-keyword">match</span> invoke_command {\n        InvokeCommand::Response {\n            command_name,\n            transaction_id,\n            properties,\n            information\n        } =&gt; {\n            encode_amf_string(v, command_name);\n            encode_amf_number(v, transaction_id);\n            encode_amf_object(v, properties);\n            encode_amf_object(v, information);\n        },\n        <span class="hljs-comment">// 現時点では InvokeCommand::Request のエンコードについて考えないものとする.</span>\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_data</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, data: Data) {\n    <span class="hljs-keyword">match</span> data {\n        Data::ChunkSize(chunk_size) =&gt; encode_chunk_size(v, chunk_size),\n        Data::Ping(ping_type, ping_data) =&gt; encode_ping(v, ping_type, ping_data),\n        Data::ServerBandwidth(server_bandwidth) =&gt; encode_server_bandwidth(v, server_bandwidth),\n        Data::ClientBandwidth(client_bandwidth, limit) =&gt; encode_client_bandwidth(v, client_bandwidth, limit),\n        Data::Invoke(invoke_command) =&gt; encode_invoke(v, invoke_command)\n    }\n}\n</code></pre>\n<p>これで各種チャンクデータを変換し, その長さを求める準備が整った.</p>\n<h5 id="%E3%83%90%E3%82%A4%E3%83%88%E5%88%97%E3%81%B8%E3%81%AE%E5%A4%89%E6%8F%9B"><a class="header-anchor" href="#%E3%83%90%E3%82%A4%E3%83%88%E5%88%97%E3%81%B8%E3%81%AE%E5%A4%89%E6%8F%9B">¶</a> バイト列への変換</h5>\n<p>次は各種ヘッダの変換処理も同様に関数化して他の返送チャンクの変換処理にも備える.</p>\n<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-keyword">impl</span> BasicHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header_format</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u8</span> {\n        <span class="hljs-keyword">self</span>.message_header_format\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_chunk_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u16</span> {\n        <span class="hljs-keyword">self</span>.chunk_id\n    }\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MessageHeader</span></span> {\n    timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_length: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_type: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt;,\n    message_id: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;\n}\n\n<span class="hljs-keyword">impl</span> MessageHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_length</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_length\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_type</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_type\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.mmessage_id\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_basic_header</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, basic_header: BasicHeader) {\n    <span class="hljs-keyword">let</span> message_header_format = basic_header.get_message_header_format();\n    <span class="hljs-keyword">let</span> chunk_id = basic_header.get_chunk_id();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> second_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> first_byte = <span class="hljs-keyword">if</span> chunk_id &gt; <span class="hljs-number">319</span> {\n        second_bytes.extend_from_slice(&amp;chunk_id.to_le_bytes());\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | <span class="hljs-number">1</span>\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> chunk_id &gt; <span class="hljs-number">63</span> {\n        second_bytes.push(chunk_id <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | <span class="hljs-number">0</span>\n    } <span class="hljs-keyword">else</span> {\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | chunk_id\n    };\n\n    v.push(first_byte);\n    v.append(&amp;<span class="hljs-keyword">mut</span> second_bytes);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_message_header</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, message_header: MessageHeader) {\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(timestamp) = message_header.get_timestamp() {\n        v.extend_from_slice(&amp;timestamp.to_be_bytes()[<span class="hljs-number">1</span>..]);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = message_header.get_message_length() {\n        v.extend_from_slice(&amp;message_length.to_be_bytes()[<span class="hljs-number">1</span>..]);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_type) = message_header.get_message_type() {\n        v.push(message_type);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> some(message_id) = message_header.get_message_id() {\n        v.extend_from_slice(&amp;message_id.to_le_bytes());\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_extended_timestamp</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;) {\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(extended_timestamp) = extended_timestamp {\n        v.extend_from_slice(&amp;extended_timestamp.to_be_bytes());\n    }\n}\n</code></pre>\n<p>ここで, 返送チャンクの変換処理を一つにまとめて, <code>main</code> 関数内の処理とも合流させる.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    collections::{\n        HashMap\n    },\n    io::{\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    }\n};\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-keyword">impl</span> BasicHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header_format</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u8</span> {\n        <span class="hljs-keyword">self</span>.message_header_format\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_chunk_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u16</span> {\n        <span class="hljs-keyword">self</span>.chunk_id\n    }\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MessageHeader</span></span> {\n    timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_length: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_type: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt;,\n    message_id: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;\n}\n\n<span class="hljs-keyword">impl</span> MessageHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_length</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_length\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_type</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_type\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.mmessage_id\n    }\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PingData</span></span> {\n    StreamBegin(<span class="hljs-built_in">u32</span>)\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    Unknown\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InvokeCommand</span></span> {\n    Request {\n        command_name: <span class="hljs-built_in">String</span>,\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    },\n    Response {\n        command_name: <span class="hljs-built_in">String</span>,\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;,\n        information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    }\n}\n\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    ChunkSize(<span class="hljs-built_in">u32</span>),\n    Ping(<span class="hljs-built_in">u16</span>, PingData),\n    ServerBandwidth(<span class="hljs-built_in">u32</span>),\n    ClientBandwidth(<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u8</span>),\n    Invoke(InvokeCommand),\n    Unknown(<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_message_header</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, message_header: MessageHeader) {\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(timestamp) = message_header.get_timestamp() {\n        v.extend_from_slice(&amp;timestamp.to_be_bytes()[<span class="hljs-number">1</span>..]);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = message_header.get_message_length() {\n        v.extend_from_slice(&amp;message_length.to_be_bytes()[<span class="hljs-number">1</span>..]);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_type) = message_header.get_message_type() {\n        v.push(message_type);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> some(message_id) = message_header.get_message_id() {\n        v.extend_from_slice(&amp;message_id.to_le_bytes());\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_extended_timestamp</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;) {\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(extended_timestamp) = extended_timestamp {\n        v.extend_from_slice(&amp;extended_timestamp.to_be_bytes());\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_chunk_size</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, chunk_size: <span class="hljs-built_in">u32</span>) {\n    v.extend_from_slice(&amp;chunk_size.to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_ping</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, ping_type: <span class="hljs-built_in">u16</span>, ping_data: PingData) {\n    v.extend_from_slice(&amp;ping_type.to_be_bytes());\n\n    <span class="hljs-keyword">match</span> ping_data {\n        PingData::StreamBegin(message_id) =&gt; v.extend_from_slice(&amp;message_id.to_be_bytes())\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_server_bandwidth</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, server_bandwidth: <span class="hljs-built_in">u32</span>) {\n    v.extend_from_slice(&amp;server_bandwidth.to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_client_bandwidth</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, client_bandwidth: <span class="hljs-built_in">u32</span>, limit: <span class="hljs-built_in">u8</span>) {\n    v.extend_from_slice(&amp;client_bandwidth.to_be_bytes());\n    v.push(limit);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_number</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, number: <span class="hljs-built_in">f64</span>) {\n    v.push(<span class="hljs-number">0</span>);\n    v.extend_from_slice(&amp;number.to_bits().to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_boolean</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, boolean: <span class="hljs-built_in">bool</span>) {\n    v.push(<span class="hljs-number">1</span>);\n    v.push(boolean <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_string</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, <span class="hljs-keyword">mut</span> string: <span class="hljs-built_in">String</span>) {\n    v.push(<span class="hljs-number">2</span>);\n    v.extend_from_slice(&amp;(string.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n    v.append(string.as_mut_vec());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_object</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;) {\n    v.push(<span class="hljs-number">3</span>);\n\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">mut</span> name, value) <span class="hljs-keyword">in</span> object {\n        v.extend_from_slice(&amp;(name.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n        v.append(name.as_mut_vec());\n        encode_amf_data(v, value);\n    }\n\n    v.extend_from_slice(&amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>]);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_data</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, data: AmfData) {\n    <span class="hljs-keyword">match</span> data {\n        AmfData::Number(number) =&gt; encode_amf_number(v, number),\n        AmfData::Boolean(boolean) =&gt; encode_amf_boolean(v, boolean),\n        AmfData::<span class="hljs-built_in">String</span>(string) =&gt; encode_amf_string(v, string),\n        AmfData::Object(object) =&gt; encode_amf_object(v, object),\n        <span class="hljs-comment">// まだ上記以外の AMF 型のデータを特定できていないため, 現段階では無視することとする.</span>\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_invoke</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, invoke_command: InvokeCommand) {\n    <span class="hljs-keyword">match</span> invoke_command {\n        InvokeCommand::Response {\n            command_name,\n            transaction_id,\n            properties,\n            information\n        } =&gt; {\n            encode_amf_string(v, command_name);\n            encode_amf_number(v, transaction_id);\n            encode_amf_object(v, properties);\n            encode_amf_object(v, information);\n        },\n        <span class="hljs-comment">// 現時点では InvokeCommand::Request のエンコードについて考えないものとする.</span>\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_data</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, data: Data) {\n    <span class="hljs-keyword">match</span> data {\n        Data::ChunkSize(chunk_size) =&gt; encode_chunk_size(v, chunk_size),\n        Data::Ping(ping_type, ping_data) =&gt; encode_ping(v, ping_type, ping_data),\n        Data::ServerBandwidth(server_bandwidth) =&gt; encode_server_bandwidth(v, server_bandwidth),\n        Data::ClientBandwidth(client_bandwidth, limit) =&gt; encode_client_bandwidth(v, client_bandwidth, limit),\n        Data::Invoke(invoke_command) =&gt; encode_invoke(v, invoke_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n        <span class="hljs-comment">/* ハンドシェイクは完了しているとみなす. */</span>\n        <span class="hljs-keyword">let</span> received_chunk = receive_chunk(&amp;<span class="hljs-keyword">mut</span> stream)?;\n        <span class="hljs-comment">/* 返送チャンクの送信処理. */</span>\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n        properties.insert(<span class="hljs-string">"fmsVer"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"FMS/3,0,1,123"</span>.to_string()));\n        properties.insert(<span class="hljs-string">"capabilities"</span>.to_string(), AmfData::Number(<span class="hljs-number">31</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n        information.insert(<span class="hljs-string">"level"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"status"</span>.to_string()));\n        information.insert(<span class="hljs-string">"code"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"NetConnection.Connect.Success"</span>.to_string()));\n        information.insert(<span class="hljs-string">"description"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"Connection succeeded."</span>.to_string()));\n        information.insert(<span class="hljs-string">"objectEncoding"</span>.to_string(), AmfData::Number(<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n\n        <span class="hljs-keyword">let</span> data = Data::Invoke(\n            InvokeCommand::Response {\n                command_name: <span class="hljs-string">"_result"</span>.to_string(),\n                transaction_id: <span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>,\n                properties,\n                information\n            }\n        );\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n        encode_data(&amp;<span class="hljs-keyword">mut</span> data_bytes, data);\n\n        <span class="hljs-keyword">let</span> message_length = data_bytes.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>;\n        <span class="hljs-keyword">let</span> chunk_id: <span class="hljs-built_in">u16</span> = <span class="hljs-number">3</span>;\n        <span class="hljs-keyword">let</span> basic_header = BasicHeader {\n            message_header_format: <span class="hljs-number">0</span>,\n            chunk_id\n        };\n        <span class="hljs-keyword">let</span> message_header = MessageHeader {\n            timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n            message_length,\n            message_type: <span class="hljs-number">20</span>,\n            message_id: <span class="hljs-number">0</span>\n        };\n        <span class="hljs-keyword">let</span> extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; = <span class="hljs-literal">None</span>;\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> invoke_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n        encode_basic_header(&amp;<span class="hljs-keyword">mut</span> invoke_bytes, basic_header);\n        encode_message_header(&amp;<span class="hljs-keyword">mut</span> invoke_bytes, message_header);\n        encode_extended_timestamp(&amp;<span class="hljs-keyword">mut</span> invoke_bytes, extended_timestamp);\n\n        <span class="hljs-comment">/* チャンクデータを append する処理に移る. */</span>\n    }\n\n    <span class="hljs-literal">Ok</span>(())\n}\n</code></pre>\n<p>これでチャンクデータまでのバイト列への変換は成功である. 次に, チャンクデータをバイト列に変換する例を以下に記す. ここで, その際の留意事項を改めて以下に記す.</p>\n<p>チャンクメッセージヘッダ中のメッセージ長の値が:</p>\n<ul>\n<li>所定のチャンクサイズ以下の場合は, メッセージ長と丁度同じサイズのチャンクデータを送信する.</li>\n<li>そうでない場合は, チャンクデータを所定のチャンクサイズ単位で区切り, それらの区切ったチャンクの間にはチャンク基本ヘッダと形式 3 のチャンクメッセージヘッダを挿入する. (つまりチャンク基本ヘッダのみを挿入する)</li>\n</ul>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    cmp::{\n        min\n    },\n    io::{\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    }\n};\n\n<span class="hljs-keyword">const</span> DEFAULT_CHUNK_SIZE: <span class="hljs-built_in">u32</span> = <span class="hljs-number">128</span>;\n\n<span class="hljs-comment">// 変換処理中でバイト列に必要な分だけ同じデータを挿入するため, コピー可能にしておく.</span>\n<span class="hljs-comment">// ちなみに, メンバのどこにもポインタ型を含んでいない構造体や列挙体には Copy トレイトを付与することができる.</span>\n<span class="hljs-comment">// これにより, 構造体をそのままコピーする(Rust の場合はスタック上に再生成する)ことが可能となる.</span>\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-keyword">impl</span> BasicHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header_format</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u8</span> {\n        <span class="hljs-keyword">self</span>.message_header_format\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_chunk_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u16</span> {\n        <span class="hljs-keyword">self</span>.chunk_id\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> stream = incoming?;\n        <span class="hljs-comment">/* チャンクデータまでのバイト列への変換処理は完了しているとみなす. */</span>\n        <span class="hljs-keyword">let</span> splits = <span class="hljs-keyword">if</span> message_length &lt;= DEFAULT_CHUNK_SIZE {\n            <span class="hljs-number">0</span>\n        } <span class="hljs-keyword">else</span> {\n            message_length / DEFAULT_CHUNK_SIZE + (message_length % DEFAULT_CHUNK_SIZE != <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>\n        };\n\n        <span class="hljs-keyword">if</span> splits &gt; <span class="hljs-number">0</span> {\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> added: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n            <span class="hljs-keyword">let</span> basic_header = BasicHeader {\n                message_header_format: <span class="hljs-number">3</span>,\n                chunk_id\n            };\n\n            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..splits {\n                <span class="hljs-comment">// バイト列の先頭にうっかりヘッダを挿入しないようにする.</span>\n                <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> {\n                    encode_basic_header(&amp;<span class="hljs-keyword">mut</span> added, basic_header);\n                }\n\n                <span class="hljs-keyword">let</span> start = (DEFAULT_CHUNK_SIZE * i) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n                <span class="hljs-comment">// 所定のチャンクサイズ（現在はデフォルト値をそのまま使用）と残りのチャンクデータのサイズの内, どちらか少ない方を採用する.</span>\n                <span class="hljs-comment">// こうすることで, 端数分のチャンクデータも過不足なく送信できる.</span>\n                <span class="hljs-keyword">let</span> end = start + min(DEFAULT_CHUNK_SIZE <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>, data_bytes[start..].len());\n\n                added.extend_from_slice(&amp;data_bytes[start..end]);\n            }\n\n            data_bytes = added;\n        }\n\n        invoke_bytes.append(&amp;<span class="hljs-keyword">mut</span> data_bytes);\n    }\n\n    <span class="hljs-literal">Ok</span>(())\n}\n</code></pre>\n<p>これで Invoke(_result) のチャンクをバイト列に変換する処理は完了である.</p>\n<h5 id="%E8%BF%94%E9%80%81%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E9%80%81%E4%BF%A1"><a class="header-anchor" href="#%E8%BF%94%E9%80%81%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E9%80%81%E4%BF%A1">¶</a> 返送チャンクの送信</h5>\n<p>ここで, 当該変換処理を一つにまとめ, 他の返送チャンクの変換も行い, 出来上がったバイト列をクライアント側に送信する.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    cmp::{\n        min\n    },\n    collections::{\n        HashMap\n    },\n    io::{\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult,\n        Write\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    }\n};\n\n<span class="hljs-keyword">const</span> DEFAULT_CHUNK_SIZE: <span class="hljs-built_in">u32</span> = <span class="hljs-number">128</span>;\n<span class="hljs-keyword">const</span> DEFAULT_BANDWIDTH: <span class="hljs-built_in">u32</span> = <span class="hljs-number">3000000</span>;\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-keyword">impl</span> BasicHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header_format</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u8</span> {\n        <span class="hljs-keyword">self</span>.message_header_format\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_chunk_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u16</span> {\n        <span class="hljs-keyword">self</span>.chunk_id\n    }\n}\n\n<span class="hljs-comment">// Option 型は, 格納している値が Copy 可能である場合はコンテナ自体にも Copy トレイトが付与される.</span>\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MessageHeader</span></span> {\n    timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_length: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_type: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt;,\n    message_id: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;\n}\n\n<span class="hljs-keyword">impl</span> MessageHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_length</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_length\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_type</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_type\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.mmessage_id\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PingData</span></span> {\n    StreamBegin(<span class="hljs-built_in">u32</span>)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    Unknown\n}\n\n<span class="hljs-comment">// String は Vec&lt;u8&gt; の Unicode 対応ラッパであり, HashMap も値の永続化のためにポインタレベルでのコピーを行っているため, Copy トレイトを付与できない.</span>\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InvokeCommand</span></span> {\n    Request {\n        command_name: <span class="hljs-built_in">String</span>,\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    },\n    Response {\n        command_name: <span class="hljs-built_in">String</span>,\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;,\n        information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    }\n}\n\n<span class="hljs-comment">// 一部に Vec が含まれるため, Copy トレイトを付与できない.</span>\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    ChunkSize(<span class="hljs-built_in">u32</span>),\n    Ping(<span class="hljs-built_in">u16</span>, PingData),\n    ServerBandwidth(<span class="hljs-built_in">u32</span>),\n    ClientBandwidth(<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u8</span>),\n    Invoke(InvokeCommand),\n    Unknown(<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;)\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span></span> {\n    basic_header: BasicHeader,\n    message_header: MessageHeader,\n    extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    data: Data\n}\n\n<span class="hljs-comment">// BasicHeader と MessageHeader は Copy トレイトを付与されたため, 参照でなくても返せるようになった.</span>\n<span class="hljs-keyword">impl</span> Chunk {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_basic_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; BasicHeader {\n        <span class="hljs-keyword">self</span>.basic_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; MessageHeader {\n        <span class="hljs-keyword">self</span>.message_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_extended_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.extended_timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_data</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Data {\n        &amp;<span class="hljs-keyword">self</span>.data\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_basic_header</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, basic_header: BasicHeader) {\n    <span class="hljs-keyword">let</span> message_header_format = basic_header.get_message_header_format();\n    <span class="hljs-keyword">let</span> chunk_id = basic_header.get_chunk_id();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> second_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> first_byte = <span class="hljs-keyword">if</span> chunk_id &gt; <span class="hljs-number">319</span> {\n        second_bytes.extend_from_slice(&amp;chunk_id.to_le_bytes());\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | <span class="hljs-number">1</span>\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> chunk_id &gt; <span class="hljs-number">63</span> {\n        second_bytes.push(chunk_id <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | <span class="hljs-number">0</span>\n    } <span class="hljs-keyword">else</span> {\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | chunk_id\n    };\n\n    v.push(first_byte);\n    v.append(&amp;<span class="hljs-keyword">mut</span> second_bytes);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_message_header</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, message_header: MessageHeader) {\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(timestamp) = message_header.get_timestamp() {\n        v.extend_from_slice(&amp;timestamp.to_be_bytes()[<span class="hljs-number">1</span>..]);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = message_header.get_message_length() {\n        v.extend_from_slice(&amp;message_length.to_be_bytes()[<span class="hljs-number">1</span>..]);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_type) = message_header.get_message_type() {\n        v.push(message_type);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> some(message_id) = message_header.get_message_id() {\n        v.extend_from_slice(&amp;message_id.to_le_bytes());\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_extended_timestamp</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;) {\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(extended_timestamp) = extended_timestamp {\n        v.extend_from_slice(&amp;extended_timestamp.to_be_bytes());\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_chunk_size</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, chunk_size: <span class="hljs-built_in">u32</span>) {\n    v.extend_from_slice(&amp;chunk_size.to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_ping</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, ping_type: <span class="hljs-built_in">u16</span>, ping_data: PingData) {\n    v.extend_from_slice(&amp;ping_type.to_be_bytes());\n\n    <span class="hljs-keyword">match</span> ping_data {\n        PingData::StreamBegin(message_id) =&gt; v.extend_from_slice(&amp;message_id.to_be_bytes())\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_server_bandwidth</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, server_bandwidth: <span class="hljs-built_in">u32</span>) {\n    v.extend_from_slice(&amp;server_bandwidth.to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_client_bandwidth</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, client_bandwidth: <span class="hljs-built_in">u32</span>, limit: <span class="hljs-built_in">u8</span>) {\n    v.extend_from_slice(&amp;client_bandwidth.to_be_bytes());\n    v.push(limit);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_number</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, number: <span class="hljs-built_in">f64</span>) {\n    v.push(<span class="hljs-number">0</span>);\n    v.extend_from_slice(&amp;number.to_bits().to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_boolean</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, boolean: <span class="hljs-built_in">bool</span>) {\n    v.push(<span class="hljs-number">1</span>);\n    v.push(boolean <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_string</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, <span class="hljs-keyword">mut</span> string: <span class="hljs-built_in">String</span>) {\n    v.push(<span class="hljs-number">2</span>);\n    v.extend_from_slice(&amp;(string.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n    v.append(string.as_mut_vec());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_object</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;) {\n    v.push(<span class="hljs-number">3</span>);\n\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">mut</span> name, value) <span class="hljs-keyword">in</span> object {\n        v.extend_from_slice(&amp;(name.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n        v.append(name.as_mut_vec());\n        encode_amf_data(v, value);\n    }\n\n    v.extend_from_slice(&amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>]);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_data</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, data: AmfData) {\n    <span class="hljs-keyword">match</span> data {\n        AmfData::Number(number) =&gt; encode_amf_number(v, number),\n        AmfData::Boolean(boolean) =&gt; encode_amf_boolean(v, boolean),\n        AmfData::<span class="hljs-built_in">String</span>(string) =&gt; encode_amf_string(v, string),\n        AmfData::Object(object) =&gt; encode_amf_object(v, object),\n        <span class="hljs-comment">// まだ上記以外の AMF 型のデータを特定できていないため, 現段階では無視することとする.</span>\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_invoke</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, invoke_command: InvokeCommand) {\n    <span class="hljs-keyword">match</span> invoke_command {\n        InvokeCommand::Response {\n            command_name,\n            transaction_id,\n            properties,\n            information\n        } =&gt; {\n            encode_amf_string(v, command_name);\n            encode_amf_number(v, transaction_id);\n            encode_amf_object(v, properties);\n            encode_amf_object(v, information);\n        },\n        <span class="hljs-comment">// 現時点では InvokeCommand::Request のエンコードについて考えないものとする.</span>\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_data</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, data: Data) {\n    <span class="hljs-keyword">match</span> data {\n        Data::ChunkSize(chunk_size) =&gt; encode_chunk_size(v, chunk_size),\n        Data::Ping(ping_type, ping_data) =&gt; encode_ping(v, ping_type, ping_data),\n        Data::ServerBandwidth(server_bandwidth) =&gt; encode_server_bandwidth(v, server_bandwidth),\n        Data::ClientBandwidth(client_bandwidth, limit) =&gt; encode_client_bandwidth(v, client_bandwidth, limit),\n        Data::Invoke(invoke_command) =&gt; encode_invoke(v, invoke_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_chunk</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, chunk: Chunk) {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_data(&amp;<span class="hljs-keyword">mut</span> data_bytes, chunk.get_data().clone());\n\n    <span class="hljs-keyword">let</span> message_length = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = chunk.get_message_header().get_message_length() {\n        message_length\n    } <span class="hljs-keyword">else</span> {\n        data_bytes.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>\n    };\n    <span class="hljs-keyword">let</span> splits = <span class="hljs-keyword">if</span> message_length &lt;= DEFAULT_CHUNK_SIZE {\n        <span class="hljs-number">0</span>\n    } <span class="hljs-keyword">else</span> {\n        message_length / DEFAULT_CHUNK_SIZE + (message_length % DEFAULT_CHUNK != <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>\n    };\n\n    <span class="hljs-keyword">if</span> splits &gt; <span class="hljs-number">0</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> added: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n        <span class="hljs-keyword">let</span> basic_header = BasicHeader {\n            message_header_format: <span class="hljs-number">3</span>,\n            <span class="hljs-comment">// Chunk 構造体の中から参照できるため, 今後はそれを利用する.</span>\n            chunk_id: chunk.get_basic_header().get_chunk_id()\n        };\n\n        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..splits {\n            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> {\n                encode_basic_header(&amp;<span class="hljs-keyword">mut</span> added, basic_header);\n            }\n\n            <span class="hljs-keyword">let</span> start = (DEFAULT_CHUNK_SIZE * i) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n            <span class="hljs-keyword">let</span> end = start + min(DEFAULT_CHUNK_SIZE, data_bytes[start..].len());\n\n            added.extend_from_slice(&amp;data_bytes[start..end]);\n        }\n\n        data_bytes = added;\n    }\n\n    encode_basic_header(v, chunk.get_basic_header());\n    encode_message_header(\n        v,\n        MessageHeader {\n            message_length,\n            <span class="hljs-comment">// 構造体の部分更新構文である.</span>\n            <span class="hljs-comment">// これにより, 正確なメッセージ長を上書きしている.</span>\n            ..chunk.get_message_header()\n        }\n    );\n    encode_extended_timestamp(v, chunk.get_extended_timestamp());\n    <span class="hljs-comment">// チャンク基本ヘッダを挟むために既にバイト列へ変換済みである.</span>\n    v.append(&amp;<span class="hljs-keyword">mut</span> data_bytes);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n        <span class="hljs-comment">/* ハンドシェイクは完了しているとみなす. */</span>\n        <span class="hljs-keyword">let</span> received_chunk = receive_chunk(&amp;<span class="hljs-keyword">mut</span> stream)?;\n        <span class="hljs-comment">/* 返送チャンクの送信処理. */</span>\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n        properties.insert(<span class="hljs-string">"fmsVer"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"FMS/3,0,1,123"</span>.to_string()));\n        properties.insert(<span class="hljs-string">"capabilities"</span>.to_string(), AmfData::Number(<span class="hljs-number">31</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n        information.insert(<span class="hljs-string">"level"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"status"</span>.to_string()));\n        information.insert(<span class="hljs-string">"code"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"NetConnection.Connect.Success"</span>.to_string()));\n        information.insert(<span class="hljs-string">"description"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"Connection succeeded."</span>.to_string()));\n        information.insert(<span class="hljs-string">"objectEncoding"</span>.to_string(), AmfData::Number(<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n\n        <span class="hljs-keyword">let</span> invoke = Chunk {\n            basic_header: BasicHeader {\n                message_header_format: <span class="hljs-number">0</span>,\n                chunk_id: <span class="hljs-number">3</span>\n            },\n            message_header: MessageHeader {\n                timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n                message_length: <span class="hljs-literal">None</span>,\n                message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">20</span>),\n                message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n            },\n            extended_timestamp: <span class="hljs-literal">None</span>,\n            data: Data::Invoke(\n                InvokeCommand::Response {\n                    command_name: <span class="hljs-string">"_result"</span>.to_string(),\n                    transaction_id: <span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>,\n                    properties,\n                    information\n                }\n            )\n        };\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> invoke_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n        <span class="hljs-keyword">let</span> server_bandwidth = Chunk {\n            basic_header: BasicHeader {\n                message_header_format: <span class="hljs-number">0</span>,\n                chunk_id: <span class="hljs-number">2</span>\n            },\n            message_header: MessageHeader {\n                timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n                message_length: <span class="hljs-literal">Some</span>(<span class="hljs-number">4</span>),\n                message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">5</span>),\n                message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n            },\n            extended_timestamp: <span class="hljs-literal">None</span>,\n            data: Data::ServerBandwidth(DEFAULT_BANDWIDTH)\n        };\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> server_bandwidth_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n        <span class="hljs-keyword">let</span> client_bandwidth = Chunk {\n            basic_header: BasicHeader {\n                message_header_format: <span class="hljs-number">0</span>,\n                chunk_id: <span class="hljs-number">2</span>\n            },\n            message_header: MessageHeader {\n                timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n                message_length: <span class="hljs-literal">Some</span>(<span class="hljs-number">5</span>),\n                message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">6</span>),\n                message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n            },\n            extended_timestamp: <span class="hljs-literal">None</span>,\n            data: Data::ClientBandwidth(DEFAULT_BANDWIDTH)\n        };\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> client_bandwidth_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n        <span class="hljs-keyword">let</span> ping = Chunk {\n            basic_header: BasicHeader {\n                message_header_format: <span class="hljs-number">0</span>,\n                chunk_id: <span class="hljs-number">2</span>\n            },\n            message_header: {\n                timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n                message_length: <span class="hljs-literal">Some</span>(<span class="hljs-number">6</span>),\n                message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">4</span>),\n                message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n            },\n            extended_timestamp: <span class="hljs-literal">None</span>,\n            data: Data::Ping(\n                <span class="hljs-number">0</span>,\n                <span class="hljs-comment">// この時点でのメッセージ ID は必然的に 0 である.</span>\n                PingData::StreamBegin(<span class="hljs-number">0</span>)\n            )\n        };\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> ping_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n        <span class="hljs-keyword">let</span> chunk_size = Chunk {\n            basic_header: BasicHeader {\n                message_header_format: <span class="hljs-number">0</span>,\n                chunk_id: <span class="hljs-number">2</span>\n            },\n            message_header: MessageHeader {\n                timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n                message_length: <span class="hljs-literal">Some</span>(<span class="hljs-number">4</span>),\n                message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">1</span>),\n                message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n            },\n            extended_timestamp: <span class="hljs-literal">None</span>,\n            data: Data::ChunkSize(DEFAULT_CHUNK_SIZE)\n        };\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> chunk_size_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n        encode_chunk(&amp;<span class="hljs-keyword">mut</span> invoke_bytes, invoke);\n        encode_chunk(&amp;<span class="hljs-keyword">mut</span> server_bandwidth_bytes, server_bandwidth);\n        encode_chunk(&amp;<span class="hljs-keyword">mut</span> client_bandwidth_bytes, client_bandwidth);\n        encode_chunk(&amp;<span class="hljs-keyword">mut</span> ping_bytes, ping);\n        encode_chunk(&amp;<span class="hljs-keyword">mut</span> chunk_size_bytes, chunk_size);\n        stream.write(invoke_bytes.as_slice())?;\n        stream.write(server_bandwidth_bytes.as_slice())?;\n        stream.write(client_bandwidth_bytes.as_slice())?;\n        stream.write(ping_bytes.as_slice())?;\n        stream.write(chunk_size.as_slice())?;\n        stream.write(invoke_bytes.as_slice()).map(|_| ())\n\n        <span class="hljs-comment">/* Invoke(releaseStream), Invoke(FCPublish) および Invoke(createStream) の受信処理に移る. */</span>\n    }\n\n    <span class="hljs-literal">Ok</span>(())\n}\n</code></pre>\n<p>上記の実装でエラーが一つも発生しなければ, Invoke(connect) リクエストへの返送処理は完了である. ここで, 当該処理を関数化して全体を見やすくする.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    cmp::{\n        min\n    },\n    collections::{\n        HashMap\n    },\n    io::{\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult,\n        Write\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    }\n};\n\n<span class="hljs-keyword">const</span> DEFAULT_CHUNK_SIZE: <span class="hljs-built_in">u32</span> = <span class="hljs-number">128</span>;\n<span class="hljs-keyword">const</span> DEFAULT_BANDWIDTH: <span class="hljs-built_in">u32</span> = <span class="hljs-number">3000000</span>;\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-keyword">impl</span> BasicHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header_format</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u8</span> {\n        <span class="hljs-keyword">self</span>.message_header_format\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_chunk_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u16</span> {\n        <span class="hljs-keyword">self</span>.chunk_id\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MessageHeader</span></span> {\n    timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_length: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_type: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt;,\n    message_id: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;\n}\n\n<span class="hljs-keyword">impl</span> MessageHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_length</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_length\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_type</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_type\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.mmessage_id\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PingData</span></span> {\n    StreamBegin(<span class="hljs-built_in">u32</span>)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    Unknown\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InvokeCommand</span></span> {\n    Request {\n        command_name: <span class="hljs-built_in">String</span>,\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    },\n    Response {\n        command_name: <span class="hljs-built_in">String</span>,\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;,\n        information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    ChunkSize(<span class="hljs-built_in">u32</span>),\n    Ping(<span class="hljs-built_in">u16</span>, PingData),\n    ServerBandwidth(<span class="hljs-built_in">u32</span>),\n    ClientBandwidth(<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u8</span>),\n    Invoke(InvokeCommand),\n    Unknown(<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;)\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span></span> {\n    basic_header: BasicHeader,\n    message_header: MessageHeader,\n    extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    data: Data\n}\n\n<span class="hljs-keyword">impl</span> Chunk {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_basic_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; BasicHeader {\n        <span class="hljs-keyword">self</span>.basic_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; MessageHeader {\n        <span class="hljs-keyword">self</span>.message_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_extended_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.extended_timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_data</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Data {\n        &amp;<span class="hljs-keyword">self</span>.data\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_basic_header</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, basic_header: BasicHeader) {\n    <span class="hljs-keyword">let</span> message_header_format = basic_header.get_message_header_format();\n    <span class="hljs-keyword">let</span> chunk_id = basic_header.get_chunk_id();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> second_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> first_byte = <span class="hljs-keyword">if</span> chunk_id &gt; <span class="hljs-number">319</span> {\n        second_bytes.extend_from_slice(&amp;chunk_id.to_le_bytes());\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | <span class="hljs-number">1</span>\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> chunk_id &gt; <span class="hljs-number">63</span> {\n        second_bytes.push(chunk_id <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | <span class="hljs-number">0</span>\n    } <span class="hljs-keyword">else</span> {\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | chunk_id\n    };\n\n    v.push(first_byte);\n    v.append(&amp;<span class="hljs-keyword">mut</span> second_bytes);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_message_header</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, message_header: MessageHeader) {\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(timestamp) = message_header.get_timestamp() {\n        v.extend_from_slice(&amp;timestamp.to_be_bytes()[<span class="hljs-number">1</span>..]);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = message_header.get_message_length() {\n        v.extend_from_slice(&amp;message_length.to_be_bytes()[<span class="hljs-number">1</span>..]);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_type) = message_header.get_message_type() {\n        v.push(message_type);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> some(message_id) = message_header.get_message_id() {\n        v.extend_from_slice(&amp;message_id.to_le_bytes());\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_extended_timestamp</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;) {\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(extended_timestamp) = extended_timestamp {\n        v.extend_from_slice(&amp;extended_timestamp.to_be_bytes());\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_chunk_size</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, chunk_size: <span class="hljs-built_in">u32</span>) {\n    v.extend_from_slice(&amp;chunk_size.to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_ping</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, ping_type: <span class="hljs-built_in">u16</span>, ping_data: PingData) {\n    v.extend_from_slice(&amp;ping_type.to_be_bytes());\n\n    <span class="hljs-keyword">match</span> ping_data {\n        PingData::StreamBegin(message_id) =&gt; v.extend_from_slice(&amp;message_id.to_be_bytes())\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_server_bandwidth</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, server_bandwidth: <span class="hljs-built_in">u32</span>) {\n    v.extend_from_slice(&amp;server_bandwidth.to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_client_bandwidth</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, client_bandwidth: <span class="hljs-built_in">u32</span>, limit: <span class="hljs-built_in">u8</span>) {\n    v.extend_from_slice(&amp;client_bandwidth.to_be_bytes());\n    v.push(limit);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_number</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, number: <span class="hljs-built_in">f64</span>) {\n    v.push(<span class="hljs-number">0</span>);\n    v.extend_from_slice(&amp;number.to_bits().to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_boolean</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, boolean: <span class="hljs-built_in">bool</span>) {\n    v.push(<span class="hljs-number">1</span>);\n    v.push(boolean <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_string</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, <span class="hljs-keyword">mut</span> string: <span class="hljs-built_in">String</span>) {\n    v.push(<span class="hljs-number">2</span>);\n    v.extend_from_slice(&amp;(string.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n    v.append(string.as_mut_vec());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_object</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;) {\n    v.push(<span class="hljs-number">3</span>);\n\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">mut</span> name, value) <span class="hljs-keyword">in</span> object {\n        v.extend_from_slice(&amp;(name.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n        v.append(name.as_mut_vec());\n        encode_amf_data(v, value);\n    }\n\n    v.extend_from_slice(&amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>]);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_data</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, data: AmfData) {\n    <span class="hljs-keyword">match</span> data {\n        AmfData::Number(number) =&gt; encode_amf_number(v, number),\n        AmfData::Boolean(boolean) =&gt; encode_amf_boolean(v, boolean),\n        AmfData::<span class="hljs-built_in">String</span>(string) =&gt; encode_amf_string(v, string),\n        AmfData::Object(object) =&gt; encode_amf_object(v, object),\n        <span class="hljs-comment">// まだ上記以外の AMF 型のデータを特定できていないため, 現段階では無視することとする.</span>\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_invoke</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, invoke_command: InvokeCommand) {\n    <span class="hljs-keyword">match</span> invoke_command {\n        InvokeCommand::Response {\n            command_name,\n            transaction_id,\n            properties,\n            information\n        } =&gt; {\n            encode_amf_string(v, command_name);\n            encode_amf_number(v, transaction_id);\n            encode_amf_object(v, properties);\n            encode_amf_object(v, information);\n        },\n        <span class="hljs-comment">// 現時点では InvokeCommand::Request のエンコードについて考えないものとする.</span>\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_data</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, data: Data) {\n    <span class="hljs-keyword">match</span> data {\n        Data::ChunkSize(chunk_size) =&gt; encode_chunk_size(v, chunk_size),\n        Data::Ping(ping_type, ping_data) =&gt; encode_ping(v, ping_type, ping_data),\n        Data::ServerBandwidth(server_bandwidth) =&gt; encode_server_bandwidth(v, server_bandwidth),\n        Data::ClientBandwidth(client_bandwidth, limit) =&gt; encode_client_bandwidth(v, client_bandwidth, limit),\n        Data::Invoke(invoke_command) =&gt; encode_invoke(v, invoke_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_chunk</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, chunk: Chunk) {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_data(&amp;<span class="hljs-keyword">mut</span> data_bytes, chunk.get_data().clone());\n\n    <span class="hljs-keyword">let</span> message_length = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = chunk.get_message_header().get_message_length() {\n        message_length\n    } <span class="hljs-keyword">else</span> {\n        data_bytes.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>\n    };\n    <span class="hljs-keyword">let</span> splits = <span class="hljs-keyword">if</span> message_length &lt;= DEFAULT_CHUNK_SIZE {\n        <span class="hljs-number">0</span>\n    } <span class="hljs-keyword">else</span> {\n        message_length / DEFAULT_CHUNK_SIZE + (message_length % DEFAULT_CHUNK != <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>\n    };\n\n    <span class="hljs-keyword">if</span> splits &gt; <span class="hljs-number">0</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> added: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n        <span class="hljs-keyword">let</span> basic_header = BasicHeader {\n            message_header_format: <span class="hljs-number">3</span>,\n            chunk_id: chunk.get_basic_header().get_chunk_id()\n        };\n\n        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..splits {\n            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> {\n                encode_basic_header(&amp;<span class="hljs-keyword">mut</span> added, basic_header);\n            }\n\n            <span class="hljs-keyword">let</span> start = (DEFAULT_CHUNK_SIZE * i) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n            <span class="hljs-keyword">let</span> end = start + min(DEFAULT_CHUNK_SIZE, data_bytes[start..].len());\n\n            added.extend_from_slice(&amp;data_bytes[start..end]);\n        }\n\n        data_bytes = added;\n    }\n\n    encode_basic_header(v, chunk.get_basic_header());\n    encode_message_header(\n        v,\n        MessageHeader {\n            message_length,\n            ..chunk.get_message_header()\n        }\n    );\n    encode_extended_timestamp(v, chunk.get_extended_timestamp());\n    v.append(&amp;<span class="hljs-keyword">mut</span> data_bytes);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_connect_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n    properties.insert(<span class="hljs-string">"fmsVer"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"FMS/3,0,1,123"</span>.to_string()));\n    properties.insert(<span class="hljs-string">"capabilities"</span>.to_string(), AmfData::Number(<span class="hljs-number">31</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n    information.insert(<span class="hljs-string">"level"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"status"</span>.to_string()));\n    information.insert(<span class="hljs-string">"code"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"NetConnection.Connect.Success"</span>.to_string()));\n    information.insert(<span class="hljs-string">"description"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"Connection succeeded."</span>.to_string()));\n    information.insert(<span class="hljs-string">"objectEncoding"</span>.to_string(), AmfData::Number(<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n\n    <span class="hljs-keyword">let</span> invoke = Chunk {\n        basic_header: BasicHeader {\n            message_header_format: <span class="hljs-number">0</span>,\n            chunk_id: <span class="hljs-number">3</span>\n        },\n        message_header: MessageHeader {\n            timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">20</span>),\n            message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n        },\n        extended_timestamp: <span class="hljs-literal">None</span>,\n        data: Data::Invoke(\n            InvokeCommand::Response {\n                command_name: <span class="hljs-string">"_result"</span>.to_string(),\n                transaction_id: <span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>,\n                properties,\n                information\n            }\n        )\n    };\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> invoke_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> server_bandwidth = Chunk {\n        basic_header: BasicHeader {\n            message_header_format: <span class="hljs-number">0</span>,\n            chunk_id: <span class="hljs-number">2</span>\n        },\n        message_header: MessageHeader {\n            timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n            message_length: <span class="hljs-literal">Some</span>(<span class="hljs-number">4</span>),\n            message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">5</span>),\n            message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n        },\n        extended_timestamp: <span class="hljs-literal">None</span>,\n        data: Data::ServerBandwidth(DEFAULT_BANDWIDTH)\n    };\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> server_bandwidth_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> client_bandwidth = Chunk {\n        basic_header: BasicHeader {\n            message_header_format: <span class="hljs-number">0</span>,\n            chunk_id: <span class="hljs-number">2</span>\n        },\n        message_header: MessageHeader {\n            timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n            message_length: <span class="hljs-literal">Some</span>(<span class="hljs-number">5</span>),\n            message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">6</span>),\n            message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n        },\n        extended_timestamp: <span class="hljs-literal">None</span>,\n        data: Data::ClientBandwidth(DEFAULT_BANDWIDTH)\n    };\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> client_bandwidth_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> ping = Chunk {\n        basic_header: BasicHeader {\n            message_header_format: <span class="hljs-number">0</span>,\n            chunk_id: <span class="hljs-number">2</span>\n        },\n        message_header: {\n            timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n            message_length: <span class="hljs-literal">Some</span>(<span class="hljs-number">6</span>),\n            message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">4</span>),\n            message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n        },\n        extended_timestamp: <span class="hljs-literal">None</span>,\n        data: Data::Ping(\n            <span class="hljs-number">0</span>,\n            PingData::StreamBegin(<span class="hljs-number">0</span>)\n        )\n    };\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> ping_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> chunk_size = Chunk {\n        basic_header: BasicHeader {\n            message_header_format: <span class="hljs-number">0</span>,\n            chunk_id: <span class="hljs-number">2</span>\n        },\n        message_header: MessageHeader {\n            timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n            message_length: <span class="hljs-literal">Some</span>(<span class="hljs-number">4</span>),\n            message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">1</span>),\n            message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n        },\n        extended_timestamp: <span class="hljs-literal">None</span>,\n        data: Data::ChunkSize(DEFAULT_CHUNK_SIZE)\n    };\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> chunk_size_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> invoke_bytes, invoke);\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> server_bandwidth_bytes, server_bandwidth);\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> client_bandwidth_bytes, client_bandwidth);\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> ping_bytes, ping);\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> chunk_size_bytes, chunk_size);\n    stream.write(invoke_bytes.as_slice())?;\n    stream.write(server_bandwidth_bytes.as_slice())?;\n    stream.write(client_bandwidth_bytes.as_slice())?;\n    stream.write(ping_bytes.as_slice())?;\n    stream.write(chunk_size.as_slice())?;\n    stream.write(invoke_bytes.as_slice()).map(|_| ())\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n        <span class="hljs-comment">/* ハンドシェイクは完了しているとみなす. */</span>\n        <span class="hljs-keyword">let</span> received_chunk = receive_chunk(&amp;<span class="hljs-keyword">mut</span> stream)?;\n\n        send_connect_response(&amp;<span class="hljs-keyword">mut</span> stream)?;\n\n        <span class="hljs-comment">/* Invoke(releaseStream), Invoke(FCPublish) および Invoke(createStream) の受信処理に移る. */</span>\n    }\n\n    <span class="hljs-literal">Ok</span>(())\n}\n</code></pre>\n<h3 id="releasestream%2C-fcpublish%2C-createstream"><a class="header-anchor" href="#releasestream%2C-fcpublish%2C-createstream">¶</a> releaseStream, FCPublish, createStream</h3>\n<p>サーバ側がクライアント側から受信した Invoke(connect) への返送を完了させると, 次にクライアント側はサーバ側にそれぞれ以下のチャンクを送信する.</p>\n<ul>\n<li>releaseStream</li>\n<li>FCPublish</li>\n<li>createStream</li>\n</ul>\n<p>上記チャンクに入力されている値を以下に記す.</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">コマンド名</th>\n<th style="text-align:right">チャンクストリーム ID</th>\n<th style="text-align:right">タイムスタンプ</th>\n<th style="text-align:right">メッセージ長</th>\n<th style="text-align:right">メッセージ種類 ID</th>\n<th style="text-align:right">メッセージストリーム ID</th>\n<th style="text-align:left">チャンクデータ</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left">\n<p>releaseStream</p>\n</td>\n<td style="text-align:right">\n<p>3</p>\n</td>\n<td style="text-align:right">\n<p>0</p>\n</td>\n<td style="text-align:right">\n<p>?</p>\n</td>\n<td style="text-align:right">\n<p>20</p>\n</td>\n<td style="text-align:right">\n<p>0</p>\n</td>\n<td style="text-align:left">\n<ul>\n<li>コマンド名: releaseStream</li>\n<li>トランザクション ID: 2 (おそらく)</li>\n<li>AMF における Null</li>\n<li>playpath: rtmp://example.com/appName/playpath 中の <em>playpath</em></li>\n</ul>\n</td>\n</tr>\n<tr>\n<td style="text-align:left">\n<p>FCPublish</p>\n</td>\n<td style="text-align:right">\n<p>3</p>\n</td>\n<td style="text-align:right">\n<p>0</p>\n</td>\n<td style="text-align:right">\n<p>?</p>\n</td>\n<td style="text-align:right">\n<p>20</p>\n</td>\n<td style="text-align:right">\n<p>-</p>\n</td>\n<td style="text-align:left">\n<ul>\n<li>コマンド名: FCPublish</li>\n<li>トランザクション ID: 3 (おそらく)</li>\n<li>AMF における Null</li>\n<li>playpath: releaseStream と同じ値</li>\n</ul>\n</td>\n</tr>\n<tr>\n<td style="text-align:left">\n<p>createStream</p>\n</td>\n<td style="text-align:right">\n<p>3</p>\n</td>\n<td style="text-align:right">\n<p>-</p>\n</td>\n<td style="text-align:right">\n<p>-</p>\n</td>\n<td style="text-align:right">\n<p>-</p>\n</td>\n<td style="text-align:right">\n<p>-</p>\n</td>\n<td style="text-align:left">\n<ul>\n<li>コマンド名: createStream</li>\n<li>トランザクション ID: 4 (おそらく)</li>\n<li>AMF における Null</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n<p>上記から, コマンドによってはチャンクメッセージヘッダのフィールドが欠ける(もしくはチャンクメッセージヘッダ自体が入力されていない)ことを説明できる. これらは, チャンクメッセージヘッダの形式が変化していることを意味している. 形式ごとのチャンクメッセージヘッダのフィールドを以下に記す.</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:right">チャンクメッセージヘッダの形式</th>\n<th style="text-align:center">タイムスタンプ</th>\n<th style="text-align:center">メッセージ長</th>\n<th style="text-align:center">メッセージの種類</th>\n<th style="text-align:center">メッセージストリーム ID</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:right">0</td>\n<td style="text-align:center">✔️</td>\n<td style="text-align:center">✔️</td>\n<td style="text-align:center">✔️</td>\n<td style="text-align:center">✔️</td>\n</tr>\n<tr>\n<td style="text-align:right">1</td>\n<td style="text-align:center">✔️</td>\n<td style="text-align:center">✔️</td>\n<td style="text-align:center">✔️</td>\n<td style="text-align:center">-</td>\n</tr>\n<tr>\n<td style="text-align:right">2</td>\n<td style="text-align:center">✔️</td>\n<td style="text-align:center">-</td>\n<td style="text-align:center">-</td>\n<td style="text-align:center">-</td>\n</tr>\n<tr>\n<td style="text-align:right">3</td>\n<td style="text-align:center">-</td>\n<td style="text-align:center">-</td>\n<td style="text-align:center">-</td>\n<td style="text-align:center">-</td>\n</tr>\n</tbody>\n</table>\n<p>公式ドキュメント<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>では, 形式 0 以外のチャンクメッセージヘッダを受信した時は直前に受信した<strong>チャンクストリーム ID が等しい</strong>チャンクから欠けている情報を参照するように指定されている. つまり, <strong>そのフィールドについては直前のチャンクに入力されていた値と同じである</strong>ようだ.</p>\n<h4 id="releasestream%2C-fcpublish%2C-createstream-%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%81%AE%E5%8F%97%E4%BF%A1%E3%81%A8%E8%BF%94%E9%80%81%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E9%80%81%E4%BF%A1"><a class="header-anchor" href="#releasestream%2C-fcpublish%2C-createstream-%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%81%AE%E5%8F%97%E4%BF%A1%E3%81%A8%E8%BF%94%E9%80%81%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E9%80%81%E4%BF%A1">¶</a> releaseStream, FCPublish, createStream コマンドの受信と返送チャンクの送信</h4>\n<p>次に, 上記の各種チャンクを受信する例を以下に記す.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    cmp::{\n        min\n    },\n    collections::{\n        HashMap\n    },\n    io::{\n        Read,\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    }\n};\n\n<span class="hljs-keyword">const</span> DEFAULT_CHUNK_SIZE: <span class="hljs-built_in">u32</span> = <span class="hljs-number">128</span>;\n<span class="hljs-keyword">const</span> DEFAULT_BANDWIDTH: <span class="hljs-built_in">u32</span> = <span class="hljs-number">3000000</span>;\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-keyword">impl</span> BasicHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header_format</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u8</span> {\n        <span class="hljs-keyword">self</span>.message_header_format\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_chunk_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u16</span> {\n        <span class="hljs-keyword">self</span>.chunk_id\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MessageHeader</span></span> {\n    timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_length: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_type: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt;,\n    message_id: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;\n}\n\n<span class="hljs-keyword">impl</span> MessageHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_length</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_length\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_type</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_type\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.mmessage_id\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PingData</span></span> {\n    StreamBegin(<span class="hljs-built_in">u32</span>)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    <span class="hljs-comment">// releaseStream, FCPublish および createStream がそれぞれコマンドオブジェクトと置き換える.</span>\n    Null,\n    Unknown\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ConnectCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;,\n        information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ReleaseStreamCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        playpath: <span class="hljs-built_in">String</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>\n    }\n}\n\n<span class="hljs-keyword">impl</span> ReleaseStreamCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-comment">// 要求チャンクが持っているトランザクション ID だけが欲しい.</span>\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            ReleaseStreamCommand::Request {\n                transaction_id,\n                play_path: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">CreateStreamCommand</span></span> {\n    <span class="hljs-comment">// createStream の要求チャンクは Null の部分を除けばトランザクション ID のみ.</span>\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>\n    },\n    <span class="hljs-comment">// 返送チャンクはトランザクション ID とメッセージストリーム ID を入力する.</span>\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        message_id: <span class="hljs-built_in">f64</span>\n    }\n}\n\n<span class="hljs-keyword">impl</span> CreateStreamCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-comment">// 同上</span>\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            CreateStreamCommand::Request {\n                transaction_id\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetConnectionCommand</span></span> {\n    Connect(ConnectCommand),\n    ReleaseStream(ReleaseStreamCommand),\n    CreateStream(CreateStreamCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FCPublishCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        playpath: <span class="hljs-built_in">String</span>\n    },\n    <span class="hljs-comment">// FCPublish の返送チャンクはコマンド名(onFCPublish)のみ.</span>\n    Response\n}\n\n<span class="hljs-keyword">impl</span> FCPublishCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-comment">// 同上</span>\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            FCPublishCommand::Request {\n                transaction_id,\n                playpath: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-comment">// コマンドのパターンが増えたため, 再構築する.</span>\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InvokeCommand</span></span> {\n    NetConnection(NetConnectionCommand),\n    FCPublish(FCPublishCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    ChunkSize(<span class="hljs-built_in">u32</span>),\n    Ping(<span class="hljs-built_in">u16</span>, PingData),\n    ServerBandwidth(<span class="hljs-built_in">u32</span>),\n    ClientBandwidth(<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u8</span>),\n    Invoke(InvokeCommand),\n    Unknown(<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;)\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span></span> {\n    basic_header: BasicHeader,\n    message_header: MessageHeader,\n    extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    data: Data\n}\n\n<span class="hljs-keyword">impl</span> Chunk {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_basic_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; BasicHeader {\n        <span class="hljs-keyword">self</span>.basic_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; MessageHeader {\n        <span class="hljs-keyword">self</span>.message_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_extended_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.extended_timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_data</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Data {\n        &amp;<span class="hljs-keyword">self</span>.data\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_basic_header</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, basic_header: BasicHeader) {\n    <span class="hljs-keyword">let</span> message_header_format = basic_header.get_message_header_format();\n    <span class="hljs-keyword">let</span> chunk_id = basic_header.get_chunk_id();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> second_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> first_byte = <span class="hljs-keyword">if</span> chunk_id &gt; <span class="hljs-number">319</span> {\n        second_bytes.extend_from_slice(&amp;chunk_id.to_le_bytes());\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | <span class="hljs-number">1</span>\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> chunk_id &gt; <span class="hljs-number">63</span> {\n        second_bytes.push(chunk_id <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | <span class="hljs-number">0</span>\n    } <span class="hljs-keyword">else</span> {\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | chunk_id\n    };\n\n    v.push(first_byte);\n    v.append(&amp;<span class="hljs-keyword">mut</span> second_bytes);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_message_header</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, message_header: MessageHeader) {\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(timestamp) = message_header.get_timestamp() {\n        v.extend_from_slice(&amp;timestamp.to_be_bytes()[<span class="hljs-number">1</span>..]);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = message_header.get_message_length() {\n        v.extend_from_slice(&amp;message_length.to_be_bytes()[<span class="hljs-number">1</span>..]);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_type) = message_header.get_message_type() {\n        v.push(message_type);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> some(message_id) = message_header.get_message_id() {\n        v.extend_from_slice(&amp;message_id.to_le_bytes());\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_extended_timestamp</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;) {\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(extended_timestamp) = extended_timestamp {\n        v.extend_from_slice(&amp;extended_timestamp.to_be_bytes());\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_chunk_size</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, chunk_size: <span class="hljs-built_in">u32</span>) {\n    v.extend_from_slice(&amp;chunk_size.to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_ping</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, ping_type: <span class="hljs-built_in">u16</span>, ping_data: PingData) {\n    v.extend_from_slice(&amp;ping_type.to_be_bytes());\n\n    <span class="hljs-keyword">match</span> ping_data {\n        PingData::StreamBegin(message_id) =&gt; v.extend_from_slice(&amp;message_id.to_be_bytes())\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_server_bandwidth</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, server_bandwidth: <span class="hljs-built_in">u32</span>) {\n    v.extend_from_slice(&amp;server_bandwidth.to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_client_bandwidth</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, client_bandwidth: <span class="hljs-built_in">u32</span>, limit: <span class="hljs-built_in">u8</span>) {\n    v.extend_from_slice(&amp;client_bandwidth.to_be_bytes());\n    v.push(limit);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_number</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, number: <span class="hljs-built_in">f64</span>) {\n    v.push(<span class="hljs-number">0</span>);\n    v.extend_from_slice(&amp;number.to_bits().to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_boolean</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, boolean: <span class="hljs-built_in">bool</span>) {\n    v.push(<span class="hljs-number">1</span>);\n    v.push(boolean <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_string</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, <span class="hljs-keyword">mut</span> string: <span class="hljs-built_in">String</span>) {\n    v.push(<span class="hljs-number">2</span>);\n    v.extend_from_slice(&amp;(string.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n    v.append(string.as_mut_vec());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_object</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;) {\n    v.push(<span class="hljs-number">3</span>);\n\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">mut</span> name, value) <span class="hljs-keyword">in</span> object {\n        v.extend_from_slice(&amp;(name.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n        v.append(name.as_mut_vec());\n        encode_amf_data(v, value);\n    }\n\n    v.extend_from_slice(&amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>]);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_null</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;) {\n    v.push(<span class="hljs-number">5</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_data</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, data: AmfData) {\n    <span class="hljs-keyword">match</span> data {\n        AmfData::Number(number) =&gt; encode_amf_number(v, number),\n        AmfData::Boolean(boolean) =&gt; encode_amf_boolean(v, boolean),\n        AmfData::<span class="hljs-built_in">String</span>(string) =&gt; encode_amf_string(v, string),\n        AmfData::Object(object) =&gt; encode_amf_object(v, object),\n        AmfData::Null =&gt; encode_amf_null(v),\n        <span class="hljs-comment">// まだ上記以外の AMF 型のデータを特定できていないため, 現段階では無視することとする.</span>\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_connect</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, connect_command: ConnectCommand) {\n    <span class="hljs-keyword">match</span> connect_command {\n        <span class="hljs-comment">// パターンの増加に対応してそれぞれ名前を付けたため, コマンド名を格納する必要がなくなった.</span>\n        Connect::Response {\n            transaction_id,\n            properties,\n            information\n        } =&gt; {\n            encode_amf_string(v, <span class="hljs-string">"_result"</span>.to_string());\n            encode_amf_number(v, transaction_id);\n            encode_amf_object(v, properties);\n            encode_amf_object(v, information);\n        },\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_release_stream</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, release_stream_command: ReleaseStreamCommand) {\n    <span class="hljs-keyword">match</span> release_stream_command {\n        ReleaseStreamCommand::Response {\n            transaction_id\n        } =&gt; {\n            encode_amf_string(v, <span class="hljs-string">"_result"</span>.to_string());\n            encode_amf_number(v, transaction_id);\n            encode_amf_null(v);\n        },\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_create_stream</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, create_stream_command: CreateStreamCommand) {\n    <span class="hljs-keyword">match</span> create_stream_command {\n        CreateStreamCommand::Response {\n            transaction_id,\n            message_id\n        } =&gt; {\n            encode_amf_string(v, <span class="hljs-string">"_result"</span>.to_string);\n            encode_amf_number(v, transaction_id);\n            encode_amf_null(v);\n            encode_amf_number(v, message_id);\n        },\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_net_connection</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, net_connection_command: NetConnectionCommand) {\n    <span class="hljs-keyword">match</span> net_connection_command {\n        Connect(connect_command) =&gt; encode_connect(v, connect_command),\n        ReleaseStream(release_stream_command) =&gt; encode_release_stream(v, release_stream_command),\n        CreateStream(create_stream_command) =&gt; encode_create_stream(v, create_stream_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_fc_publish</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, fc_publish_command: FCPublishCommand) {\n    <span class="hljs-keyword">match</span> fc_publish_command {\n        FCPublishCommand::Response =&gt; encode_amf_string(v, <span class="hljs-string">"onFCPublish"</span>.to_string()),\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_invoke</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, invoke_command: InvokeCommand) {\n    <span class="hljs-keyword">match</span> invoke_command {\n        InvokeCommand::NetConnection(net_connection_command) =&gt; encode_net_connection(v, net_connection_command),\n        InvokeCommand::FCPublish(fc_publish_command) =&gt; encode_fc_publish(v, fc_publish_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_data</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, data: Data) {\n    <span class="hljs-keyword">match</span> data {\n        Data::ChunkSize(chunk_size) =&gt; encode_chunk_size(v, chunk_size),\n        Data::Ping(ping_type, ping_data) =&gt; encode_ping(v, ping_type, ping_data),\n        Data::ServerBandwidth(server_bandwidth) =&gt; encode_server_bandwidth(v, server_bandwidth),\n        Data::ClientBandwidth(client_bandwidth, limit) =&gt; encode_client_bandwidth(v, client_bandwidth, limit),\n        Data::Invoke(invoke_command) =&gt; encode_invoke(v, invoke_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_chunk</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, chunk: Chunk) {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_data(&amp;<span class="hljs-keyword">mut</span> data_bytes, chunk.get_data().clone());\n\n    <span class="hljs-keyword">let</span> message_length = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = chunk.get_message_header().get_message_length() {\n        message_length\n    } <span class="hljs-keyword">else</span> {\n        data_bytes.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>\n    };\n    <span class="hljs-keyword">let</span> splits = <span class="hljs-keyword">if</span> message_length &lt;= DEFAULT_CHUNK_SIZE {\n        <span class="hljs-number">0</span>\n    } <span class="hljs-keyword">else</span> {\n        message_length / DEFAULT_CHUNK_SIZE + (message_length % DEFAULT_CHUNK != <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>\n    };\n\n    <span class="hljs-keyword">if</span> splits &gt; <span class="hljs-number">0</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> added: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n        <span class="hljs-keyword">let</span> basic_header = BasicHeader {\n            message_header_format: <span class="hljs-number">3</span>,\n            chunk_id: chunk.get_basic_header().get_chunk_id()\n        };\n\n        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..splits {\n            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> {\n                encode_basic_header(&amp;<span class="hljs-keyword">mut</span> added, basic_header);\n            }\n\n            <span class="hljs-keyword">let</span> start = (DEFAULT_CHUNK_SIZE * i) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n            <span class="hljs-keyword">let</span> end = start + min(DEFAULT_CHUNK_SIZE, data_bytes[start..].len());\n\n            added.extend_from_slice(&amp;data_bytes[start..end]);\n        }\n\n        data_bytes = added;\n    }\n\n    encode_basic_header(v, chunk.get_basic_header());\n    encode_message_header(\n        v,\n        MessageHeader {\n            message_length,\n            ..chunk.get_message_header()\n        }\n    );\n    encode_extended_timestamp(v, chunk.get_extended_timestamp());\n    v.append(&amp;<span class="hljs-keyword">mut</span> data_bytes);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_connect_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, connect_command: ConnectCommand) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-comment">/* 受信した connect コマンドを記憶する処理...? */</span>\n\n    <span class="hljs-comment">/* connect コマンドの返送チャンクを作成・送信する処理 */</span>\n    <span class="hljs-comment">// 基本的に受信チャンクのトランザクション ID をコピーする.</span>\n    <span class="hljs-keyword">let</span> transaction_id = connect_command.get_received_transaction_id().unwrap();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n    properties.insert(<span class="hljs-string">"fmsVer"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"FMS/3,0,1,123"</span>.to_string()));\n    properties.insert(<span class="hljs-string">"capabilities"</span>.to_string(), AmfData::Number(<span class="hljs-number">31</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n    information.insert(<span class="hljs-string">"level"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"status"</span>.to_string()));\n    information.insert(<span class="hljs-string">"code"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"NetConnection.Connect.Success"</span>.to_string()));\n    information.insert(<span class="hljs-string">"description"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"Connection succeeded."</span>.to_string()));\n    information.insert(<span class="hljs-string">"objectEncoding"</span>.to_string(), AmfData::Number(<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n\n    <span class="hljs-keyword">let</span> invoke = Chunk {\n        basic_header: BasicHeader {\n            message_header_format: <span class="hljs-number">0</span>,\n            chunk_id: <span class="hljs-number">3</span>\n        },\n        message_header: MessageHeader {\n            timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">20</span>),\n            message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n        },\n        extended_timestamp: <span class="hljs-literal">None</span>,\n        data: Data::Invoke(\n            <span class="hljs-comment">// 構造が変更されたので追従する.</span>\n            InvokeCommand::NetConnection(\n                NetConnectionCommand::Connect(\n                    ConnectCommand::Response {\n                        transaction_id,\n                        properties,\n                        information\n                    }\n                )\n            )\n        )\n    };\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> invoke_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> server_bandwidth = Chunk {\n        basic_header: BasicHeader {\n            message_header_format: <span class="hljs-number">0</span>,\n            chunk_id: <span class="hljs-number">2</span>\n        },\n        message_header: MessageHeader {\n            timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n            message_length: <span class="hljs-literal">Some</span>(<span class="hljs-number">4</span>),\n            message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">5</span>),\n            message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n        },\n        extended_timestamp: <span class="hljs-literal">None</span>,\n        data: Data::ServerBandwidth(DEFAULT_BANDWIDTH)\n    };\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> server_bandwidth_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> client_bandwidth = Chunk {\n        basic_header: BasicHeader {\n            message_header_format: <span class="hljs-number">0</span>,\n            chunk_id: <span class="hljs-number">2</span>\n        },\n        message_header: MessageHeader {\n            timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n            message_length: <span class="hljs-literal">Some</span>(<span class="hljs-number">5</span>),\n            message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">6</span>),\n            message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n        },\n        extended_timestamp: <span class="hljs-literal">None</span>,\n        data: Data::ClientBandwidth(DEFAULT_BANDWIDTH)\n    };\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> client_bandwidth_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> ping = Chunk {\n        basic_header: BasicHeader {\n            message_header_format: <span class="hljs-number">0</span>,\n            chunk_id: <span class="hljs-number">2</span>\n        },\n        message_header: {\n            timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n            message_length: <span class="hljs-literal">Some</span>(<span class="hljs-number">6</span>),\n            message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">4</span>),\n            message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n        },\n        extended_timestamp: <span class="hljs-literal">None</span>,\n        data: Data::Ping(\n            <span class="hljs-number">0</span>,\n            PingData::StreamBegin(<span class="hljs-number">0</span>)\n        )\n    };\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> ping_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> chunk_size = Chunk {\n        basic_header: BasicHeader {\n            message_header_format: <span class="hljs-number">0</span>,\n            chunk_id: <span class="hljs-number">2</span>\n        },\n        message_header: MessageHeader {\n            timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n            message_length: <span class="hljs-literal">Some</span>(<span class="hljs-number">4</span>),\n            message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">1</span>),\n            message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n        },\n        extended_timestamp: <span class="hljs-literal">None</span>,\n        data: Data::ChunkSize(DEFAULT_CHUNK_SIZE)\n    };\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> chunk_size_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> invoke_bytes, invoke);\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> server_bandwidth_bytes, server_bandwidth);\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> client_bandwidth_bytes, client_bandwidth);\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> ping_bytes, ping);\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> chunk_size_bytes, chunk_size);\n    stream.write(invoke_bytes.as_slice())?;\n    stream.write(server_bandwidth_bytes.as_slice())?;\n    stream.write(client_bandwidth_bytes.as_slice())?;\n    stream.write(ping_bytes.as_slice())?;\n    stream.write(chunk_size.as_slice())?;\n    stream.write(invoke_bytes.as_slice()).map(|_| ())\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_release_stream_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, release_stream_command: ReleaseStreamCommand) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-comment">/* 受信した releaseStream コマンドを記憶する処理...? */</span>\n\n    <span class="hljs-comment">/* releaseStream コマンドの返送チャンクを作成・送信する処理 */</span>\n    <span class="hljs-keyword">let</span> transaction_id = release_stream_command.get_received_trnasaction_id().unwrap();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> invoke = Chunk {\n        basic_header: BasicHeader {\n            <span class="hljs-comment">// 現時点ではまだ決定できない.</span>\n            message_header_format: ?,\n            chunk_id: <span class="hljs-number">3</span>\n        },\n        message_header: MessageHeader {\n            timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">20</span>),\n            message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n        },\n        extended_timestamp: <span class="hljs-literal">None</span>,\n        data: Data::Invoke(\n            InvokeCommand::NetConnection(\n                NetConnectionCommand::ReleaseStream(\n                    ReleaseStreamCommand::Response {\n                        transaction_id\n                    }\n                )\n            )\n        )\n    };\n\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> v, invoke);\n    stream.write(&amp;<span class="hljs-keyword">mut</span> stream, v.as_slice()).map(|_| ())\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_create_stream_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, create_stream_command: CreateStreamCommand, message_id: <span class="hljs-built_in">f64</span>) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-comment">/* 受信した createStream コマンドを記憶する処理...? */</span>\n\n    <span class="hljs-comment">// 同上.</span>\n    <span class="hljs-keyword">let</span> transaction_id = create_stream_command.get_received_transaction_id().unwrap();\n\n    <span class="hljs-comment">/* createStream コマンドの返送チャンクを作成・送信する処理 */</span>\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> invoke = Chunk {\n        basic_header: BasicHeader {\n            <span class="hljs-comment">// 同上</span>\n            message_header_format: ?,\n            chunk_id: <span class="hljs-number">3</span>\n        },\n        message_header: MessageHeader {\n            timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">20</span>),\n            message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n        },\n        extended_timestamp: <span class="hljs-literal">None</span>,\n        data: Data::Invoke(\n            InvokeCommand::NetConnection(\n                NetConnectionCommand::CreateStream(\n                    CreateStreamCommand::Response {\n                        transaction_id,\n                        message_id\n                    }\n                )\n            )\n        )\n    };\n\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> v, invoke);\n    stream.write(v.as_slice()).map(|_| ())\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_net_connection_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, net_connection_command: NetConnectionCommand) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">match</span> net_connection_command {\n        NetConnectionCommand::Connect(connect_command) =&gt; send_connect_response(stream, connect_command),\n        NetConnectionCommand::ReleaseStream(release_stream_command) =&gt; send_release_stream_response(stream, release_stream_command),\n        NetConnectionCommand::CreateStream(create_stream_command) =&gt; send_create_stream_command(stream, create_stream_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_fc_publish_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, fc_publish_command: FCPublishCommand) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-comment">/* 受信した FCPublish コマンドを記憶する処理...? */</span>\n\n    <span class="hljs-comment">/* FCPublish コマンドの返送チャンクを作成・送信する処理 */</span>\n    <span class="hljs-keyword">let</span> transaction_id = fc_publish_command.get_received_transaction_id().unwrap();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> invoke = Chunk {\n        basic_header: BasicHeader {\n            <span class="hljs-comment">// 同上</span>\n            message_header_format: ?,\n            chunk_id: <span class="hljs-number">3</span>\n        },\n        message_header: MessageHeader {\n            timestamp: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>),\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">Some</span>(<span class="hljs-number">20</span>),\n            message_id: <span class="hljs-literal">Some</span>(<span class="hljs-number">0</span>)\n        },\n        extended_timestamp: <span class="hljs-literal">None</span>,\n        data: Data::Invoke(\n            InvokeCommand::FCPublish(\n                FCPublishCommand::Response\n            )\n        )\n    };\n\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> v, invoke);\n    stream.write(v.as_slice()).map(|_| ())\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_invoke_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, invoke_command: InvokeCommand) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">match</span> invoke_command {\n        InvokeCommand::NetConnection(net_connection_command) =&gt; send_net_connection_response(stream, net_connection_command),\n        InvokeCommand::FCPublish(fc_publish_command) =&gt; send_fc_publish_response(stream, fc_publish)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener = TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n        <span class="hljs-comment">/* ハンドシェイクは完了しているとみなす. */</span>\n        <span class="hljs-keyword">let</span> received_chunk = receive_chunk(&amp;<span class="hljs-keyword">mut</span> stream)?;\n\n        <span class="hljs-keyword">match</span> received_chunk.get_data().clone() {\n            Data::Invoke(invoke_command) =&gt; send_invoke_response(&amp;<span class="hljs-keyword">mut</span> stream, invoke_command)?,\n            <span class="hljs-comment">// 今のところ, Invoke チャンクの処理のみを考える.</span>\n            _ =&gt; {}\n        }\n    }\n\n    <span class="hljs-literal">Ok</span>(())\n}\n</code></pre>\n<p>これで releaseStream, FCPublish および createStream チャンクそれぞれの受信と各応答チャンクの送信自体は実装した.</p>\n<h4 id="%E7%9B%B4%E5%89%8D%E3%81%AE%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E6%83%85%E5%A0%B1%E3%81%AE%E4%BF%9D%E5%AD%98"><a class="header-anchor" href="#%E7%9B%B4%E5%89%8D%E3%81%AE%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E6%83%85%E5%A0%B1%E3%81%AE%E4%BF%9D%E5%AD%98">¶</a> 直前のチャンクの情報の保存</h4>\n<p>上記から更に以下の点を考慮する:</p>\n<ol>\n<li>送受信したチャンクの内容を記憶する方法</li>\n<li>送信するチャンクメッセージヘッダの形式を決定する方法</li>\n<li>直前のチャンクからチャンクメッセージヘッダを参照する方法</li>\n</ol>\n<h5 id="%E5%8F%97%E4%BF%A1%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E5%A0%B4%E5%90%88"><a class="header-anchor" href="#%E5%8F%97%E4%BF%A1%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E5%A0%B4%E5%90%88">¶</a> 受信チャンクの場合</h5>\n<p>まず, 受信チャンクの場合の例を以下に記す. 上記の例ではコメントを残したのみではあるが, 当該箇所から受信したすべてのチャンクに対して同様に行う必要があることが予想できる. つまり, チャンクデータの種類を問わず受信時にまとめて行う必要がある. それは <code>receive_chunk</code> の実装を以下のように追記することで行うことができる.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    collections::{\n        HashMap\n    },\n    io::{\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult\n    },\n    net::{\n        TcpStream\n    }\n};\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-keyword">impl</span> BasicHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header_format</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u8</span> {\n        <span class="hljs-keyword">self</span>.message_header_format\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_chunk_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u16</span> {\n        <span class="hljs-keyword">self</span>.chunk_id\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MessageHeader</span></span> {\n    timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_length: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_type: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt;,\n    message_id: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;\n}\n\n<span class="hljs-keyword">impl</span> MessageHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_timestamp</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, timestamp: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.timestamp = <span class="hljs-literal">Some</span>(timestamp);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_length</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_length\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_length</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_length: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.message_length = <span class="hljs-literal">Some</span>(message_length);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_type</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_type\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_type</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_type: <span class="hljs-built_in">u8</span>) {\n        <span class="hljs-keyword">self</span>.message_type = <span class="hljs-literal">Some</span>(message_type);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.mmessage_id\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_id</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_id: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.message_id = <span class="hljs-literal">Some</span>(message_id);\n    }\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span></span> {\n    basic_header: BasicHeader,\n    message_header: MessageHeader,\n    extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    data: Data\n}\n\n<span class="hljs-keyword">impl</span> Chunk {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_basic_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; BasicHeader {\n        <span class="hljs-keyword">self</span>.basic_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; MessageHeader {\n        <span class="hljs-keyword">self</span>.message_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_extended_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.extended_timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_data</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Data {\n        &amp;<span class="hljs-keyword">self</span>.data\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_chunk</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, last_received_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;Chunk&gt; {\n    <span class="hljs-keyword">let</span> basic_header = receive_basic_header(stream)?;\n    <span class="hljs-keyword">let</span> chunk_id = basic_header.get_chunk_id();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_message_header = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span> (<span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> last_message_header) = last_received_chunks.get_mut(&amp;chunk_id) {\n        *last_message_header\n    } <span class="hljs-keyword">else</span> {\n        MessageHeader {\n            timestamp: <span class="hljs-literal">None</span>,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        }\n    };\n    <span class="hljs-keyword">let</span> received_message_header = receive_message_header(stream, basic_header.get_message_header_format())?;\n    <span class="hljs-keyword">let</span> timestamp = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(timestamp) = received_message_header.get_timestamp() {\n        timestamp\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-comment">// 仕様上, 受信チャンクにない時は記憶済みの直前のチャンクメッセージヘッダから参照できると考えて良い.</span>\n        last_message_header.get_timestamp().unwrap()\n    };\n    <span class="hljs-keyword">let</span> message_length = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = received_message_header.get_message_length() {\n        message_length\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-comment">// 同上.</span>\n        last_message_header.unwrap().get_message_length().unwrap()\n    };\n    <span class="hljs-keyword">let</span> message_type = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_type) = received_message_header.get_message_type() {\n        message_type\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-comment">// 同上.</span>\n        last_message_header.get_message_type().unwrap()\n    };\n    <span class="hljs-keyword">let</span> message_id = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_id) = received_message_header.get_message_id() {\n        message_id\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-comment">// 同上.</span>\n        last_message_header.get_message_id().unwrap()\n    };\n    <span class="hljs-keyword">let</span> extended_timestamp = receive_extended_timestamp(stream, timestamp)?;\n    <span class="hljs-keyword">let</span> data = receive_data(stream, message_type, message_length)?;\n\n    last_message_header.set_timestamp(timestamp);\n    last_message_header.set_message_length(message_length);\n    last_message_header.set_message_type(message_type);\n    last_message_header.set_message_id(message_id);\n    last_received_chunks.insert(chunk_id, last_message_header);\n\n    <span class="hljs-literal">Ok</span>(\n        Chunk {\n            basic_header,\n            message_header,\n            extended_timestamp,\n            data\n        }\n    )\n}\n</code></pre>\n<h5 id="%E9%80%81%E4%BF%A1%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E5%A0%B4%E5%90%88"><a class="header-anchor" href="#%E9%80%81%E4%BF%A1%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E5%A0%B4%E5%90%88">¶</a> 送信チャンクの場合</h5>\n<p>次に, 送信チャンクの場合の例を以下に記す.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    collections::{\n        HashMap\n    },\n    io::{\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult,\n        Write\n    },\n    net::{\n        TcpStream\n    }\n};\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-keyword">impl</span> BasicHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header_format</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u8</span> {\n        <span class="hljs-keyword">self</span>.message_header_format\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_chunk_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u16</span> {\n        <span class="hljs-keyword">self</span>.chunk_id\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MessageHeader</span></span> {\n    timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_length: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_type: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt;,\n    message_id: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;\n}\n\n<span class="hljs-keyword">impl</span> MessageHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_timestamp</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, timestamp: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.timestamp = <span class="hljs-literal">Some</span>(timestamp);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_length</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_length\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_length</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_length: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.message_length = <span class="hljs-literal">Some</span>(message_length);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_type</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_type\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_type</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_type: <span class="hljs-built_in">u8</span>) {\n        <span class="hljs-keyword">self</span>.message_type = <span class="hljs-literal">Some</span>(message_type);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.mmessage_id\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_id</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_id: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.message_id = <span class="hljs-literal">Some</span>(message_id);\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PingData</span></span> {\n    StreamBegin(<span class="hljs-built_in">u32</span>)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    Null,\n    Unknown\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ConnectCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;,\n        information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ReleaseStreamCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        playpath: <span class="hljs-built_in">String</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>\n    }\n}\n\n<span class="hljs-keyword">impl</span> ReleaseStreamCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            ReleaseStreamCommand::Request {\n                transaction_id,\n                play_path: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">CreateStreamCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        message_id: <span class="hljs-built_in">f64</span>\n    }\n}\n\n<span class="hljs-keyword">impl</span> CreateStreamCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            CreateStreamCommand::Request {\n                transaction_id\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetConnectionCommand</span></span> {\n    Connect(ConnectCommand),\n    ReleaseStream(ReleaseStreamCommand),\n    CreateStream(CreateStreamCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FCPublishCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        playpath: <span class="hljs-built_in">String</span>\n    },\n    Response\n}\n\n<span class="hljs-keyword">impl</span> FCPublishCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            FCPublishCommand::Request {\n                transaction_id,\n                playpath: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InvokeCommand</span></span> {\n    NetConnection(NetConnectionCommand),\n    FCPublish(FCPublishCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    ChunkSize(<span class="hljs-built_in">u32</span>),\n    Ping(<span class="hljs-built_in">u16</span>, PingData),\n    ServerBandwidth(<span class="hljs-built_in">u32</span>),\n    ClientBandwidth(<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u8</span>),\n    Invoke(InvokeCommand),\n    Unknown(<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;)\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span></span> {\n    basic_header: BasicHeader,\n    message_header: MessageHeader,\n    extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    data: Data\n}\n\n<span class="hljs-keyword">impl</span> Chunk {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_basic_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; BasicHeader {\n        <span class="hljs-keyword">self</span>.basic_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; MessageHeader {\n        <span class="hljs-keyword">self</span>.message_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_extended_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.extended_timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_data</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Data {\n        &amp;<span class="hljs-keyword">self</span>.data\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_chunk</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, chunk_id: <span class="hljs-built_in">u16</span>, <span class="hljs-keyword">mut</span> timestamp: <span class="hljs-built_in">u32</span>, message_length: <span class="hljs-built_in">u32</span>, message_type: <span class="hljs-built_in">u8</span>, message_id: <span class="hljs-built_in">u32</span>, data: Data, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_message_header = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> last_message_header) = last_sent_chunks.get_mut(&amp;chunk_id) {\n        *last_message_header\n    } <span class="hljs-keyword">else</span> {\n        MessageHeader {\n            timestamp: <span class="hljs-literal">None</span>,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        }\n    };\n    <span class="hljs-keyword">let</span> last_timestamp = last_message_header.get_timestamp().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_length = last_message_header.get_message_length().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_type = last_message_header.get_message_type().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_id = last_message_header.get_message_id().unwrap_or_default();\n    <span class="hljs-keyword">let</span> message_header_format: <span class="hljs-built_in">u8</span> = <span class="hljs-keyword">if</span> message_id == last_message_id {\n        <span class="hljs-comment">// メッセージストリーム ID のみ同じ場合は形式 1 である.</span>\n        <span class="hljs-keyword">if</span> message_length == last_message_length &amp;&amp; message_type == last_message_type {\n            <span class="hljs-comment">// メッセージストリーム ID に加えて, メッセージ長とメッセージの種類が同じ場合は形式 2 である.</span>\n            <span class="hljs-keyword">if</span> timestamp == last_timestamp {\n                <span class="hljs-comment">// すべて同じ場合は形式 3 である.</span>\n                <span class="hljs-number">3</span>\n            } <span class="hljs-keyword">else</span> {\n                <span class="hljs-number">2</span>\n            }\n        } <span class="hljs-keyword">else</span> {\n            <span class="hljs-number">1</span>\n        }\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-comment">// メッセージ ID が違う場合は, 他のどのフィールドが同じでも形式 0 である.</span>\n        <span class="hljs-number">0</span>\n    };\n    <span class="hljs-keyword">let</span> basic_header = BasicHeader {\n        message_header_format,\n        chunk_id\n    };\n    <span class="hljs-keyword">let</span> extended_timestamp = <span class="hljs-keyword">if</span> timestamp &gt;= <span class="hljs-number">0x00ffffff</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span> {\n        <span class="hljs-keyword">let</span> extended_timestamp = <span class="hljs-literal">Some</span>(timestamp);\n\n        timestamp = <span class="hljs-number">0x00ffffff</span>;\n        extended_timestamp\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-literal">None</span>\n    };\n    <span class="hljs-keyword">let</span> message_header = <span class="hljs-keyword">match</span> message_header_format {\n        <span class="hljs-number">0</span> =&gt; MessageHeader {\n            timestamp,\n            message_length,\n            message_type,\n            message_id\n        },\n        <span class="hljs-number">1</span> =&gt; MessageHeader {\n            timestamp,\n            message_length,\n            message_type,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        <span class="hljs-number">2</span> =&gt; MessageHeader {\n            timestamp,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        <span class="hljs-number">3</span> =&gt; MessageHeader {\n            timestamp: <span class="hljs-literal">None</span>,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        <span class="hljs-comment">// 0 から 3 の間にない数値であった場合は強制的にプログラムを落とす. (必要な時は来ないとは思うが)</span>\n        n =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"what\'s this!?: {}"</span>, n)\n    };\n    <span class="hljs-keyword">let</span> chunk = Chunk {\n        basic_header,\n        message_header,\n        extended_timestamp,\n        data\n    };\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> v, chunk);\n    stream.write(v.as_slice()).map(|_| ())\n}\n</code></pre>\n<p>ここで, 各送信チャンクも同様に上記の手順を実行できるように, チャンクデータの種類別に送信関数を用意し, それらに <code>send_chunk</code> を呼ばせるようにする.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    collections::{\n        HashMap\n    },\n    io::{\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult,\n        Write\n    },\n    net::{\n        TcpStream\n    }\n};\n\n<span class="hljs-keyword">const</span> DEFAULT_CHUNK_SIZE: <span class="hljs-built_in">u32</span> = <span class="hljs-number">128</span>;\n<span class="hljs-keyword">const</span> DEFAULT_BANDWIDTH: <span class="hljs-built_in">u32</span> = <span class="hljs-number">3000000</span>;\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-keyword">impl</span> BasicHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header_format</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u8</span> {\n        <span class="hljs-keyword">self</span>.message_header_format\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_chunk_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u16</span> {\n        <span class="hljs-keyword">self</span>.chunk_id\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MessageHeader</span></span> {\n    timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_length: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_type: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt;,\n    message_id: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;\n}\n\n<span class="hljs-keyword">impl</span> MessageHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_timestamp</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, timestamp: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.timestamp = <span class="hljs-literal">Some</span>(timestamp);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_length</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_length\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_length</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_length: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.message_length = <span class="hljs-literal">Some</span>(message_length);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_type</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_type\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_type</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_type: <span class="hljs-built_in">u8</span>) {\n        <span class="hljs-keyword">self</span>.message_type = <span class="hljs-literal">Some</span>(message_type);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.mmessage_id\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_id</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_id: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.message_id = <span class="hljs-literal">Some</span>(message_id);\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PingData</span></span> {\n    StreamBegin(<span class="hljs-built_in">u32</span>)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    Null,\n    Unknown\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ConnectCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;,\n        information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ReleaseStreamCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        playpath: <span class="hljs-built_in">String</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>\n    }\n}\n\n<span class="hljs-keyword">impl</span> ReleaseStreamCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            ReleaseStreamCommand::Request {\n                transaction_id,\n                play_path: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">CreateStreamCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        message_id: <span class="hljs-built_in">f64</span>\n    }\n}\n\n<span class="hljs-keyword">impl</span> CreateStreamCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            CreateStreamCommand::Request {\n                transaction_id\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetConnectionCommand</span></span> {\n    Connect(ConnectCommand),\n    ReleaseStream(ReleaseStreamCommand),\n    CreateStream(CreateStreamCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FCPublishCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        playpath: <span class="hljs-built_in">String</span>\n    },\n    Response\n}\n\n<span class="hljs-keyword">impl</span> FCPublishCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            FCPublishCommand::Request {\n                transaction_id,\n                playpath: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InvokeCommand</span></span> {\n    NetConnection(NetConnectionCommand),\n    FCPublish(FCPublishCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    ChunkSize(<span class="hljs-built_in">u32</span>),\n    Ping(<span class="hljs-built_in">u16</span>, PingData),\n    ServerBandwidth(<span class="hljs-built_in">u32</span>),\n    ClientBandwidth(<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u8</span>),\n    Invoke(InvokeCommand),\n    Unknown(<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;)\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span></span> {\n    basic_header: BasicHeader,\n    message_header: MessageHeader,\n    extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    data: Data\n}\n\n<span class="hljs-keyword">impl</span> Chunk {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_basic_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; BasicHeader {\n        <span class="hljs-keyword">self</span>.basic_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; MessageHeader {\n        <span class="hljs-keyword">self</span>.message_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_extended_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.extended_timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_data</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Data {\n        &amp;<span class="hljs-keyword">self</span>.data\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_chunk</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, chunk_id: <span class="hljs-built_in">u16</span>, <span class="hljs-keyword">mut</span> timestamp: <span class="hljs-built_in">u32</span>, message_length: <span class="hljs-built_in">u32</span>, message_type: <span class="hljs-built_in">u8</span>, message_id: <span class="hljs-built_in">u32</span>, data: Data, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_message_header = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> last_message_header) = last_sent_chunks.get_mut(&amp;chunk_id) {\n        *last_message_header\n    } <span class="hljs-keyword">else</span> {\n        MessageHeader {\n            timestamp: <span class="hljs-literal">None</span>,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        }\n    };\n    <span class="hljs-keyword">let</span> last_timestamp = last_message_header.get_timestamp().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_length = last_message_header.get_message_length().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_type = last_message_header.get_message_type().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_id = last_message_header.get_message_id().unwrap_or_default();\n    <span class="hljs-keyword">let</span> message_header_format: <span class="hljs-built_in">u8</span> = <span class="hljs-keyword">if</span> message_id == last_message_id {\n        <span class="hljs-keyword">if</span> message_length == last_message_length &amp;&amp; message_type == last_message_type {\n            <span class="hljs-keyword">if</span> timestamp == last_timestamp {\n                <span class="hljs-number">3</span>\n            } <span class="hljs-keyword">else</span> {\n                <span class="hljs-number">2</span>\n            }\n        } <span class="hljs-keyword">else</span> {\n            <span class="hljs-number">1</span>\n        }\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-number">0</span>\n    };\n    <span class="hljs-keyword">let</span> basic_header = BasicHeader {\n        message_header_format,\n        chunk_id\n    };\n    <span class="hljs-keyword">let</span> extended_timestamp = <span class="hljs-keyword">if</span> timestamp &gt;= <span class="hljs-number">0x00ffffff</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span> {\n        <span class="hljs-keyword">let</span> extended_timestamp = <span class="hljs-literal">Some</span>(timestamp);\n\n        timestamp = <span class="hljs-number">0x00ffffff</span>;\n        extended_timestamp\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-literal">None</span>\n    };\n    <span class="hljs-keyword">let</span> message_header = <span class="hljs-keyword">match</span> message_header_format {\n        <span class="hljs-number">0</span> =&gt; MessageHeader {\n            timestamp,\n            message_length,\n            message_type,\n            message_id\n        },\n        <span class="hljs-number">1</span> =&gt; MessageHeader {\n            timestamp,\n            message_length,\n            message_type,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        <span class="hljs-number">2</span> =&gt; MessageHeader {\n            timestamp,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        <span class="hljs-number">3</span> =&gt; MessageHeader {\n            timestamp: <span class="hljs-literal">None</span>,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        n =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"what\'s this!?: {}"</span>, n)\n    };\n    <span class="hljs-keyword">let</span> chunk = Chunk {\n        basic_header,\n        message_header,\n        extended_timestamp,\n        data\n    };\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> v, chunk);\n    stream.write(v.as_slice()).map(|_| ())\n}\n\n<span class="hljs-comment">/* 送信時のタイムスタンプやメッセージストリーム ID の実際の渡し方については後述する. */</span>\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_chunk_size</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, chunk_size: <span class="hljs-built_in">u32</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-comment">// 仕様の範囲内であるかをチェック.</span>\n    <span class="hljs-keyword">if</span> chunk_size &lt; <span class="hljs-number">1</span> || chunk_size &gt; <span class="hljs-number">0x7fffffff</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidData.into());\n    }\n\n    send_chunk(stream, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, Data::ChunkSize(chunk_size), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_stream_begin</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    send_chunk(stream, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, Data::Ping(<span class="hljs-number">1</span>, PingData::StreamBegin(<span class="hljs-number">0</span>)), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_ping</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, ping_type: <span class="hljs-built_in">u16</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">match</span> ping_type {\n        <span class="hljs-number">1</span> =&gt; send_stream_begin(stream, last_sent_chunks),\n        n =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"what\'s this!?: {}"</span>, n)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_server_bandwidth</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, server_bandwidth: <span class="hljs-built_in">u32</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    send_chunk(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, Data::ServerBandwidth(server_bandwidth), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_client_bandwidth</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, client_bandwidth: <span class="hljs-built_in">u32</span>, limit: <span class="hljs-built_in">u8</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    send_chunk(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, Data::ClientBandwidth(client_bandwidth, limit), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_invoke</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, invoke_command: InvokeCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_data(&amp;<span class="hljs-keyword">mut</span> v, Data::Invoke(invoke_command.clone()));\n    send_chunk(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, v.len(), <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, Data::Invoke(invoke_command), last_sent_chunks)\n}\n</code></pre>\n<p>次に, 既存の関数内に書かれてある <code>stream.write()</code> を上記の関数に置き換えていく.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    collections::{\n        HashMap\n    },\n    io::{\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult,\n        Write\n    },\n    net::{\n        TcpStream\n    }\n};\n\n<span class="hljs-keyword">const</span> DEFAULT_CHUNK_SIZE: <span class="hljs-built_in">u32</span> = <span class="hljs-number">128</span>;\n<span class="hljs-keyword">const</span> DEFAULT_BANDWIDTH: <span class="hljs-built_in">u32</span> = <span class="hljs-number">3000000</span>;\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-keyword">impl</span> BasicHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header_format</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u8</span> {\n        <span class="hljs-keyword">self</span>.message_header_format\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_chunk_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u16</span> {\n        <span class="hljs-keyword">self</span>.chunk_id\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MessageHeader</span></span> {\n    timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_length: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_type: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt;,\n    message_id: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;\n}\n\n<span class="hljs-keyword">impl</span> MessageHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_timestamp</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, timestamp: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.timestamp = <span class="hljs-literal">Some</span>(timestamp);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_length</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_length\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_length</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_length: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.message_length = <span class="hljs-literal">Some</span>(message_length);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_type</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_type\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_type</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_type: <span class="hljs-built_in">u8</span>) {\n        <span class="hljs-keyword">self</span>.message_type = <span class="hljs-literal">Some</span>(message_type);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.mmessage_id\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_id</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_id: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.message_id = <span class="hljs-literal">Some</span>(message_id);\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PingData</span></span> {\n    StreamBegin(<span class="hljs-built_in">u32</span>)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    Null,\n    Unknown\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ConnectCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;,\n        information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ReleaseStreamCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        playpath: <span class="hljs-built_in">String</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>\n    }\n}\n\n<span class="hljs-keyword">impl</span> ReleaseStreamCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            ReleaseStreamCommand::Request {\n                transaction_id,\n                play_path: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">CreateStreamCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        message_id: <span class="hljs-built_in">f64</span>\n    }\n}\n\n<span class="hljs-keyword">impl</span> CreateStreamCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            CreateStreamCommand::Request {\n                transaction_id\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetConnectionCommand</span></span> {\n    Connect(ConnectCommand),\n    ReleaseStream(ReleaseStreamCommand),\n    CreateStream(CreateStreamCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FCPublishCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        playpath: <span class="hljs-built_in">String</span>\n    },\n    Response\n}\n\n<span class="hljs-keyword">impl</span> FCPublishCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            FCPublishCommand::Request {\n                transaction_id,\n                playpath: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InvokeCommand</span></span> {\n    NetConnection(NetConnectionCommand),\n    FCPublish(FCPublishCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    ChunkSize(<span class="hljs-built_in">u32</span>),\n    Ping(<span class="hljs-built_in">u16</span>, PingData),\n    ServerBandwidth(<span class="hljs-built_in">u32</span>),\n    ClientBandwidth(<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u8</span>),\n    Invoke(InvokeCommand),\n    Unknown(<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;)\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span></span> {\n    basic_header: BasicHeader,\n    message_header: MessageHeader,\n    extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    data: Data\n}\n\n<span class="hljs-keyword">impl</span> Chunk {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_basic_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; BasicHeader {\n        <span class="hljs-keyword">self</span>.basic_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; MessageHeader {\n        <span class="hljs-keyword">self</span>.message_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_extended_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.extended_timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_data</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Data {\n        &amp;<span class="hljs-keyword">self</span>.data\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_chunk</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, chunk_id: <span class="hljs-built_in">u16</span>, <span class="hljs-keyword">mut</span> timestamp: <span class="hljs-built_in">u32</span>, message_length: <span class="hljs-built_in">u32</span>, message_type: <span class="hljs-built_in">u8</span>, message_id: <span class="hljs-built_in">u32</span>, data: Data, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_message_header = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> last_message_header) = last_sent_chunks.get_mut(&amp;chunk_id) {\n        *last_message_header\n    } <span class="hljs-keyword">else</span> {\n        MessageHeader {\n            timestamp: <span class="hljs-literal">None</span>,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        }\n    };\n    <span class="hljs-keyword">let</span> last_timestamp = last_message_header.get_timestamp().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_length = last_message_header.get_message_length().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_type = last_message_header.get_message_type().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_id = last_message_header.get_message_id().unwrap_or_default();\n    <span class="hljs-keyword">let</span> message_header_format: <span class="hljs-built_in">u8</span> = <span class="hljs-keyword">if</span> message_id == last_message_id {\n        <span class="hljs-keyword">if</span> message_length == last_message_length &amp;&amp; message_type == last_message_type {\n            <span class="hljs-keyword">if</span> timestamp == last_timestamp {\n                <span class="hljs-number">3</span>\n            } <span class="hljs-keyword">else</span> {\n                <span class="hljs-number">2</span>\n            }\n        } <span class="hljs-keyword">else</span> {\n            <span class="hljs-number">1</span>\n        }\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-number">0</span>\n    };\n    <span class="hljs-keyword">let</span> basic_header = BasicHeader {\n        message_header_format,\n        chunk_id\n    };\n    <span class="hljs-keyword">let</span> extended_timestamp = <span class="hljs-keyword">if</span> timestamp &gt;= <span class="hljs-number">0x00ffffff</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span> {\n        <span class="hljs-keyword">let</span> extended_timestamp = <span class="hljs-literal">Some</span>(timestamp);\n\n        timestamp = <span class="hljs-number">0x00ffffff</span>;\n        extended_timestamp\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-literal">None</span>\n    };\n    <span class="hljs-keyword">let</span> message_header = <span class="hljs-keyword">match</span> message_header_format {\n        <span class="hljs-number">0</span> =&gt; MessageHeader {\n            timestamp,\n            message_length,\n            message_type,\n            message_id\n        },\n        <span class="hljs-number">1</span> =&gt; MessageHeader {\n            timestamp,\n            message_length,\n            message_type,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        <span class="hljs-number">2</span> =&gt; MessageHeader {\n            timestamp,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        <span class="hljs-number">3</span> =&gt; MessageHeader {\n            timestamp: <span class="hljs-literal">None</span>,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        n =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"what\'s this!?: {}"</span>, n)\n    };\n    <span class="hljs-keyword">let</span> chunk = Chunk {\n        basic_header,\n        message_header,\n        extended_timestamp,\n        data\n    };\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> v, chunk);\n    stream.write(v.as_slice()).map(|_| ())\n}\n\n<span class="hljs-comment">/* 送信時のタイムスタンプやメッセージストリーム ID の実際の渡し方については後述する. */</span>\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_chunk_size</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, chunk_size: <span class="hljs-built_in">u32</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">if</span> chunk_size &lt; <span class="hljs-number">1</span> || chunk_size &gt; <span class="hljs-number">0x7fffffff</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidData.into());\n    }\n\n    send_chunk(stream, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, Data::ChunkSize(chunk_size), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_stream_begin</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    send_chunk(stream, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, Data::Ping(<span class="hljs-number">1</span>, PingData::StreamBegin(<span class="hljs-number">0</span>)), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_ping</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, ping_type: <span class="hljs-built_in">u16</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">match</span> ping_type {\n        <span class="hljs-number">1</span> =&gt; send_stream_begin(stream, last_sent_chunks),\n        n =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"what\'s this!?: {}"</span>, n)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_server_bandwidth</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, server_bandwidth: <span class="hljs-built_in">u32</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    send_chunk(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, Data::ServerBandwidth(server_bandwidth), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_client_bandwidth</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, client_bandwidth: <span class="hljs-built_in">u32</span>, limit: <span class="hljs-built_in">u8</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    send_chunk(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, Data::ClientBandwidth(client_bandwidth, limit), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_invoke</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, invoke_command: InvokeCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_data(&amp;<span class="hljs-keyword">mut</span> v, Data::Invoke(invoke_command.clone()));\n    send_chunk(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, v.len(), <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, Data::Invoke(invoke_command), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_connect_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, connect_command: ConnectCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-comment">// 基本的に受信チャンクのトランザクション ID をコピーする.</span>\n    <span class="hljs-keyword">let</span> transaction_id = connect_command.get_received_transaction_id().unwrap();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n    properties.insert(<span class="hljs-string">"fmsVer"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"FMS/3,0,1,123"</span>.to_string()));\n    properties.insert(<span class="hljs-string">"capabilities"</span>.to_string(), AmfData::Number(<span class="hljs-number">31</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n    information.insert(<span class="hljs-string">"level"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"status"</span>.to_string()));\n    information.insert(<span class="hljs-string">"code"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"NetConnection.Connect.Success"</span>.to_string()));\n    information.insert(<span class="hljs-string">"description"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"Connection succeeded."</span>.to_string()));\n    information.insert(<span class="hljs-string">"objectEncoding"</span>.to_string(), AmfData::Number(<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::NetConnection(\n            NetConnectionCommand::Connect(\n                ConnectCommand::Response {\n                    transaction_id,\n                    properties,\n                    information\n                }\n            )\n        )\n    );\n\n    send_invoke(stream, invoke.clone(), last_sent_chunks)?;\n    send_server_bandwidth(stream, DEFAULT_BANDWIDTH, last_sent_chunks)?;\n    send_client_bandwidth(stream, DEFAULT_BANDWIDTH, last_sent_chunks)?;\n    send_ping(stream, <span class="hljs-number">1</span>, last_sent_chunks)?;\n    send_chunk_size(stream, DEFAULT_CHUNK_SIZE, last_sent_chunks)?;\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_release_stream_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, release_stream_command: ReleaseStreamCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-comment">// 同上.</span>\n    <span class="hljs-keyword">let</span> transaction_id = release_stream_command.get_received_trnasaction_id().unwrap();\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::NetConnection(\n            NetConnectionCommand::ReleaseStream(\n                ReleaseStreamCommand::Response {\n                    transaction_id\n                }\n            )\n        )\n    );\n\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_create_stream_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, create_stream_command: CreateStreamCommand, message_id: <span class="hljs-built_in">f64</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-comment">// 同上.</span>\n    <span class="hljs-keyword">let</span> transaction_id = create_stream_command.get_received_transaction_id().unwrap();\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::NetConnection(\n            NetConnectionCommand::CreateStream(\n                CreateStreamCommand::Response {\n                    transaction_id,\n                    message_id\n                }\n            )\n        )\n    );\n\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_net_connection_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, net_connection_command: NetConnectionCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">match</span> net_connection_command {\n        NetConnectionCommand::Connect(connect_command) =&gt; send_connect_response(stream, connect_command, last_sent_chunks),\n        NetConnectionCommand::ReleaseStream(release_stream_command) =&gt; send_release_stream_response(stream, release_stream_command, last_sent_chunks),\n        NetConnectionCommand::CreateStream(create_stream_command) =&gt; send_create_stream_command(stream, create_stream_command, last_sent_chunks)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_fc_publish_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, fc_publish_command: FCPublishCommand) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-comment">// 同上.</span>\n    <span class="hljs-keyword">let</span> transaction_id = fc_publish_command.get_received_transaction_id().unwrap();\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::FCPublish(\n            FCPublishCommand::Response\n        )\n    );\n\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_invoke_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, invoke_command: InvokeCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">match</span> invoke_command {\n        InvokeCommand::NetConnection(net_connection_command) =&gt; send_net_connection_response(stream, net_connection_command, last_sent_chunks),\n        InvokeCommand::FCPublish(fc_publish_command) =&gt; send_fc_publish_response(stream, fc_publish, last_sent_chunks)\n    }\n}\n</code></pre>\n<p>そして, 上記のコードを <code>main</code> および <code>receive_chunk</code> と合流させる. また, <code>decode_invoke</code> の変更を忘れていたため, 下記のコードにてそれも行う.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    collections::{\n        HashMap\n    },\n    io::{\n        Error <span class="hljs-keyword">as</span> IOError,\n        ErrorKind,\n        Read,\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult,\n        Write\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    }\n};\n\n<span class="hljs-keyword">const</span> DEFAULT_CHUNK_SIZE: <span class="hljs-built_in">u32</span> = <span class="hljs-number">128</span>;\n<span class="hljs-keyword">const</span> DEFAULT_BANDWIDTH: <span class="hljs-built_in">u32</span> = <span class="hljs-number">3000000</span>;\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-keyword">impl</span> BasicHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header_format</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u8</span> {\n        <span class="hljs-keyword">self</span>.message_header_format\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_chunk_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u16</span> {\n        <span class="hljs-keyword">self</span>.chunk_id\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MessageHeader</span></span> {\n    timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_length: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_type: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt;,\n    message_id: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;\n}\n\n<span class="hljs-keyword">impl</span> MessageHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_timestamp</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, timestamp: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.timestamp = <span class="hljs-literal">Some</span>(timestamp);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_length</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_length\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_length</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_length: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.message_length = <span class="hljs-literal">Some</span>(message_length);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_type</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_type\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_type</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_type: <span class="hljs-built_in">u8</span>) {\n        <span class="hljs-keyword">self</span>.message_type = <span class="hljs-literal">Some</span>(message_type);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.mmessage_id\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_id</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_id: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.message_id = <span class="hljs-literal">Some</span>(message_id);\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PingData</span></span> {\n    StreamBegin(<span class="hljs-built_in">u32</span>)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    Null,\n    Unknown\n}\n\n<span class="hljs-keyword">impl</span> AmfData {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">number</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {\n            AmfData::Number(number) =&gt; <span class="hljs-literal">Some</span>(number),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">boolean</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">bool</span>&gt; {\n        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {\n            AmfData::Boolean(boolean) =&gt; <span class="hljs-literal">Some</span>(boolean),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">string</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">String</span>&gt; {\n        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {\n            AmfData::<span class="hljs-built_in">String</span>(string) =&gt; <span class="hljs-literal">Some</span>(string),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">object</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;&gt; {\n        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {\n            AmfData::Object(object) =&gt; <span class="hljs-literal">Some</span>(object),\n            _ =&gt; <span class="hljs-literal">None</span>\n        } \n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ConnectCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;,\n        information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ReleaseStreamCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        playpath: <span class="hljs-built_in">String</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>\n    }\n}\n\n<span class="hljs-keyword">impl</span> ReleaseStreamCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            ReleaseStreamCommand::Request {\n                transaction_id,\n                play_path: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">CreateStreamCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        message_id: <span class="hljs-built_in">f64</span>\n    }\n}\n\n<span class="hljs-keyword">impl</span> CreateStreamCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            CreateStreamCommand::Request {\n                transaction_id\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetConnectionCommand</span></span> {\n    Connect(ConnectCommand),\n    ReleaseStream(ReleaseStreamCommand),\n    CreateStream(CreateStreamCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FCPublishCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        playpath: <span class="hljs-built_in">String</span>\n    },\n    Response\n}\n\n<span class="hljs-keyword">impl</span> FCPublishCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            FCPublishCommand::Request {\n                transaction_id,\n                playpath: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InvokeCommand</span></span> {\n    NetConnection(NetConnectionCommand),\n    FCPublish(FCPublishCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    ChunkSize(<span class="hljs-built_in">u32</span>),\n    Ping(<span class="hljs-built_in">u16</span>, PingData),\n    ServerBandwidth(<span class="hljs-built_in">u32</span>),\n    ClientBandwidth(<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u8</span>),\n    Invoke(InvokeCommand),\n    Unknown(<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;)\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span></span> {\n    basic_header: BasicHeader,\n    message_header: MessageHeader,\n    extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    data: Data\n}\n\n<span class="hljs-keyword">impl</span> Chunk {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_basic_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; BasicHeader {\n        <span class="hljs-keyword">self</span>.basic_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; MessageHeader {\n        <span class="hljs-keyword">self</span>.message_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_extended_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.extended_timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_data</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Data {\n        &amp;<span class="hljs-keyword">self</span>.data\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_number</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> number_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">8</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">8</span>];\n\n    number_bytes.copy_from_slice(&amp;data[*offset..(*offset + <span class="hljs-number">8</span>)]);\n    *offset += <span class="hljs-number">8</span>;\n\n    <span class="hljs-keyword">let</span> number = <span class="hljs-built_in">f64</span>::from_bits(<span class="hljs-built_in">u64</span>::from_be_bytes(number_bytes));\n\n    <span class="hljs-literal">Ok</span>(AmfData::Number(number))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_boolean</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> boolean = data[*offset] &gt; <span class="hljs-number">0</span>;\n\n    *offset += <span class="hljs-number">1</span>;\n    <span class="hljs-literal">Ok</span>(AmfData::Boolean(boolean))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_string</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">2</span>];\n\n    length_bytes.copy_from_slice(&amp;data[*offset..(*offset + <span class="hljs-number">2</span>)]);\n    *offset += <span class="hljs-number">2</span>;\n\n    <span class="hljs-keyword">let</span> string = <span class="hljs-built_in">String</span>::from_utf8(data[*offset..(*offset + length)].to_vec()).map_err(\n        |_| IOError::from(ErrorKind::InvalidData)\n    )?;\n\n    *offset += length;\n    <span class="hljs-literal">Ok</span>(AmfData::<span class="hljs-built_in">String</span>(string))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_object</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n    <span class="hljs-keyword">while</span> &amp;data[*offset..(*offset + <span class="hljs-number">3</span>)] != &amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>] {\n        <span class="hljs-keyword">let</span> name = decode_amf_string(data, offset)?.string().unwrap();\n        <span class="hljs-keyword">let</span> value = decode_amf_data(data, offset)?;\n\n        object.insert(name, value);\n    }\n\n    <span class="hljs-literal">Ok</span>(AmfData::Object(object))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_null</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-literal">Ok</span>(AmfData::Null)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_unknown</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-comment">/* 当該部分の実装は後述する. */</span>\n    <span class="hljs-literal">Ok</span>(AmfData::Unknown)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_data</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">match</span> data[*offset] {\n        <span class="hljs-number">0</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_number(data, offset)\n        },\n        <span class="hljs-number">1</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_boolean(data, offset)\n        },\n        <span class="hljs-number">2</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_string(data, offset)\n        },\n        <span class="hljs-number">3</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_object(data, offset)\n        },\n        <span class="hljs-number">5</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_null(data, offset)\n        },\n        _ =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_unknown()\n        }\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_basic_header</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream) -&gt; IOResult&lt;BasicHeader&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> first_byte: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n    stream.read(&amp;<span class="hljs-keyword">mut</span> first_byte)?;\n\n    <span class="hljs-keyword">let</span> message_header_format = (first_byte[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0xc0</span>) &gt;&gt; <span class="hljs-number">6</span>;\n    <span class="hljs-keyword">let</span> chunk_id = <span class="hljs-keyword">match</span> first_byte[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x3f</span> {\n        <span class="hljs-number">0</span> =&gt; {\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> chunk_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n            stream.read(&amp;<span class="hljs-keyword">mut</span> chunk_id_bytes)?;\n            (<span class="hljs-built_in">u8</span>::from_be_bytes(chunk_id_bytes) + <span class="hljs-number">64</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>\n        },\n        <span class="hljs-number">1</span> =&gt; {\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> chunk_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">2</span>];\n\n            stream.read(&amp;<span class="hljs-keyword">mut</span> chunk_id_bytes)?;\n            <span class="hljs-built_in">u16</span>::from_le_bytes(chunk_id_bytes) + <span class="hljs-number">64</span>\n        },\n        n =&gt; n\n    };\n\n    <span class="hljs-literal">Ok</span>(\n        BasicHeader {\n            message_header_format,\n            chunk_id\n        }\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_message_header</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, message_header_format: <span class="hljs-built_in">u8</span>) -&gt; IOResult&lt;MessageHeader&gt; {\n    <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">0</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_type_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_length_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_type_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_id_bytes)?;\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n        message_length_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;message_length_bytes);\n\n        <span class="hljs-keyword">let</span> timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n        <span class="hljs-keyword">let</span> message_length = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(message_length_tmp));\n        <span class="hljs-keyword">let</span> message_type = <span class="hljs-literal">Some</span>(message_type_bytes[<span class="hljs-number">0</span>]);\n        <span class="hljs-keyword">let</span> message_id = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_le_bytes(message_id_bytes));\n\n        <span class="hljs-literal">Ok</span>(\n            MessageHeader {\n                timestamp,\n                message_length,\n                message_type,\n                message_id\n            }\n        )\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">1</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_type_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_length_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_type_bytes)?;\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n        message_length_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;message_length_bytes);\n\n        <span class="hljs-keyword">let</span> timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n        <span class="hljs-keyword">let</span> message_length = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(message_length_tmp));\n        <span class="hljs-keyword">let</span> message_type = <span class="hljs-literal">Some</span>(message_type_bytes[<span class="hljs-number">0</span>]);\n\n        <span class="hljs-literal">Ok</span>(\n            MessageHeader {\n                timestamp,\n                message_length,\n                message_type,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        )\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">2</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n\n        <span class="hljs-keyword">let</span> timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n\n        <span class="hljs-literal">Ok</span>(\n            MessageHeader {\n                timestamp,\n                message_length: <span class="hljs-literal">None</span>,\n                message_type: <span class="hljs-literal">None</span>,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        )\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-literal">Ok</span>(\n            MessageHeader {\n                timestamp: <span class="hljs-literal">None</span>,\n                message_length: <span class="hljs-literal">None</span>,\n                message_type: <span class="hljs-literal">None</span>,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        )\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_extended_timestamp</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, timestamp: <span class="hljs-built_in">u32</span>) -&gt; IOResult&lt;<span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;&gt; {\n    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0x00ffffff</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> extended_timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> extended_timestamp_bytes)?;\n        <span class="hljs-literal">Ok</span>(<span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(extended_timestamp_bytes)))\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-literal">Ok</span>(<span class="hljs-literal">None</span>)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_connect</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = decode_amf_data(data, offset)?.number().unwrap();\n    <span class="hljs-keyword">let</span> command_object = decode_amf_data(data, offset)?.object().unwrap();\n\n    <span class="hljs-literal">Ok</span>(\n        Data::Invoke(\n            InvokeCommand::NetConnection(\n                NetConnectionCommand::Connect(\n                    ConnectCommand::Request {\n                        transaction_id,\n                        command_object\n                    }\n                )\n            )\n        )\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_release_stream</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = decode_amf_data(data, offset)?.number().unwrap();\n\n    <span class="hljs-comment">// ほぼ間違いなく Null が先に続くので, それを読み飛ばす.</span>\n    decode_amf_data(data, offset)?;\n\n    <span class="hljs-keyword">let</span> playpath = decode_amf_data(data, offset)?.string().unwrap();\n\n    <span class="hljs-literal">Ok</span>(\n        Data::Invoke(\n            InvokeCommand::NetConnection(\n                NetConnectionCommand::ReleaseStream(\n                    ReleaseStreamCommand::Request {\n                        transaction_id,\n                        playpath\n                    }\n                )\n            )\n        )\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_fc_publish</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = decode_amf_data(data, offset)?.number().unwrap();\n\n    <span class="hljs-comment">// 同上.</span>\n    decode_amf_data(data, offset)?;\n\n    <span class="hljs-keyword">let</span> playpath = decode_amf_data(data, offset)?.string().unwrap();\n\n    <span class="hljs-literal">Ok</span>(\n        Data::Invoke(\n            InvokeCommand::FCPublish(\n                FCPublishCommand::Request {\n                    transaction_id,\n                    playpath\n                }\n            )\n        )\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_create_stream</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = decode_amf_data(data, offset)?.number().unwrap();\n\n    <span class="hljs-comment">// 同上.</span>\n    decode_amf_data(data, offset)?;\n\n    <span class="hljs-literal">Ok</span>(\n        Data::Invoke(\n            InvokeCommand::NetConnection(\n                NetConnectionCommand::CreateStream(\n                    CreateStreamCommand::Request {\n                        transaction_id\n                    }\n                )\n            )\n        )\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_invoke</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset = <span class="hljs-built_in">usize</span>::default();\n    <span class="hljs-keyword">let</span> command_name = decode_amf_data(data, &amp;<span class="hljs-keyword">mut</span> offset)?.string().unwrap();\n\n    <span class="hljs-keyword">if</span> command_name == <span class="hljs-string">"connect"</span> {\n        decode_connect(data, &amp;<span class="hljs-keyword">mut</span> offset)\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> command_name == <span class="hljs-string">"releaseStream"</span> {\n        decode_release_stream(data, &amp;<span class="hljs-keyword">mut</span> offset)\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> command_name == <span class="hljs-string">"FCPublish"</span> {\n        decode_fc_publish(data, &amp;<span class="hljs-keyword">mut</span> offset)\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> command_name == <span class="hljs-string">"createStream"</span> {\n        decode_create_stream(data, &amp;<span class="hljs-keyword">mut</span> offset)\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"unknown command!: {}"</span>, command_name)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_data</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, message_type: <span class="hljs-built_in">u8</span>, message_length: <span class="hljs-built_in">u32</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> splits = <span class="hljs-keyword">if</span> message_length &lt;= DEFAULT_CHUNK_SIZE {\n        <span class="hljs-number">0</span>\n    } <span class="hljs-keyword">else</span> {\n        message_length / DEFAULT_CHUNK_SIZE + (message_length % DEFAULT_CHUNK_SIZE &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>\n    };\n    <span class="hljs-keyword">let</span> actual_message_length = (message_length + splits) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::with_capacity(actual_message_length);\n\n    <span class="hljs-keyword">unsafe</span> {\n        data_bytes.set_len(actual_message_length);\n    }\n\n    stream.read(data_bytes.as_mut_slice())?;\n\n    <span class="hljs-keyword">if</span> splits &gt; <span class="hljs-number">0</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> split_data: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..splits {\n            <span class="hljs-keyword">let</span> start = <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> {\n                (DEFAULT_CHUNK_SIZE * i) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>\n            } <span class="hljs-keyword">else</span> {\n                (DEFAULT_CHUNK_SIZE * i + <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n            };\n            <span class="hljs-keyword">let</span> end = start + DEFAULT_CHUNK_SIZE <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n\n            split_data.extend_from_slice(&amp;data_bytes[start..end]);\n        }\n\n        data_bytes = split_data;\n    }\n\n    <span class="hljs-keyword">match</span> message_type {\n        <span class="hljs-number">20</span> =&gt; decode_invoke(data_bytes),\n        _ =&gt; <span class="hljs-literal">Ok</span>(Data::Unknown(data_bytes))\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_chunk</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, last_received_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;Chunk&gt; {\n    <span class="hljs-keyword">let</span> basic_header = receive_basic_header(stream)?;\n    <span class="hljs-keyword">let</span> chunk_id = basic_header.get_chunk_id();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_message_header = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span> (<span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> last_message_header) = last_received_chunks.get_mut(&amp;chunk_id) {\n        *last_message_header\n    } <span class="hljs-keyword">else</span> {\n        MessageHeader {\n            timestamp: <span class="hljs-literal">None</span>,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        }\n    };\n    <span class="hljs-keyword">let</span> received_message_header = receive_message_header(stream, basic_header.get_message_header_format())?;\n    <span class="hljs-keyword">let</span> timestamp = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(timestamp) = received_message_header.get_timestamp() {\n        timestamp\n    } <span class="hljs-keyword">else</span> {\n        last_message_header.get_timestamp().unwrap()\n    };\n    <span class="hljs-keyword">let</span> message_length = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = received_message_header.get_message_length() {\n        message_length\n    } <span class="hljs-keyword">else</span> {\n        last_message_header.unwrap().get_message_length().unwrap()\n    };\n    <span class="hljs-keyword">let</span> message_type = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_type) = received_message_header.get_message_type() {\n        message_type\n    } <span class="hljs-keyword">else</span> {\n        last_message_header.get_message_type().unwrap()\n    };\n    <span class="hljs-keyword">let</span> message_id = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_id) = received_message_header.get_message_id() {\n        message_id\n    } <span class="hljs-keyword">else</span> {\n        last_message_header.get_message_id().unwrap()\n    };\n    <span class="hljs-keyword">let</span> extended_timestamp = receive_extended_timestamp(stream, timestamp)?;\n    <span class="hljs-keyword">let</span> data = receive_data(stream, message_type, message_length)?;\n\n    last_message_header.set_timestamp(timestamp);\n    last_message_header.set_message_length(message_length);\n    last_message_header.set_message_type(message_type);\n    last_message_header.set_message_id(message_id);\n    last_received_chunks.insert(chunk_id, last_message_header);\n\n    <span class="hljs-literal">Ok</span>(\n        Chunk {\n            basic_header,\n            message_header,\n            extended_timestamp,\n            data\n        }\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_basic_header</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, basic_header: BasicHeader) {\n    <span class="hljs-keyword">let</span> message_header_format = basic_header.get_message_header_format();\n    <span class="hljs-keyword">let</span> chunk_id = basic_header.get_chunk_id();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> second_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> first_byte = <span class="hljs-keyword">if</span> chunk_id &gt; <span class="hljs-number">319</span> {\n        second_bytes.extend_from_slice(&amp;chunk_id.to_le_bytes());\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | <span class="hljs-number">1</span>\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> chunk_id &gt; <span class="hljs-number">63</span> {\n        second_bytes.push(chunk_id <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | <span class="hljs-number">0</span>\n    } <span class="hljs-keyword">else</span> {\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | chunk_id\n    };\n\n    v.push(first_byte);\n    v.append(&amp;<span class="hljs-keyword">mut</span> second_bytes);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_message_header</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, message_header: MessageHeader) {\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(timestamp) = message_header.get_timestamp() {\n        v.extend_from_slice(&amp;timestamp.to_be_bytes()[<span class="hljs-number">1</span>..]);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = message_header.get_message_length() {\n        v.extend_from_slice(&amp;message_length.to_be_bytes()[<span class="hljs-number">1</span>..]);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_type) = message_header.get_message_type() {\n        v.push(message_type);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> some(message_id) = message_header.get_message_id() {\n        v.extend_from_slice(&amp;message_id.to_le_bytes());\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_extended_timestamp</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;) {\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(extended_timestamp) = extended_timestamp {\n        v.extend_from_slice(&amp;extended_timestamp.to_be_bytes());\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_chunk_size</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, chunk_size: <span class="hljs-built_in">u32</span>) {\n    v.extend_from_slice(&amp;chunk_size.to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_ping</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, ping_type: <span class="hljs-built_in">u16</span>, ping_data: PingData) {\n    v.extend_from_slice(&amp;ping_type.to_be_bytes());\n\n    <span class="hljs-keyword">match</span> ping_data {\n        PingData::StreamBegin(message_id) =&gt; v.extend_from_slice(&amp;message_id.to_be_bytes())\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_server_bandwidth</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, server_bandwidth: <span class="hljs-built_in">u32</span>) {\n    v.extend_from_slice(&amp;server_bandwidth.to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_client_bandwidth</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, client_bandwidth: <span class="hljs-built_in">u32</span>, limit: <span class="hljs-built_in">u8</span>) {\n    v.extend_from_slice(&amp;client_bandwidth.to_be_bytes());\n    v.push(limit);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_number</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, number: <span class="hljs-built_in">f64</span>) {\n    v.push(<span class="hljs-number">0</span>);\n    v.extend_from_slice(&amp;number.to_bits().to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_boolean</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, boolean: <span class="hljs-built_in">bool</span>) {\n    v.push(<span class="hljs-number">1</span>);\n    v.push(boolean <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_string</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, <span class="hljs-keyword">mut</span> string: <span class="hljs-built_in">String</span>) {\n    v.push(<span class="hljs-number">2</span>);\n    v.extend_from_slice(&amp;(string.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n    v.append(string.as_mut_vec());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_object</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;) {\n    v.push(<span class="hljs-number">3</span>);\n\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">mut</span> name, value) <span class="hljs-keyword">in</span> object {\n        v.extend_from_slice(&amp;(name.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n        v.append(name.as_mut_vec());\n        encode_amf_data(v, value);\n    }\n\n    v.extend_from_slice(&amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>]);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_null</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;) {\n    v.push(<span class="hljs-number">5</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_data</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, data: AmfData) {\n    <span class="hljs-keyword">match</span> data {\n        AmfData::Number(number) =&gt; encode_amf_number(v, number),\n        AmfData::Boolean(boolean) =&gt; encode_amf_boolean(v, boolean),\n        AmfData::<span class="hljs-built_in">String</span>(string) =&gt; encode_amf_string(v, string),\n        AmfData::Object(object) =&gt; encode_amf_object(v, object),\n        AmfData::Null =&gt; encode_amf_null(v),\n        <span class="hljs-comment">// まだ上記以外の AMF 型のデータを特定できていないため, 現段階では無視することとする.</span>\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_connect</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, connect_command: ConnectCommand) {\n    <span class="hljs-keyword">match</span> connect_command {\n        Connect::Response {\n            transaction_id,\n            properties,\n            information\n        } =&gt; {\n            encode_amf_string(v, <span class="hljs-string">"_result"</span>.to_string());\n            encode_amf_number(v, transaction_id);\n            encode_amf_object(v, properties);\n            encode_amf_object(v, information);\n        },\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_release_stream</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, release_stream_command: ReleaseStreamCommand) {\n    <span class="hljs-keyword">match</span> release_stream_command {\n        ReleaseStreamCommand::Response {\n            transaction_id\n        } =&gt; {\n            encode_amf_string(v, <span class="hljs-string">"_result"</span>.to_string());\n            encode_amf_number(v, transaction_id);\n            encode_amf_null(v);\n        },\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_create_stream</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, create_stream_command: CreateStreamCommand) {\n    <span class="hljs-keyword">match</span> create_stream_command {\n        CreateStreamCommand::Response {\n            transaction_id,\n            message_id\n        } =&gt; {\n            encode_amf_string(v, <span class="hljs-string">"_result"</span>.to_string);\n            encode_amf_number(v, transaction_id);\n            encode_amf_null(v);\n            encode_amf_number(v, message_id);\n        },\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_net_connection</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, net_connection_command: NetConnectionCommand) {\n    <span class="hljs-keyword">match</span> net_connection_command {\n        Connect(connect_command) =&gt; encode_connect(v, connect_command),\n        ReleaseStream(release_stream_command) =&gt; encode_release_stream(v, release_stream_command),\n        CreateStream(create_stream_command) =&gt; encode_create_stream(v, create_stream_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_fc_publish</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, fc_publish_command: FCPublishCommand) {\n    <span class="hljs-keyword">match</span> fc_publish_command {\n        FCPublishCommand::Response =&gt; encode_amf_string(v, <span class="hljs-string">"onFCPublish"</span>.to_string()),\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_invoke</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, invoke_command: InvokeCommand) {\n    <span class="hljs-keyword">match</span> invoke_command {\n        InvokeCommand::NetConnection(net_connection_command) =&gt; encode_net_connection(v, net_connection_command),\n        InvokeCommand::FCPublish(fc_publish_command) =&gt; encode_fc_publish(v, fc_publish_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_data</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, data: Data) {\n    <span class="hljs-keyword">match</span> data {\n        Data::ChunkSize(chunk_size) =&gt; encode_chunk_size(v, chunk_size),\n        Data::Ping(ping_type, ping_data) =&gt; encode_ping(v, ping_type, ping_data),\n        Data::ServerBandwidth(server_bandwidth) =&gt; encode_server_bandwidth(v, server_bandwidth),\n        Data::ClientBandwidth(client_bandwidth, limit) =&gt; encode_client_bandwidth(v, client_bandwidth, limit),\n        Data::Invoke(invoke_command) =&gt; encode_invoke(v, invoke_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_chunk</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, chunk: Chunk) {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_data(&amp;<span class="hljs-keyword">mut</span> data_bytes, chunk.get_data().clone());\n\n    <span class="hljs-keyword">let</span> message_length = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = chunk.get_message_header().get_message_length() {\n        message_length\n    } <span class="hljs-keyword">else</span> {\n        data_bytes.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>\n    };\n    <span class="hljs-keyword">let</span> splits = <span class="hljs-keyword">if</span> message_length &lt;= DEFAULT_CHUNK_SIZE {\n        <span class="hljs-number">0</span>\n    } <span class="hljs-keyword">else</span> {\n        message_length / DEFAULT_CHUNK_SIZE + (message_length % DEFAULT_CHUNK != <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>\n    };\n\n    <span class="hljs-keyword">if</span> splits &gt; <span class="hljs-number">0</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> added: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n        <span class="hljs-keyword">let</span> basic_header = BasicHeader {\n            message_header_format: <span class="hljs-number">3</span>,\n            chunk_id: chunk.get_basic_header().get_chunk_id()\n        };\n\n        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..splits {\n            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> {\n                encode_basic_header(&amp;<span class="hljs-keyword">mut</span> added, basic_header);\n            }\n\n            <span class="hljs-keyword">let</span> start = (DEFAULT_CHUNK_SIZE * i) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n            <span class="hljs-keyword">let</span> end = start + min(DEFAULT_CHUNK_SIZE, data_bytes[start..].len());\n\n            added.extend_from_slice(&amp;data_bytes[start..end]);\n        }\n\n        data_bytes = added;\n    }\n\n    encode_basic_header(v, chunk.get_basic_header());\n    encode_message_header(\n        v,\n        MessageHeader {\n            message_length,\n            ..chunk.get_message_header()\n        }\n    );\n    encode_extended_timestamp(v, chunk.get_extended_timestamp());\n    v.append(&amp;<span class="hljs-keyword">mut</span> data_bytes);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_chunk</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, chunk_id: <span class="hljs-built_in">u16</span>, <span class="hljs-keyword">mut</span> timestamp: <span class="hljs-built_in">u32</span>, message_length: <span class="hljs-built_in">u32</span>, message_type: <span class="hljs-built_in">u8</span>, message_id: <span class="hljs-built_in">u32</span>, data: Data, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_message_header = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> last_message_header) = last_sent_chunks.get_mut(&amp;chunk_id) {\n        *last_message_header\n    } <span class="hljs-keyword">else</span> {\n        MessageHeader {\n            timestamp: <span class="hljs-literal">None</span>,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        }\n    };\n    <span class="hljs-keyword">let</span> last_timestamp = last_message_header.get_timestamp().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_length = last_message_header.get_message_length().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_type = last_message_header.get_message_type().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_id = last_message_header.get_message_id().unwrap_or_default();\n    <span class="hljs-keyword">let</span> message_header_format: <span class="hljs-built_in">u8</span> = <span class="hljs-keyword">if</span> message_id == last_message_id {\n        <span class="hljs-keyword">if</span> message_length == last_message_length &amp;&amp; message_type == last_message_type {\n            <span class="hljs-keyword">if</span> timestamp == last_timestamp {\n                <span class="hljs-number">3</span>\n            } <span class="hljs-keyword">else</span> {\n                <span class="hljs-number">2</span>\n            }\n        } <span class="hljs-keyword">else</span> {\n            <span class="hljs-number">1</span>\n        }\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-number">0</span>\n    };\n    <span class="hljs-keyword">let</span> basic_header = BasicHeader {\n        message_header_format,\n        chunk_id\n    };\n    <span class="hljs-keyword">let</span> extended_timestamp = <span class="hljs-keyword">if</span> timestamp &gt;= <span class="hljs-number">0x00ffffff</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span> {\n        <span class="hljs-keyword">let</span> extended_timestamp = <span class="hljs-literal">Some</span>(timestamp);\n\n        timestamp = <span class="hljs-number">0x00ffffff</span>;\n        extended_timestamp\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-literal">None</span>\n    };\n    <span class="hljs-keyword">let</span> message_header = <span class="hljs-keyword">match</span> message_header_format {\n        <span class="hljs-number">0</span> =&gt; MessageHeader {\n            timestamp,\n            message_length,\n            message_type,\n            message_id\n        },\n        <span class="hljs-number">1</span> =&gt; MessageHeader {\n            timestamp,\n            message_length,\n            message_type,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        <span class="hljs-number">2</span> =&gt; MessageHeader {\n            timestamp,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        <span class="hljs-number">3</span> =&gt; MessageHeader {\n            timestamp: <span class="hljs-literal">None</span>,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        n =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"what\'s this!?: {}"</span>, n)\n    };\n    <span class="hljs-keyword">let</span> chunk = Chunk {\n        basic_header,\n        message_header,\n        extended_timestamp,\n        data\n    };\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> v, chunk);\n    stream.write(v.as_slice()).map(|_| ())\n}\n\n<span class="hljs-comment">/* 送信時のタイムスタンプやメッセージストリーム ID の実際の渡し方については後述する. */</span>\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_chunk_size</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, chunk_size: <span class="hljs-built_in">u32</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">if</span> chunk_size &lt; <span class="hljs-number">1</span> || chunk_size &gt; <span class="hljs-number">0x7fffffff</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidData.into());\n    }\n\n    send_chunk(stream, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, Data::ChunkSize(chunk_size), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_stream_begin</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    send_chunk(stream, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, Data::Ping(<span class="hljs-number">1</span>, PingData::StreamBegin(<span class="hljs-number">0</span>)), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_ping</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, ping_type: <span class="hljs-built_in">u16</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">match</span> ping_type {\n        <span class="hljs-number">1</span> =&gt; send_stream_begin(stream, last_sent_chunks),\n        n =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"what\'s this!?: {}"</span>, n)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_server_bandwidth</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, server_bandwidth: <span class="hljs-built_in">u32</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    send_chunk(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, Data::ServerBandwidth(server_bandwidth), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_client_bandwidth</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, client_bandwidth: <span class="hljs-built_in">u32</span>, limit: <span class="hljs-built_in">u8</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    send_chunk(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, Data::ClientBandwidth(client_bandwidth, limit), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_invoke</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, invoke_command: InvokeCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_data(&amp;<span class="hljs-keyword">mut</span> v, Data::Invoke(invoke_command.clone()));\n    send_chunk(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, v.len(), <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, Data::Invoke(invoke_command), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_connect_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, connect_command: ConnectCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = connect_command.get_received_transaction_id().unwrap();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n    properties.insert(<span class="hljs-string">"fmsVer"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"FMS/3,0,1,123"</span>.to_string()));\n    properties.insert(<span class="hljs-string">"capabilities"</span>.to_string(), AmfData::Number(<span class="hljs-number">31</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n    information.insert(<span class="hljs-string">"level"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"status"</span>.to_string()));\n    information.insert(<span class="hljs-string">"code"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"NetConnection.Connect.Success"</span>.to_string()));\n    information.insert(<span class="hljs-string">"description"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"Connection succeeded."</span>.to_string()));\n    information.insert(<span class="hljs-string">"objectEncoding"</span>.to_string(), AmfData::Number(<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::NetConnection(\n            NetConnectionCommand::Connect(\n                ConnectCommand::Response {\n                    transaction_id,\n                    properties,\n                    information\n                }\n            )\n        )\n    );\n\n    send_invoke(stream, invoke.clone(), last_sent_chunks)?;\n    send_server_bandwidth(stream, DEFAULT_BANDWIDTH, last_sent_chunks)?;\n    send_client_bandwidth(stream, DEFAULT_BANDWIDTH, last_sent_chunks)?;\n    send_ping(stream, <span class="hljs-number">1</span>, last_sent_chunks)?;\n    send_chunk_size(stream, DEFAULT_CHUNK_SIZE, last_sent_chunks)?;\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_release_stream_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, release_stream_command: ReleaseStreamCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = release_stream_command.get_received_trnasaction_id().unwrap();\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::NetConnection(\n            NetConnectionCommand::ReleaseStream(\n                ReleaseStreamCommand::Response {\n                    transaction_id\n                }\n            )\n        )\n    );\n\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_create_stream_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, create_stream_command: CreateStreamCommand, message_id: <span class="hljs-built_in">f64</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = create_stream_command.get_received_transaction_id().unwrap();\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::NetConnection(\n            NetConnectionCommand::CreateStream(\n                CreateStreamCommand::Response {\n                    transaction_id,\n                    message_id\n                }\n            )\n        )\n    );\n\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_net_connection_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, net_connection_command: NetConnectionCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">match</span> net_connection_command {\n        NetConnectionCommand::Connect(connect_command) =&gt; send_connect_response(stream, connect_command, last_sent_chunks),\n        NetConnectionCommand::ReleaseStream(release_stream_command) =&gt; send_release_stream_response(stream, release_stream_command, last_sent_chunks),\n        NetConnectionCommand::CreateStream(create_stream_command) =&gt; send_create_stream_command(stream, create_stream_command, last_sent_chunks)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_fc_publish_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, fc_publish_command: FCPublishCommand) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = fc_publish_command.get_received_transaction_id().unwrap();\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::FCPublish(\n            FCPublishCommand::Response\n        )\n    );\n\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_invoke_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, invoke_command: InvokeCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">match</span> invoke_command {\n        InvokeCommand::NetConnection(net_connection_command) =&gt; send_net_connection_response(stream, net_connection_command, last_sent_chunks),\n        InvokeCommand::FCPublish(fc_publish_command) =&gt; send_fc_publish_response(stream, fc_publish, last_sent_chunks)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener: TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_received_chunks: HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt; = HashMap::new();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_sent_chunks: HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt; = HashMap::new();\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n\n        <span class="hljs-comment">/* connect コマンドへの返送までは完了しているとみなす. */</span>\n\n        <span class="hljs-comment">// 以降は要求チャンクの受信とそれらへの返送の連続であるため, loop でストリームを維持する.</span>\n        <span class="hljs-keyword">loop</span> {\n            <span class="hljs-keyword">let</span> received_chunk = receive_chunk(&amp;<span class="hljs-keyword">mut</span> stream, &amp;<span class="hljs-keyword">mut</span> last_received_chunks)?;\n\n            <span class="hljs-keyword">match</span> received_chunk.get_data().clone() {\n                Data::Invoke(invoke_command) =&gt; send_invoke_response(&amp;<span class="hljs-keyword">mut</span> stream, invoke_command, &amp;<span class="hljs-keyword">mut</span> last_sent_chunks)?,\n                _ =&gt; {}\n            }\n        }\n    }\n}\n</code></pre>\n<p>上記の実装で一つもエラーが発生しなければ, 送受信するチャンクを記憶しながら releaseStream, FCPublish, createStream (および connect) コマンドを返送する処理は完了である.</p>\n<h3 id="publish"><a class="header-anchor" href="#publish">¶</a> publish</h3>\n<p>NetConnection コマンド (connect, releaseStream, createStream) および FCPublish コマンドの送受信が完了すると, 次にサーバ側はクライアント側から publish コマンドを受信する. ここで, publish コマンドに入力されている値を以下に記す. 公式ドキュメント<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>では以下のように指定されている.</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">コマンド名</th>\n<th style="text-align:right">チャンクストリーム ID</th>\n<th style="text-align:right">タイムスタンプ</th>\n<th style="text-align:right">メッセージ長</th>\n<th style="text-align:right">メッセージの種類</th>\n<th style="text-align:right">メッセージストリーム ID</th>\n<th style="text-align:left">チャンクデータ</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left">\n<p>publish</p>\n</td>\n<td style="text-align:right">\n<p>3</p>\n</td>\n<td style="text-align:right">\n<p>0</p>\n</td>\n<td style="text-align:right">\n<p>?</p>\n</td>\n<td style="text-align:right">\n<p>20</p>\n</td>\n<td style="text-align:right">\n<p>0</p>\n</td>\n<td style="text-align:left">\n<ul>\n<li>コマンド名: publish</li>\n<li>トランザクションID: 0</li>\n<li>コマンドオブジェクト: Null</li>\n<li>公開名 (何らかの文字列)</li>\n<li>公開の種類: live, record, append のいずれか</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n<p>一方で, FFmpeg では以下のように入力されている.</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">コマンド名</th>\n<th style="text-align:right">チャンクストリーム ID</th>\n<th style="text-align:right">タイムスタンプ</th>\n<th style="text-align:right">メッセージ長</th>\n<th style="text-align:right">メッセージの種類</th>\n<th style="text-align:right">メッセージストリーム ID</th>\n<th style="text-align:left">チャンクデータ</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left">\n<p>publish</p>\n</td>\n<td style="text-align:right">\n<p>3</p>\n</td>\n<td style="text-align:right">\n<p>0</p>\n</td>\n<td style="text-align:right">\n<p>?</p>\n</td>\n<td style="text-align:right">\n<p>20</p>\n</td>\n<td style="text-align:right">\n<p>0</p>\n</td>\n<td style="text-align:left">\n<ul>\n<li>コマンド名: publish</li>\n<li>トランザクション ID: <strong>5</strong> (おそらく)</li>\n<li>コマンドオブジェクト: Null</li>\n<li>公開名 (何らかの文字列)</li>\n<li>公開の種類: live, record, append のいずれか</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n<p>「公開の種類」はそれぞれ以下を意味する.</p>\n<ul>\n<li>live: 受信した映像・音声データを<strong>ファイルに記録せず</strong>に他のクライアントに転送する.</li>\n<li>record: 受信した映像・音声データを<strong>新規のファイルとして記録</strong>しながら, 他のクライアントに転送する.</li>\n<li>append: 受信した映像・音声データを<strong>既存のファイルに追記</strong>しながら, 他のクライアントに転送する.</li>\n</ul>\n<h4 id="publish-%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%81%AE%E5%8F%97%E4%BF%A1"><a class="header-anchor" href="#publish-%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%81%AE%E5%8F%97%E4%BF%A1">¶</a> publish コマンドの受信</h4>\n<p>次に, 上記チャンクを受信する例を以下に記す.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    collections::{\n        HashMap\n    },\n    io::{\n        Error <span class="hljs-keyword">as</span> IOError,\n        ErrorKind,\n        Read,\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    }\n};\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-keyword">impl</span> BasicHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header_format</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u8</span> {\n        <span class="hljs-keyword">self</span>.message_header_format\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_chunk_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u16</span> {\n        <span class="hljs-keyword">self</span>.chunk_id\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MessageHeader</span></span> {\n    timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_length: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_type: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt;,\n    message_id: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;\n}\n\n<span class="hljs-keyword">impl</span> MessageHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_timestamp</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, timestamp: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.timestamp = <span class="hljs-literal">Some</span>(timestamp);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_length</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_length\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_length</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_length: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.message_length = <span class="hljs-literal">Some</span>(message_length);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_type</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_type\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_type</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_type: <span class="hljs-built_in">u8</span>) {\n        <span class="hljs-keyword">self</span>.message_type = <span class="hljs-literal">Some</span>(message_type);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.mmessage_id\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_id</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_id: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.message_id = <span class="hljs-literal">Some</span>(message_id);\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PingData</span></span> {\n    StreamBegin(<span class="hljs-built_in">u32</span>)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    Null,\n    Unknown\n}\n\n<span class="hljs-keyword">impl</span> AmfData {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">number</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {\n            AmfData::Number(number) =&gt; <span class="hljs-literal">Some</span>(number),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">boolean</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">bool</span>&gt; {\n        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {\n            AmfData::Boolean(boolean) =&gt; <span class="hljs-literal">Some</span>(boolean),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">string</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">String</span>&gt; {\n        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {\n            AmfData::<span class="hljs-built_in">String</span>(string) =&gt; <span class="hljs-literal">Some</span>(string),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">object</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;&gt; {\n        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {\n            AmfData::Object(object) =&gt; <span class="hljs-literal">Some</span>(object),\n            _ =&gt; <span class="hljs-literal">None</span>\n        } \n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ConnectCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;,\n        information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ReleaseStreamCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        playpath: <span class="hljs-built_in">String</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>\n    }\n}\n\n<span class="hljs-keyword">impl</span> ReleaseStreamCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            ReleaseStreamCommand::Request {\n                transaction_id,\n                play_path: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">CreateStreamCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        message_id: <span class="hljs-built_in">f64</span>\n    }\n}\n\n<span class="hljs-keyword">impl</span> CreateStreamCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            CreateStreamCommand::Request {\n                transaction_id\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetConnectionCommand</span></span> {\n    Connect(ConnectCommand),\n    ReleaseStream(ReleaseStreamCommand),\n    CreateStream(CreateStreamCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FCPublishCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        playpath: <span class="hljs-built_in">String</span>\n    },\n    Response\n}\n\n<span class="hljs-keyword">impl</span> FCPublishCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            FCPublishCommand::Request {\n                transaction_id,\n                playpath: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PublishCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        publishing_name: <span class="hljs-built_in">String</span>,\n        publishing_type: <span class="hljs-built_in">String</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    }\n}\n\n<span class="hljs-keyword">impl</span> PublishCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            Request {\n                transaction_id,\n                publishing_name: _,\n                publishing_type: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetStreamCommand</span></span> {\n    Publish(PublishCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InvokeCommand</span></span> {\n    NetConnection(NetConnectionCommand),\n    NetStream(NetStreamCommand),\n    FCPublish(FCPublishCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    ChunkSize(<span class="hljs-built_in">u32</span>),\n    Ping(<span class="hljs-built_in">u16</span>, PingData),\n    ServerBandwidth(<span class="hljs-built_in">u32</span>),\n    ClientBandwidth(<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u8</span>),\n    Invoke(InvokeCommand),\n    Unknown(<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;)\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span></span> {\n    basic_header: BasicHeader,\n    message_header: MessageHeader,\n    extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    data: Data\n}\n\n<span class="hljs-keyword">impl</span> Chunk {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_basic_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; BasicHeader {\n        <span class="hljs-keyword">self</span>.basic_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; MessageHeader {\n        <span class="hljs-keyword">self</span>.message_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_extended_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.extended_timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_data</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Data {\n        &amp;<span class="hljs-keyword">self</span>.data\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_number</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> number_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">8</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">8</span>];\n\n    number_bytes.copy_from_slice(&amp;data[*offset..(*offset + <span class="hljs-number">8</span>)]);\n    *offset += <span class="hljs-number">8</span>;\n\n    <span class="hljs-keyword">let</span> number = <span class="hljs-built_in">f64</span>::from_bits(<span class="hljs-built_in">u64</span>::from_be_bytes(number_bytes));\n\n    <span class="hljs-literal">Ok</span>(AmfData::Number(number))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_boolean</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> boolean = data[*offset] &gt; <span class="hljs-number">0</span>;\n\n    *offset += <span class="hljs-number">1</span>;\n    <span class="hljs-literal">Ok</span>(AmfData::Boolean(boolean))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_string</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">2</span>];\n\n    length_bytes.copy_from_slice(&amp;data[*offset..(*offset + <span class="hljs-number">2</span>)]);\n    *offset += <span class="hljs-number">2</span>;\n\n    <span class="hljs-keyword">let</span> string = <span class="hljs-built_in">String</span>::from_utf8(data[*offset..(*offset + length)].to_vec()).map_err(\n        |_| IOError::from(ErrorKind::InvalidData)\n    )?;\n\n    *offset += length;\n    <span class="hljs-literal">Ok</span>(AmfData::<span class="hljs-built_in">String</span>(string))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_object</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n    <span class="hljs-keyword">while</span> &amp;data[*offset..(*offset + <span class="hljs-number">3</span>)] != &amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>] {\n        <span class="hljs-keyword">let</span> name = decode_amf_string(data, offset)?.string().unwrap();\n        <span class="hljs-keyword">let</span> value = decode_amf_data(data, offset)?;\n\n        object.insert(name, value);\n    }\n\n    <span class="hljs-literal">Ok</span>(AmfData::Object(object))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_null</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-literal">Ok</span>(AmfData::Null)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_unknown</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-comment">/* 当該部分の実装は後述する. */</span>\n    <span class="hljs-literal">Ok</span>(AmfData::Unknown)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_data</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">match</span> data[*offset] {\n        <span class="hljs-number">0</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_number(data, offset)\n        },\n        <span class="hljs-number">1</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_boolean(data, offset)\n        },\n        <span class="hljs-number">2</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_string(data, offset)\n        },\n        <span class="hljs-number">3</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_object(data, offset)\n        },\n        <span class="hljs-number">5</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_null(data, offset)\n        },\n        _ =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_unknown()\n        }\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_basic_header</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream) -&gt; IOResult&lt;BasicHeader&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> first_byte: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n    stream.read(&amp;<span class="hljs-keyword">mut</span> first_byte)?;\n\n    <span class="hljs-keyword">let</span> message_header_format = (first_byte[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0xc0</span>) &gt;&gt; <span class="hljs-number">6</span>;\n    <span class="hljs-keyword">let</span> chunk_id = <span class="hljs-keyword">match</span> first_byte[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x3f</span> {\n        <span class="hljs-number">0</span> =&gt; {\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> chunk_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n            stream.read(&amp;<span class="hljs-keyword">mut</span> chunk_id_bytes)?;\n            (<span class="hljs-built_in">u8</span>::from_be_bytes(chunk_id_bytes) + <span class="hljs-number">64</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>\n        },\n        <span class="hljs-number">1</span> =&gt; {\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> chunk_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">2</span>];\n\n            stream.read(&amp;<span class="hljs-keyword">mut</span> chunk_id_bytes)?;\n            <span class="hljs-built_in">u16</span>::from_le_bytes(chunk_id_bytes) + <span class="hljs-number">64</span>\n        },\n        n =&gt; n\n    };\n\n    <span class="hljs-literal">Ok</span>(\n        BasicHeader {\n            message_header_format,\n            chunk_id\n        }\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_message_header</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, message_header_format: <span class="hljs-built_in">u8</span>) -&gt; IOResult&lt;MessageHeader&gt; {\n    <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">0</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_type_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_length_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_type_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_id_bytes)?;\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n        message_length_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;message_length_bytes);\n\n        <span class="hljs-keyword">let</span> timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n        <span class="hljs-keyword">let</span> message_length = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(message_length_tmp));\n        <span class="hljs-keyword">let</span> message_type = <span class="hljs-literal">Some</span>(message_type_bytes[<span class="hljs-number">0</span>]);\n        <span class="hljs-keyword">let</span> message_id = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_le_bytes(message_id_bytes));\n\n        <span class="hljs-literal">Ok</span>(\n            MessageHeader {\n                timestamp,\n                message_length,\n                message_type,\n                message_id\n            }\n        )\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">1</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_type_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_length_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_type_bytes)?;\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n        message_length_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;message_length_bytes);\n\n        <span class="hljs-keyword">let</span> timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n        <span class="hljs-keyword">let</span> message_length = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(message_length_tmp));\n        <span class="hljs-keyword">let</span> message_type = <span class="hljs-literal">Some</span>(message_type_bytes[<span class="hljs-number">0</span>]);\n\n        <span class="hljs-literal">Ok</span>(\n            MessageHeader {\n                timestamp,\n                message_length,\n                message_type,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        )\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">2</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n\n        <span class="hljs-keyword">let</span> timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n\n        <span class="hljs-literal">Ok</span>(\n            MessageHeader {\n                timestamp,\n                message_length: <span class="hljs-literal">None</span>,\n                message_type: <span class="hljs-literal">None</span>,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        )\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-literal">Ok</span>(\n            MessageHeader {\n                timestamp: <span class="hljs-literal">None</span>,\n                message_length: <span class="hljs-literal">None</span>,\n                message_type: <span class="hljs-literal">None</span>,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        )\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_extended_timestamp</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, timestamp: <span class="hljs-built_in">u32</span>) -&gt; IOResult&lt;<span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;&gt; {\n    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0x00ffffff</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> extended_timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> extended_timestamp_bytes)?;\n        <span class="hljs-literal">Ok</span>(<span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(extended_timestamp_bytes)))\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-literal">Ok</span>(<span class="hljs-literal">None</span>)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_connect</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = decode_amf_data(data, offset)?.number().unwrap();\n    <span class="hljs-keyword">let</span> command_object = decode_amf_data(data, offset)?.object().unwrap();\n\n    <span class="hljs-literal">Ok</span>(\n        Data::Invoke(\n            InvokeCommand::NetConnection(\n                NetConnectionCommand::Connect(\n                    ConnectCommand::Request {\n                        transaction_id,\n                        command_object\n                    }\n                )\n            )\n        )\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_release_stream</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = decode_amf_data(data, offset)?.number().unwrap();\n\n    decode_amf_data(data, offset)?;\n\n    <span class="hljs-keyword">let</span> playpath = decode_amf_data(data, offset)?.string().unwrap();\n\n    <span class="hljs-literal">Ok</span>(\n        Data::Invoke(\n            InvokeCommand::NetConnection(\n                NetConnectionCommand::ReleaseStream(\n                    ReleaseStreamCommand::Request {\n                        transaction_id,\n                        playpath\n                    }\n                )\n            )\n        )\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_fc_publish</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = decode_amf_data(data, offset)?.number().unwrap();\n\n    decode_amf_data(data, offset)?;\n\n    <span class="hljs-keyword">let</span> playpath = decode_amf_data(data, offset)?.string().unwrap();\n\n    <span class="hljs-literal">Ok</span>(\n        Data::Invoke(\n            InvokeCommand::FCPublish(\n                FCPublishCommand::Request {\n                    transaction_id,\n                    playpath\n                }\n            )\n        )\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_create_stream</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = decode_amf_data(data, offset)?.number().unwrap();\n\n    decode_amf_data(data, offset)?;\n\n    <span class="hljs-literal">Ok</span>(\n        Data::Invoke(\n            InvokeCommand::NetConnection(\n                NetConnectionCommand::CreateStream(\n                    CreateStreamCommand::Request {\n                        transaction_id\n                    }\n                )\n            )\n        )\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_publish</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = decode_amf_data(data, offset)?.number().unwrap();\n\n    decode_amf_data(data, offset)?;\n\n    <span class="hljs-keyword">let</span> publishing_name = decode_amf_data(data, offset)?.string().unwrap();\n    <span class="hljs-keyword">let</span> publishing_type = decode_amf_data(data, offset)?.string().unwrap();\n\n    <span class="hljs-literal">Ok</span>(\n        Data::Invoke(\n            InvokeCommand::NetStream(\n                NetStreamCommand::Publish(\n                    PublishCommand::Request {\n                        transaction_id,\n                        publishing_name,\n                        publishing_type\n                    }\n                )\n            )\n        )\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_invoke</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset = <span class="hljs-built_in">usize</span>::default();\n    <span class="hljs-keyword">let</span> command_name = decode_amf_data(data, &amp;<span class="hljs-keyword">mut</span> offset)?.string().unwrap();\n\n    <span class="hljs-keyword">if</span> command_name == <span class="hljs-string">"connect"</span> {\n        decode_connect(data, &amp;<span class="hljs-keyword">mut</span> offset)\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> command_name == <span class="hljs-string">"releaseStream"</span> {\n        decode_release_stream(data, &amp;<span class="hljs-keyword">mut</span> offset)\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> command_name == <span class="hljs-string">"FCPublish"</span> {\n        decode_fc_publish(data, &amp;<span class="hljs-keyword">mut</span> offset)\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> command_name == <span class="hljs-string">"createStream"</span> {\n        decode_create_stream(data, &amp;<span class="hljs-keyword">mut</span> offset)\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> command_name == <span class="hljs-string">"publish"</span> {\n        decode_publish(data, &amp;<span class="hljs-keyword">mut</span> offset)\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"unknown command!: {}"</span>, command_name)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_data</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, message_type: <span class="hljs-built_in">u8</span>, message_length: <span class="hljs-built_in">u32</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> splits = <span class="hljs-keyword">if</span> message_length &lt;= DEFAULT_CHUNK_SIZE {\n        <span class="hljs-number">0</span>\n    } <span class="hljs-keyword">else</span> {\n        message_length / DEFAULT_CHUNK_SIZE + (message_length % DEFAULT_CHUNK_SIZE &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>\n    };\n    <span class="hljs-keyword">let</span> actual_message_length = (message_length + splits) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::with_capacity(actual_message_length);\n\n    <span class="hljs-keyword">unsafe</span> {\n        data_bytes.set_len(actual_message_length);\n    }\n\n    stream.read(data_bytes.as_mut_slice())?;\n\n    <span class="hljs-keyword">if</span> splits &gt; <span class="hljs-number">0</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> split_data: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..splits {\n            <span class="hljs-keyword">let</span> start = <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> {\n                (DEFAULT_CHUNK_SIZE * i) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>\n            } <span class="hljs-keyword">else</span> {\n                (DEFAULT_CHUNK_SIZE * i + <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n            };\n            <span class="hljs-keyword">let</span> end = start + DEFAULT_CHUNK_SIZE <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n\n            split_data.extend_from_slice(&amp;data_bytes[start..end]);\n        }\n\n        data_bytes = split_data;\n    }\n\n    <span class="hljs-keyword">match</span> message_type {\n        <span class="hljs-number">20</span> =&gt; decode_invoke(data_bytes),\n        _ =&gt; <span class="hljs-literal">Ok</span>(Data::Unknown(data_bytes))\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_chunk</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, last_received_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;Chunk&gt; {\n    <span class="hljs-keyword">let</span> basic_header = receive_basic_header(stream)?;\n    <span class="hljs-keyword">let</span> chunk_id = basic_header.get_chunk_id();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_message_header = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span> (<span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> last_message_header) = last_received_chunks.get_mut(&amp;chunk_id) {\n        *last_message_header\n    } <span class="hljs-keyword">else</span> {\n        MessageHeader {\n            timestamp: <span class="hljs-literal">None</span>,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        }\n    };\n    <span class="hljs-keyword">let</span> received_message_header = receive_message_header(stream, basic_header.get_message_header_format())?;\n    <span class="hljs-keyword">let</span> timestamp = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(timestamp) = received_message_header.get_timestamp() {\n        timestamp\n    } <span class="hljs-keyword">else</span> {\n        last_message_header.get_timestamp().unwrap()\n    };\n    <span class="hljs-keyword">let</span> message_length = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = received_message_header.get_message_length() {\n        message_length\n    } <span class="hljs-keyword">else</span> {\n        last_message_header.unwrap().get_message_length().unwrap()\n    };\n    <span class="hljs-keyword">let</span> message_type = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_type) = received_message_header.get_message_type() {\n        message_type\n    } <span class="hljs-keyword">else</span> {\n        last_message_header.get_message_type().unwrap()\n    };\n    <span class="hljs-keyword">let</span> message_id = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_id) = received_message_header.get_message_id() {\n        message_id\n    } <span class="hljs-keyword">else</span> {\n        last_message_header.get_message_id().unwrap()\n    };\n    <span class="hljs-keyword">let</span> extended_timestamp = receive_extended_timestamp(stream, timestamp)?;\n    <span class="hljs-keyword">let</span> data = receive_data(stream, message_type, message_length)?;\n\n    last_message_header.set_timestamp(timestamp);\n    last_message_header.set_message_length(message_length);\n    last_message_header.set_message_type(message_type);\n    last_message_header.set_message_id(message_id);\n    last_received_chunks.insert(chunk_id, last_message_header);\n\n    <span class="hljs-literal">Ok</span>(\n        Chunk {\n            basic_header,\n            message_header,\n            extended_timestamp,\n            data\n        }\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener: TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_received_chunks: HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt; = HashMap::new();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_sent_chunks: HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt; = HashMap::new();\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n\n        <span class="hljs-keyword">loop</span> {\n            <span class="hljs-keyword">let</span> received_chunk = receive_chunk(&amp;<span class="hljs-keyword">mut</span> stream, &amp;<span class="hljs-keyword">mut</span> last_received_chunks)?;\n\n            <span class="hljs-keyword">match</span> received_chunk.get_data().clone() {\n                Data::Invoke(invoke_command) =&gt; send_invoke_response(&amp;<span class="hljs-keyword">mut</span> stream, invoke_command, &amp;<span class="hljs-keyword">mut</span> last_sent_chunks)?,\n                _ =&gt; {}\n            }\n        }\n    }\n}\n</code></pre>\n<h4 id="publish-%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E8%A6%81%E6%B1%82%E3%81%B8%E3%81%AE%E8%BF%94%E9%80%81%E6%89%8B%E9%A0%86"><a class="header-anchor" href="#publish-%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E8%A6%81%E6%B1%82%E3%81%B8%E3%81%AE%E8%BF%94%E9%80%81%E6%89%8B%E9%A0%86">¶</a> publish コマンド要求への返送手順</h4>\n<p>サーバ側は上記の実装でクライアント側から受信した publish コマンド要求に対して, 以下の二種類の返送チャンクを送信する.</p>\n<ol>\n<li>Ping(Stream Begin) チャンク</li>\n<li>Invoke(onStatus) チャンク</li>\n</ol>\n<p>ここで, 当該返送処理に必要な通信の手順を以下に改めて記す.</p>\n<div id="rtmp-invoke-publish-sequences">\n<a href="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuRArLV3CAylFJjL8BafDB4aDBW5IkPeAZnjtF6vSztJ_dEThfpnkx7cwhkV9hhR7ZTCVDyxNKx2rvNhSjFvnyyh7JKiUDorwtBpvSNE7WgwTmkEchO-Rzpnkdc05CxMWD2adipX3amik1L67hjjA8RGujKZ1EJ-lf2W_HmFY30MdrFJCF2BqGYtBpmikIImfBTO4UUlPZ0LFc_lrNyxV_7Jn1g1VNZOqFksV_cJ_miTDarvEwtwwlFjnuyp7JTt4U4T1Mrl1Ii4tjIGn9R4aaR3d7KjJClC9AmlBJ4dDn-5Ma4CHuGvowEF6VOyRbuETwv2QbmACFG00" target="_self"><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuRArLV3CAylFJjL8BafDB4aDBW5IkPeAZnjtF6vSztJ_dEThfpnkx7cwhkV9hhR7ZTCVDyxNKx2rvNhSjFvnyyh7JKiUDorwtBpvSNE7WgwTmkEchO-Rzpnkdc05CxMWD2adipX3amik1L67hjjA8RGujKZ1EJ-lf2W_HmFY30MdrFJCF2BqGYtBpmikIImfBTO4UUlPZ0LFc_lrNyxV_7Jn1g1VNZOqFksV_cJ_miTDarvEwtwwlFjnuyp7JTt4U4T1Mrl1Ii4tjIGn9R4aaR3d7KjJClC9AmlBJ4dDn-5Ma4CHuGvowEF6VOyRbuETwv2QbmACFG00" alt=""></a></div>\n<p id="caption-rtmp-invoke-publish-sequences">図2. Invoke(publish) チャンクの送受信手順</p>\n<p>次に onStatus コマンドに入力する値を記す. 公式ドキュメント<sup class="footnote-ref"><a href="#fn1" id="fnref1:2">[1:2]</a></sup>では以下のように指定されている.</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">コマンド名</th>\n<th style="text-align:right">チャンクストリーム ID</th>\n<th style="text-align:right">タイムスタンプ</th>\n<th style="text-align:right">メッセージ長</th>\n<th style="text-align:right">メッセージの種類 (ID)</th>\n<th style="text-align:right">メッセージストリーム ID</th>\n<th style="text-align:left">チャンクデータ</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left">\n<p>onStatus</p>\n</td>\n<td style="text-align:right">\n<p>3</p>\n</td>\n<td style="text-align:right">\n<p>0</p>\n</td>\n<td style="text-align:right">\n<p>?</p>\n</td>\n<td style="text-align:right">\n<p>20</p>\n</td>\n<td style="text-align:right">\n<p>0</p>\n</td>\n<td style="text-align:left">\n<ul>\n<li>コマンド名: onStatus</li>\n<li>トランザクション ID: 0</li>\n<li>インフォメーション:\n<ul>\n<li>level: このメッセージのレベル. status, warn, error のいずれか一つ.</li>\n<li>code: メッセージコード. 例えば, NetStream.Play.Start.</li>\n<li>description: メッセージの人間が読める説明.</li>\n</ul>\n</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n<p>注: インフォメーションはコードへ必要に応じて他のプロパティを含め<strong>てもよい</strong>.</p>\n<p>一方で, FFmpeg では以下の値が入力されている.</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:left">コマンド名</th>\n<th style="text-align:right">チャンクストリーム ID</th>\n<th style="text-align:right">タイムスタンプ</th>\n<th style="text-align:right">メッセージ長</th>\n<th style="text-align:right">メッセージの種類 (ID)</th>\n<th style="text-align:right">メッセージストリーム ID</th>\n<th style="text-align:left">チャンクデータ</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:left">\n<p>onStatus</p>\n</td>\n<td style="text-align:right">\n<p>3</p>\n</td>\n<td style="text-align:right">\n<p>0</p>\n</td>\n<td style="text-align:right">\n<p>?</p>\n</td>\n<td style="text-align:right">\n<p>20</p>\n</td>\n<td style="text-align:right">\n<p>0</p>\n</td>\n<td style="text-align:left">\n<ul>\n<li>コマンド名: onStatus</li>\n<li>トランザクション ID: 0</li>\n<li>インフォメーション:\n<ul>\n<li>level: status</li>\n<li>code: NetStream.Publish.Start</li>\n<li>description: <em>playpath</em> is now published</li>\n<li>details: <em>playpath</em> の値</li>\n</ul>\n</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n<p>次に, 返送チャンクを送信する例を以下に記す.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    collections::{\n        HashMap\n    },\n    io::{\n        Error <span class="hljs-keyword">as</span> IOError,\n        ErrorKind,\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult,\n        Write\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    }\n};\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-keyword">impl</span> BasicHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header_format</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u8</span> {\n        <span class="hljs-keyword">self</span>.message_header_format\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_chunk_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u16</span> {\n        <span class="hljs-keyword">self</span>.chunk_id\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MessageHeader</span></span> {\n    timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_length: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_type: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt;,\n    message_id: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;\n}\n\n<span class="hljs-keyword">impl</span> MessageHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_timestamp</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, timestamp: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.timestamp = <span class="hljs-literal">Some</span>(timestamp);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_length</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_length\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_length</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_length: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.message_length = <span class="hljs-literal">Some</span>(message_length);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_type</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_type\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_type</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_type: <span class="hljs-built_in">u8</span>) {\n        <span class="hljs-keyword">self</span>.message_type = <span class="hljs-literal">Some</span>(message_type);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.mmessage_id\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_id</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_id: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.message_id = <span class="hljs-literal">Some</span>(message_id);\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PingData</span></span> {\n    StreamBegin(<span class="hljs-built_in">u32</span>)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    Null,\n    Unknown\n}\n\n<span class="hljs-keyword">impl</span> AmfData {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">number</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {\n            AmfData::Number(number) =&gt; <span class="hljs-literal">Some</span>(number),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">boolean</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">bool</span>&gt; {\n        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {\n            AmfData::Boolean(boolean) =&gt; <span class="hljs-literal">Some</span>(boolean),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">string</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">String</span>&gt; {\n        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {\n            AmfData::<span class="hljs-built_in">String</span>(string) =&gt; <span class="hljs-literal">Some</span>(string),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">object</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;&gt; {\n        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {\n            AmfData::Object(object) =&gt; <span class="hljs-literal">Some</span>(object),\n            _ =&gt; <span class="hljs-literal">None</span>\n        } \n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ConnectCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;,\n        information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ReleaseStreamCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        playpath: <span class="hljs-built_in">String</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>\n    }\n}\n\n<span class="hljs-keyword">impl</span> ReleaseStreamCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            ReleaseStreamCommand::Request {\n                transaction_id,\n                play_path: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">CreateStreamCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        message_id: <span class="hljs-built_in">f64</span>\n    }\n}\n\n<span class="hljs-keyword">impl</span> CreateStreamCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            CreateStreamCommand::Request {\n                transaction_id\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetConnectionCommand</span></span> {\n    Connect(ConnectCommand),\n    ReleaseStream(ReleaseStreamCommand),\n    CreateStream(CreateStreamCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FCPublishCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        playpath: <span class="hljs-built_in">String</span>\n    },\n    Response\n}\n\n<span class="hljs-keyword">impl</span> FCPublishCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            FCPublishCommand::Request {\n                transaction_id,\n                playpath: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PublishCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        publishing_name: <span class="hljs-built_in">String</span>,\n        publishing_type: <span class="hljs-built_in">String</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    }\n}\n\n<span class="hljs-keyword">impl</span> PublishCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            PublishCommand::Request {\n                transaction_id,\n                publishing_name: _,\n                publishing_type: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_publishing_name</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">String</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            PublishCommand::Request {\n                transaction_id: _,\n                publishing_name,\n                publishing_type: _\n            } =&gt; <span class="hljs-literal">Some</span>(publishing_name),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetStreamCommand</span></span> {\n    Publish(PublishCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InvokeCommand</span></span> {\n    NetConnection(NetConnectionCommand),\n    NetStream(NetStreamCommand),\n    FCPublish(FCPublishCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    ChunkSize(<span class="hljs-built_in">u32</span>),\n    Ping(<span class="hljs-built_in">u16</span>, PingData),\n    ServerBandwidth(<span class="hljs-built_in">u32</span>),\n    ClientBandwidth(<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u8</span>),\n    Invoke(InvokeCommand),\n    Unknown(<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;)\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span></span> {\n    basic_header: BasicHeader,\n    message_header: MessageHeader,\n    extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    data: Data\n}\n\n<span class="hljs-keyword">impl</span> Chunk {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_basic_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; BasicHeader {\n        <span class="hljs-keyword">self</span>.basic_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; MessageHeader {\n        <span class="hljs-keyword">self</span>.message_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_extended_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.extended_timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_data</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Data {\n        &amp;<span class="hljs-keyword">self</span>.data\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_basic_header</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, basic_header: BasicHeader) {\n    <span class="hljs-keyword">let</span> message_header_format = basic_header.get_message_header_format();\n    <span class="hljs-keyword">let</span> chunk_id = basic_header.get_chunk_id();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> second_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> first_byte = <span class="hljs-keyword">if</span> chunk_id &gt; <span class="hljs-number">319</span> {\n        second_bytes.extend_from_slice(&amp;chunk_id.to_le_bytes());\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | <span class="hljs-number">1</span>\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> chunk_id &gt; <span class="hljs-number">63</span> {\n        second_bytes.push(chunk_id <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | <span class="hljs-number">0</span>\n    } <span class="hljs-keyword">else</span> {\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | chunk_id\n    };\n\n    v.push(first_byte);\n    v.append(&amp;<span class="hljs-keyword">mut</span> second_bytes);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_message_header</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, message_header: MessageHeader) {\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(timestamp) = message_header.get_timestamp() {\n        v.extend_from_slice(&amp;timestamp.to_be_bytes()[<span class="hljs-number">1</span>..]);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = message_header.get_message_length() {\n        v.extend_from_slice(&amp;message_length.to_be_bytes()[<span class="hljs-number">1</span>..]);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_type) = message_header.get_message_type() {\n        v.push(message_type);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> some(message_id) = message_header.get_message_id() {\n        v.extend_from_slice(&amp;message_id.to_le_bytes());\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_extended_timestamp</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;) {\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(extended_timestamp) = extended_timestamp {\n        v.extend_from_slice(&amp;extended_timestamp.to_be_bytes());\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_chunk_size</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, chunk_size: <span class="hljs-built_in">u32</span>) {\n    v.extend_from_slice(&amp;chunk_size.to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_ping</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, ping_type: <span class="hljs-built_in">u16</span>, ping_data: PingData) {\n    v.extend_from_slice(&amp;ping_type.to_be_bytes());\n\n    <span class="hljs-keyword">match</span> ping_data {\n        PingData::StreamBegin(message_id) =&gt; v.extend_from_slice(&amp;message_id.to_be_bytes())\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_server_bandwidth</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, server_bandwidth: <span class="hljs-built_in">u32</span>) {\n    v.extend_from_slice(&amp;server_bandwidth.to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_client_bandwidth</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, client_bandwidth: <span class="hljs-built_in">u32</span>, limit: <span class="hljs-built_in">u8</span>) {\n    v.extend_from_slice(&amp;client_bandwidth.to_be_bytes());\n    v.push(limit);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_number</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, number: <span class="hljs-built_in">f64</span>) {\n    v.push(<span class="hljs-number">0</span>);\n    v.extend_from_slice(&amp;number.to_bits().to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_boolean</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, boolean: <span class="hljs-built_in">bool</span>) {\n    v.push(<span class="hljs-number">1</span>);\n    v.push(boolean <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_string</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, <span class="hljs-keyword">mut</span> string: <span class="hljs-built_in">String</span>) {\n    v.push(<span class="hljs-number">2</span>);\n    v.extend_from_slice(&amp;(string.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n    v.append(string.as_mut_vec());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_object</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;) {\n    v.push(<span class="hljs-number">3</span>);\n\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">mut</span> name, value) <span class="hljs-keyword">in</span> object {\n        v.extend_from_slice(&amp;(name.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n        v.append(name.as_mut_vec());\n        encode_amf_data(v, value);\n    }\n\n    v.extend_from_slice(&amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>]);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_null</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;) {\n    v.push(<span class="hljs-number">5</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_data</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, data: AmfData) {\n    <span class="hljs-keyword">match</span> data {\n        AmfData::Number(number) =&gt; encode_amf_number(v, number),\n        AmfData::Boolean(boolean) =&gt; encode_amf_boolean(v, boolean),\n        AmfData::<span class="hljs-built_in">String</span>(string) =&gt; encode_amf_string(v, string),\n        AmfData::Object(object) =&gt; encode_amf_object(v, object),\n        AmfData::Null =&gt; encode_amf_null(v),\n        <span class="hljs-comment">// まだ上記以外の AMF 型のデータを特定できていないため, 現段階では無視することとする.</span>\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_connect</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, connect_command: ConnectCommand) {\n    <span class="hljs-keyword">match</span> connect_command {\n        Connect::Response {\n            transaction_id,\n            properties,\n            information\n        } =&gt; {\n            encode_amf_string(v, <span class="hljs-string">"_result"</span>.to_string());\n            encode_amf_number(v, transaction_id);\n            encode_amf_object(v, properties);\n            encode_amf_object(v, information);\n        },\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_release_stream</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, release_stream_command: ReleaseStreamCommand) {\n    <span class="hljs-keyword">match</span> release_stream_command {\n        ReleaseStreamCommand::Response {\n            transaction_id\n        } =&gt; {\n            encode_amf_string(v, <span class="hljs-string">"_result"</span>.to_string());\n            encode_amf_number(v, transaction_id);\n            encode_amf_null(v);\n        },\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_create_stream</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, create_stream_command: CreateStreamCommand) {\n    <span class="hljs-keyword">match</span> create_stream_command {\n        CreateStreamCommand::Response {\n            transaction_id,\n            message_id\n        } =&gt; {\n            encode_amf_string(v, <span class="hljs-string">"_result"</span>.to_string);\n            encode_amf_number(v, transaction_id);\n            encode_amf_null(v);\n            encode_amf_number(v, message_id);\n        },\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_net_connection</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, net_connection_command: NetConnectionCommand) {\n    <span class="hljs-keyword">match</span> net_connection_command {\n        Connect(connect_command) =&gt; encode_connect(v, connect_command),\n        ReleaseStream(release_stream_command) =&gt; encode_release_stream(v, release_stream_command),\n        CreateStream(create_stream_command) =&gt; encode_create_stream(v, create_stream_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_fc_publish</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, fc_publish_command: FCPublishCommand) {\n    <span class="hljs-keyword">match</span> fc_publish_command {\n        FCPublishCommand::Response =&gt; encode_amf_string(v, <span class="hljs-string">"onFCPublish"</span>.to_string()),\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_publish</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, publish_command: PublishCommand) {\n    <span class="hljs-keyword">match</span> publish_command {\n        PublishCommand::Response {\n            transaction_id,\n            information\n        } =&gt; {\n            encode_amf_string(v, <span class="hljs-string">"onStatus"</span>.to_string());\n            encode_amf_number(v, transaction_id);\n            encode_amf_null(v);\n            encode_amf_object(v, information);\n        },\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_net_stream</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, net_stream_command: NetStreamCommand) {\n    <span class="hljs-keyword">match</span> net_stream_command {\n        NetStreamCommand::Publish(publish_command) =&gt; encode_publish(v, publish_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_invoke</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, invoke_command: InvokeCommand) {\n    <span class="hljs-keyword">match</span> invoke_command {\n        InvokeCommand::NetConnection(net_connection_command) =&gt; encode_net_connection(v, net_connection_command),\n        InvokeCommand::NetStream(net_stream_command) =&gt; encode_net_stream(v, net_stream_command),\n        InvokeCommand::FCPublish(fc_publish_command) =&gt; encode_fc_publish(v, fc_publish_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_data</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, data: Data) {\n    <span class="hljs-keyword">match</span> data {\n        Data::ChunkSize(chunk_size) =&gt; encode_chunk_size(v, chunk_size),\n        Data::Ping(ping_type, ping_data) =&gt; encode_ping(v, ping_type, ping_data),\n        Data::ServerBandwidth(server_bandwidth) =&gt; encode_server_bandwidth(v, server_bandwidth),\n        Data::ClientBandwidth(client_bandwidth, limit) =&gt; encode_client_bandwidth(v, client_bandwidth, limit),\n        Data::Invoke(invoke_command) =&gt; encode_invoke(v, invoke_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_chunk</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, chunk: Chunk) {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_data(&amp;<span class="hljs-keyword">mut</span> data_bytes, chunk.get_data().clone());\n\n    <span class="hljs-keyword">let</span> message_length = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = chunk.get_message_header().get_message_length() {\n        message_length\n    } <span class="hljs-keyword">else</span> {\n        data_bytes.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>\n    };\n    <span class="hljs-keyword">let</span> splits = <span class="hljs-keyword">if</span> message_length &lt;= DEFAULT_CHUNK_SIZE {\n        <span class="hljs-number">0</span>\n    } <span class="hljs-keyword">else</span> {\n        message_length / DEFAULT_CHUNK_SIZE + (message_length % DEFAULT_CHUNK != <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>\n    };\n\n    <span class="hljs-keyword">if</span> splits &gt; <span class="hljs-number">0</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> added: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n        <span class="hljs-keyword">let</span> basic_header = BasicHeader {\n            message_header_format: <span class="hljs-number">3</span>,\n            chunk_id: chunk.get_basic_header().get_chunk_id()\n        };\n\n        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..splits {\n            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> {\n                encode_basic_header(&amp;<span class="hljs-keyword">mut</span> added, basic_header);\n            }\n\n            <span class="hljs-keyword">let</span> start = (DEFAULT_CHUNK_SIZE * i) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n            <span class="hljs-keyword">let</span> end = start + min(DEFAULT_CHUNK_SIZE, data_bytes[start..].len());\n\n            added.extend_from_slice(&amp;data_bytes[start..end]);\n        }\n\n        data_bytes = added;\n    }\n\n    encode_basic_header(v, chunk.get_basic_header());\n    encode_message_header(\n        v,\n        MessageHeader {\n            message_length,\n            ..chunk.get_message_header()\n        }\n    );\n    encode_extended_timestamp(v, chunk.get_extended_timestamp());\n    v.append(&amp;<span class="hljs-keyword">mut</span> data_bytes);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_chunk</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, chunk_id: <span class="hljs-built_in">u16</span>, <span class="hljs-keyword">mut</span> timestamp: <span class="hljs-built_in">u32</span>, message_length: <span class="hljs-built_in">u32</span>, message_type: <span class="hljs-built_in">u8</span>, message_id: <span class="hljs-built_in">u32</span>, data: Data, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_message_header = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> last_message_header) = last_sent_chunks.get_mut(&amp;chunk_id) {\n        *last_message_header\n    } <span class="hljs-keyword">else</span> {\n        MessageHeader {\n            timestamp: <span class="hljs-literal">None</span>,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        }\n    };\n    <span class="hljs-keyword">let</span> last_timestamp = last_message_header.get_timestamp().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_length = last_message_header.get_message_length().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_type = last_message_header.get_message_type().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_id = last_message_header.get_message_id().unwrap_or_default();\n    <span class="hljs-keyword">let</span> message_header_format: <span class="hljs-built_in">u8</span> = <span class="hljs-keyword">if</span> message_id == last_message_id {\n        <span class="hljs-keyword">if</span> message_length == last_message_length &amp;&amp; message_type == last_message_type {\n            <span class="hljs-keyword">if</span> timestamp == last_timestamp {\n                <span class="hljs-number">3</span>\n            } <span class="hljs-keyword">else</span> {\n                <span class="hljs-number">2</span>\n            }\n        } <span class="hljs-keyword">else</span> {\n            <span class="hljs-number">1</span>\n        }\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-number">0</span>\n    };\n    <span class="hljs-keyword">let</span> basic_header = BasicHeader {\n        message_header_format,\n        chunk_id\n    };\n    <span class="hljs-keyword">let</span> extended_timestamp = <span class="hljs-keyword">if</span> timestamp &gt;= <span class="hljs-number">0x00ffffff</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span> {\n        <span class="hljs-keyword">let</span> extended_timestamp = <span class="hljs-literal">Some</span>(timestamp);\n\n        timestamp = <span class="hljs-number">0x00ffffff</span>;\n        extended_timestamp\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-literal">None</span>\n    };\n    <span class="hljs-keyword">let</span> message_header = <span class="hljs-keyword">match</span> message_header_format {\n        <span class="hljs-number">0</span> =&gt; MessageHeader {\n            timestamp,\n            message_length,\n            message_type,\n            message_id\n        },\n        <span class="hljs-number">1</span> =&gt; MessageHeader {\n            timestamp,\n            message_length,\n            message_type,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        <span class="hljs-number">2</span> =&gt; MessageHeader {\n            timestamp,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        <span class="hljs-number">3</span> =&gt; MessageHeader {\n            timestamp: <span class="hljs-literal">None</span>,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        n =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"what\'s this!?: {}"</span>, n)\n    };\n    <span class="hljs-keyword">let</span> chunk = Chunk {\n        basic_header,\n        message_header,\n        extended_timestamp,\n        data\n    };\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> v, chunk);\n    stream.write(v.as_slice()).map(|_| ())\n}\n\n<span class="hljs-comment">/* 送信時のタイムスタンプやメッセージストリーム ID の実際の渡し方については後述する. */</span>\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_chunk_size</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, chunk_size: <span class="hljs-built_in">u32</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">if</span> chunk_size &lt; <span class="hljs-number">1</span> || chunk_size &gt; <span class="hljs-number">0x7fffffff</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidData.into());\n    }\n\n    send_chunk(stream, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, Data::ChunkSize(chunk_size), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_stream_begin</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    send_chunk(stream, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, Data::Ping(<span class="hljs-number">1</span>, PingData::StreamBegin(<span class="hljs-number">0</span>)), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_ping</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, ping_type: <span class="hljs-built_in">u16</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">match</span> ping_type {\n        <span class="hljs-number">1</span> =&gt; send_stream_begin(stream, last_sent_chunks),\n        n =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"what\'s this!?: {}"</span>, n)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_server_bandwidth</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, server_bandwidth: <span class="hljs-built_in">u32</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    send_chunk(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, Data::ServerBandwidth(server_bandwidth), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_client_bandwidth</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, client_bandwidth: <span class="hljs-built_in">u32</span>, limit: <span class="hljs-built_in">u8</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    send_chunk(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, Data::ClientBandwidth(client_bandwidth, limit), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_invoke</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, invoke_command: InvokeCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_data(&amp;<span class="hljs-keyword">mut</span> v, Data::Invoke(invoke_command.clone()));\n    send_chunk(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, v.len(), <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, Data::Invoke(invoke_command), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_connect_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, connect_command: ConnectCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = connect_command.get_received_transaction_id().unwrap();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n    properties.insert(<span class="hljs-string">"fmsVer"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"FMS/3,0,1,123"</span>.to_string()));\n    properties.insert(<span class="hljs-string">"capabilities"</span>.to_string(), AmfData::Number(<span class="hljs-number">31</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n    information.insert(<span class="hljs-string">"level"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"status"</span>.to_string()));\n    information.insert(<span class="hljs-string">"code"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"NetConnection.Connect.Success"</span>.to_string()));\n    information.insert(<span class="hljs-string">"description"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"Connection succeeded."</span>.to_string()));\n    information.insert(<span class="hljs-string">"objectEncoding"</span>.to_string(), AmfData::Number(<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::NetConnection(\n            NetConnectionCommand::Connect(\n                ConnectCommand::Response {\n                    transaction_id,\n                    properties,\n                    information\n                }\n            )\n        )\n    );\n\n    send_invoke(stream, invoke.clone(), last_sent_chunks)?;\n    send_server_bandwidth(stream, DEFAULT_BANDWIDTH, last_sent_chunks)?;\n    send_client_bandwidth(stream, DEFAULT_BANDWIDTH, last_sent_chunks)?;\n    send_ping(stream, <span class="hljs-number">1</span>, last_sent_chunks)?;\n    send_chunk_size(stream, DEFAULT_CHUNK_SIZE, last_sent_chunks)?;\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_release_stream_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, release_stream_command: ReleaseStreamCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = release_stream_command.get_received_trnasaction_id().unwrap();\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::NetConnection(\n            NetConnectionCommand::ReleaseStream(\n                ReleaseStreamCommand::Response {\n                    transaction_id\n                }\n            )\n        )\n    );\n\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_create_stream_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, create_stream_command: CreateStreamCommand, message_id: <span class="hljs-built_in">f64</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = create_stream_command.get_received_transaction_id().unwrap();\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::NetConnection(\n            NetConnectionCommand::CreateStream(\n                CreateStreamCommand::Response {\n                    transaction_id,\n                    message_id\n                }\n            )\n        )\n    );\n\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_net_connection_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, net_connection_command: NetConnectionCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">match</span> net_connection_command {\n        NetConnectionCommand::Connect(connect_command) =&gt; send_connect_response(stream, connect_command, last_sent_chunks),\n        NetConnectionCommand::ReleaseStream(release_stream_command) =&gt; send_release_stream_response(stream, release_stream_command, last_sent_chunks),\n        NetConnectionCommand::CreateStream(create_stream_command) =&gt; send_create_stream_command(stream, create_stream_command, last_sent_chunks)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_fc_publish_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, fc_publish_command: FCPublishCommand) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = fc_publish_command.get_received_transaction_id().unwrap();\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::FCPublish(\n            FCPublishCommand::Response\n        )\n    );\n\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_publish_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, publish_command: PublishCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = publish_command.get_received_transaction_id().unwrap();\n    <span class="hljs-keyword">let</span> publishing_name = publish_command.get_received_publishing_name().unwrap();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n    information.insert(<span class="hljs-string">"level"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"status"</span>.to_string()));\n    information.insert(<span class="hljs-string">"code"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"NetStream.Publish.Start"</span>.to_string()));\n    information.insert(<span class="hljs-string">"description"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">"{} is now published"</span>, publishing_name)));\n    information.insert(<span class="hljs-string">"details"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(publishing_name));\n\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::NetStream(\n            NetStreamCommand::Publish(\n                PublishCommand::Response {\n                    transaction_id,\n                    information\n                }\n            )\n        )\n    );\n\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_net_stream_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, net_stream_command: NetStreamCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">match</span> net_stream_command {\n        NetStreamCommand::Publish(publish_command) =&gt; send_publish_response(stream, publish_command, last_sent_chunks)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_invoke_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, invoke_command: InvokeCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">match</span> invoke_command {\n        InvokeCommand::NetConnection(net_connection_command) =&gt; send_net_connection_response(stream, net_connection_command, last_sent_chunks),\n        InvokeCommand::NetStream(net_stream_command) =&gt; send_net_stream_response(stream, net_stream_command, last_sent_chunks),\n        InvokeCommand::FCPublish(fc_publish_command) =&gt; send_fc_publish_response(stream, fc_publish, last_sent_chunks)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener: TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_received_chunks: HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt; = HashMap::new();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_sent_chunks: HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt; = HashMap::new();\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n\n        <span class="hljs-comment">/* connect コマンドへの返送までは完了しているとみなす. */</span>\n\n        <span class="hljs-keyword">loop</span> {\n            <span class="hljs-keyword">let</span> received_chunk = receive_chunk(&amp;<span class="hljs-keyword">mut</span> stream, &amp;<span class="hljs-keyword">mut</span> last_received_chunks)?;\n\n            <span class="hljs-keyword">match</span> received_chunk.get_data().clone() {\n                Data::Invoke(invoke_command) =&gt; send_invoke_response(&amp;<span class="hljs-keyword">mut</span> stream, invoke_command, &amp;<span class="hljs-keyword">mut</span> last_sent_chunks)?,\n                _ =&gt; {}\n            }\n        }\n    }\n}\n</code></pre>\n<p>上記の実装でエラーが発生しなければ, RTMP における基本的な接続処理はすべて完了である.</p>\n<h2 id="%E3%81%BE%E3%81%A8%E3%82%81"><a class="header-anchor" href="#%E3%81%BE%E3%81%A8%E3%82%81">¶</a> まとめ</h2>\n<p>最後に, ハンドシェイクとチャンクの送受信処理を以下に一つにまとめておく.</p>\n<pre class="hljs"><code><span class="hljs-keyword">use</span> std::{\n    collections::{\n        HashMap\n    },\n    io::{\n        Error <span class="hljs-keyword">as</span> IOError,\n        ErrorKind,\n        Read,\n        <span class="hljs-built_in">Result</span> <span class="hljs-keyword">as</span> IOResult,\n        Write\n    },\n    net::{\n        TcpListener,\n        TcpStream\n    },\n    time::{\n        SystemTime\n    }\n};\n<span class="hljs-keyword">use</span> crypto::{\n    hmac::{\n        Hmac\n    },\n    sha2::{\n        Sha256\n    }\n};\n<span class="hljs-keyword">use</span> rand::prelude::*;\n\n<span class="hljs-keyword">const</span> GENUINE_FP_KEY: &amp;[<span class="hljs-built_in">u8</span>] = &amp;[\n    <span class="hljs-number">0x47</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x4d</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x76</span>,\n    <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-number">0xee</span>, <span class="hljs-number">0xc2</span>, <span class="hljs-number">0x4a</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0xe8</span>, <span class="hljs-number">0x2e</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xd0</span>, <span class="hljs-number">0xd1</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x9e</span>, <span class="hljs-number">0x7e</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0xec</span>, <span class="hljs-number">0x5d</span>, <span class="hljs-number">0x2d</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0xab</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xb8</span>, <span class="hljs-number">0xe6</span>, <span class="hljs-number">0x36</span>, <span class="hljs-number">0xcf</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xae</span>\n];\n<span class="hljs-keyword">const</span> GENUINE_FMS_KEY: &amp;[<span class="hljs-built_in">u8</span>] = &amp;[\n    <span class="hljs-number">0x47</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x4d</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x53</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x76</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x31</span>,\n    <span class="hljs-number">0xf0</span>, <span class="hljs-number">0xee</span>, <span class="hljs-number">0xc2</span>, <span class="hljs-number">0x4a</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0xbe</span>, <span class="hljs-number">0xe8</span>, <span class="hljs-number">0x2e</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xd0</span>, <span class="hljs-number">0xd1</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x9e</span>, <span class="hljs-number">0x7e</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0xec</span>, <span class="hljs-number">0x5d</span>, <span class="hljs-number">0x2d</span>, <span class="hljs-number">0x29</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0xab</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0xb8</span>, <span class="hljs-number">0xe6</span>, <span class="hljs-number">0x36</span>, <span class="hljs-number">0xcf</span>, <span class="hljs-number">0xeb</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xae</span>\n];\n<span class="hljs-keyword">const</span> DEFAULT_CHUNK_SIZE: <span class="hljs-built_in">u32</span> = <span class="hljs-number">128</span>;\n<span class="hljs-keyword">const</span> DEFAULT_BANDWIDTH: <span class="hljs-built_in">u32</span> = <span class="hljs-number">3000000</span>;\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BasicHeader</span></span> {\n    message_header_format: <span class="hljs-built_in">u8</span>,\n    chunk_id: <span class="hljs-built_in">u16</span>\n}\n\n<span class="hljs-keyword">impl</span> BasicHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header_format</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u8</span> {\n        <span class="hljs-keyword">self</span>.message_header_format\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_chunk_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u16</span> {\n        <span class="hljs-keyword">self</span>.chunk_id\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MessageHeader</span></span> {\n    timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_length: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    message_type: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt;,\n    message_id: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;\n}\n\n<span class="hljs-keyword">impl</span> MessageHeader {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_timestamp</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, timestamp: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.timestamp = <span class="hljs-literal">Some</span>(timestamp);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_length</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_length\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_length</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_length: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.message_length = <span class="hljs-literal">Some</span>(message_length);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_type</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u8</span>&gt; {\n        <span class="hljs-keyword">self</span>.message_type\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_type</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_type: <span class="hljs-built_in">u8</span>) {\n        <span class="hljs-keyword">self</span>.message_type = <span class="hljs-literal">Some</span>(message_type);\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.mmessage_id\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_message_id</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, message_id: <span class="hljs-built_in">u32</span>) {\n        <span class="hljs-keyword">self</span>.message_id = <span class="hljs-literal">Some</span>(message_id);\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone, Copy)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PingData</span></span> {\n    StreamBegin(<span class="hljs-built_in">u32</span>)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AmfData</span></span> {\n    Number(<span class="hljs-built_in">f64</span>),\n    Boolean(<span class="hljs-built_in">bool</span>),\n    <span class="hljs-built_in">String</span>(<span class="hljs-built_in">String</span>),\n    Object(HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;),\n    Null,\n    Unknown\n}\n\n<span class="hljs-keyword">impl</span> AmfData {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">number</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {\n            AmfData::Number(number) =&gt; <span class="hljs-literal">Some</span>(number),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">boolean</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">bool</span>&gt; {\n        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {\n            AmfData::Boolean(boolean) =&gt; <span class="hljs-literal">Some</span>(boolean),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">string</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">String</span>&gt; {\n        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {\n            AmfData::<span class="hljs-built_in">String</span>(string) =&gt; <span class="hljs-literal">Some</span>(string),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">object</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;&gt; {\n        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {\n            AmfData::Object(object) =&gt; <span class="hljs-literal">Some</span>(object),\n            _ =&gt; <span class="hljs-literal">None</span>\n        } \n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ConnectCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        command_object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;,\n        information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ReleaseStreamCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        playpath: <span class="hljs-built_in">String</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>\n    }\n}\n\n<span class="hljs-keyword">impl</span> ReleaseStreamCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            ReleaseStreamCommand::Request {\n                transaction_id,\n                play_path: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">CreateStreamCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        message_id: <span class="hljs-built_in">f64</span>\n    }\n}\n\n<span class="hljs-keyword">impl</span> CreateStreamCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            CreateStreamCommand::Request {\n                transaction_id\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetConnectionCommand</span></span> {\n    Connect(ConnectCommand),\n    ReleaseStream(ReleaseStreamCommand),\n    CreateStream(CreateStreamCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">FCPublishCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        playpath: <span class="hljs-built_in">String</span>\n    },\n    Response\n}\n\n<span class="hljs-keyword">impl</span> FCPublishCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            FCPublishCommand::Request {\n                transaction_id,\n                playpath: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PublishCommand</span></span> {\n    Request {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        publishing_name: <span class="hljs-built_in">String</span>,\n        publishing_type: <span class="hljs-built_in">String</span>\n    },\n    Response {\n        transaction_id: <span class="hljs-built_in">f64</span>,\n        information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;\n    }\n}\n\n<span class="hljs-keyword">impl</span> PublishCommand {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_transaction_id</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">f64</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            PublishCommand::Request {\n                transaction_id,\n                publishing_name: _,\n                publishing_type: _\n            } =&gt; <span class="hljs-literal">Some</span>(transaction_id),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_received_publishing_name</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">String</span>&gt; {\n        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {\n            PublishCommand::Request {\n                transaction_id: _,\n                publishing_name,\n                publishing_type: _\n            } =&gt; <span class="hljs-literal">Some</span>(publishing_name),\n            _ =&gt; <span class="hljs-literal">None</span>\n        }\n    }\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetStreamCommand</span></span> {\n    Publish(PublishCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">InvokeCommand</span></span> {\n    NetConnection(NetConnectionCommand),\n    NetStream(NetStreamCommand),\n    FCPublish(FCPublishCommand)\n}\n\n<span class="hljs-meta">#[derive(Clone)]</span>\n<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Data</span></span> {\n    ChunkSize(<span class="hljs-built_in">u32</span>),\n    Ping(<span class="hljs-built_in">u16</span>, PingData),\n    ServerBandwidth(<span class="hljs-built_in">u32</span>),\n    ClientBandwidth(<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u8</span>),\n    Invoke(InvokeCommand),\n    Unknown(<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;)\n}\n\n<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span></span> {\n    basic_header: BasicHeader,\n    message_header: MessageHeader,\n    extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;,\n    data: Data\n}\n\n<span class="hljs-keyword">impl</span> Chunk {\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_basic_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; BasicHeader {\n        <span class="hljs-keyword">self</span>.basic_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_message_header</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; MessageHeader {\n        <span class="hljs-keyword">self</span>.message_header\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_extended_timestamp</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt; {\n        <span class="hljs-keyword">self</span>.extended_timestamp\n    }\n\n    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_data</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Data {\n        &amp;<span class="hljs-keyword">self</span>.data\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">handle_first_handshake</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream) -&gt; IOResult&lt;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> c0c1: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1537</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1537</span>];\n\n    stream.read(&amp;<span class="hljs-keyword">mut</span> c0c1)?;\n\n    <span class="hljs-keyword">if</span> c0c1[<span class="hljs-number">0</span>] != <span class="hljs-number">3</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidInput.into());\n    }\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset_client = <span class="hljs-built_in">usize</span>::default();\n\n    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">4</span> {\n        offset_client += c0c1[<span class="hljs-number">9</span> + i] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n    }\n\n    offset_client = offset_client % <span class="hljs-number">728</span> + <span class="hljs-number">12</span>;\n\n    <span class="hljs-keyword">let</span> digest_client_sent = &amp;c0c1[offset_client..(offset_client + <span class="hljs-number">32</span>)];\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hmac_client = Hmac::new(Sha256::new(), &amp;GENUINE_FP_KEY[..<span class="hljs-number">30</span>]);\n\n    hmac_client.input(&amp;c0c1[<span class="hljs-number">9</span>..(<span class="hljs-number">9</span> + offset_client)]);\n    hmac_client.input(&amp;c0c1[(<span class="hljs-number">9</span> + offset_client + <span class="hljs-number">32</span>)..]);\n\n    <span class="hljs-keyword">let</span> digest_client_expected = hmac_client.result();\n\n    <span class="hljs-keyword">if</span> digest_client_sent != digest_client_expected.code() {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidData.into());\n    }\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s0s1s2: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> timestamp = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap().as_secs() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>;\n\n    s0s1s2.push(<span class="hljs-number">3</span>);\n    s0s1s2.extend_from_slice(&amp;timestamp.to_be_bytes());\n    s0s1s2.extend_from_slice(&amp;[<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>]);\n\n    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">1528</span> {\n        s0s1s2.push(random());\n    }\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset_server = <span class="hljs-built_in">usize</span>::default();\n\n    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">4</span> {\n        offset_server += s0s1s2[<span class="hljs-number">9</span> + i] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n    }\n\n    offset_server = offset_server % <span class="hljs-number">728</span> + <span class="hljs-number">12</span>;\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hmac_server = Hmac::new(Sha256::new(), &amp;GENUINE_FMS_KEY[..<span class="hljs-number">36</span>]);\n\n    hmac_server.input(&amp;s0s1s2[<span class="hljs-number">9</span>..(<span class="hljs-number">9</span> + offset_server)]);\n    hmac_server.input(&amp;s0s1s2[(<span class="hljs-number">9</span> + offset_server + <span class="hljs-number">32</span>)..]);\n\n    <span class="hljs-keyword">let</span> digest_server = hmac.result().code();\n\n    s0s1s2[(<span class="hljs-number">9</span> + offset_server)..(<span class="hljs-number">9</span> + offset_server + <span class="hljs-number">32</span>)].copy_from_slice(digest_server);\n\n\n    hmac_client = Hmac::new(Sha256::new(), &amp;GENUINE_FP_KEY);\n    hmac_client.input(digest_client_sent);\n\n    <span class="hljs-keyword">let</span> digest_s2 = hmac_client.result();\n\n    hmac_client = Hmac::new(Sha256::new(), digest_s2.code());\n    hmac_client.input(c0c1[<span class="hljs-number">9</span>..(c0c1.len() - <span class="hljs-number">32</span>)]);\n\n    <span class="hljs-keyword">let</span> signature_s2 = hmac_client.result();\n\n    c0c1[(c0c1.len() - <span class="hljs-number">32</span>)..].copy_from_slice(signature_s2.code());\n    s0s1s2.extend_from_slice(&amp;c0c1[<span class="hljs-number">1</span>..]);\n    stream.write(s0s1s2.as_slice()).map(|_| s0s1s2[<span class="hljs-number">1</span>..(s0s1s2.len() - <span class="hljs-number">1536</span>)].to_vec())\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">handle_second_handshake</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, s1: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> c2: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1536</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1536</span>];\n\n    stream.read(&amp;<span class="hljs-keyword">mut</span> c2)?;\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset_server_s1 = <span class="hljs-built_in">usize</span>::default();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset_server_c2 = <span class="hljs-built_in">usize</span>::default();\n\n    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">4</span> {\n        offset_server_s1 += s1[<span class="hljs-number">8</span> + i] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n        offset_server_c2 += c2[<span class="hljs-number">8</span> + i] <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n    }\n\n    offset_server_s1 = offset_server_s1 % <span class="hljs-number">728</span> + <span class="hljs-number">12</span>;\n    offset_server_c2 = offset_server_c2 % <span class="hljs-number">728</span> + <span class="hljs-number">12</span>;\n\n    <span class="hljs-keyword">let</span> digest_s1 = &amp;s1[offset_server_s1..(offset_server_s1 + <span class="hljs-number">32</span>)];\n    <span class="hljs-keyword">let</span> digest_c2 = &amp;c2[offset_server_c2..(offset_server_c2 + <span class="hljs-number">32</span>)];\n\n    <span class="hljs-keyword">if</span> digest_s1 != digest_c2 {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidData.into());\n    }\n\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hmac = Hmac::new(Sha256::new(), GENUINE_FMS_KEY);\n\n    hmac.input(&amp;s1[..offset_server_s1]);\n    hmac.input(&amp;s1[(offset_server_s1 + <span class="hljs-number">32</span>)..]);\n\n    <span class="hljs-keyword">let</span> digest = hmac.result();\n\n    hmac = Hmac::new(Sha256::new(), digest.code());\n    hmac.input(&amp;s1[..(s1.len() - <span class="hljs-number">32</span>)]);\n\n    <span class="hljs-keyword">let</span> signature_s1 = hmac.result();\n    <span class="hljs-keyword">let</span> signature_c2 = &amp;c2[(c2.len() - <span class="hljs-number">32</span>)..];\n\n    <span class="hljs-comment">// 注: FFmpeg は何故か C2 チャンクに署名を上書きしていないようであり, FFmpeg からの応答に対してこの処理を行うと必ずエラーになる.</span>\n    <span class="hljs-keyword">if</span> signature_s1 != signature_c2 {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidData.into());\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Ok</span>(());\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_number</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> number_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">8</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">8</span>];\n\n    number_bytes.copy_from_slice(&amp;data[*offset..(*offset + <span class="hljs-number">8</span>)]);\n    *offset += <span class="hljs-number">8</span>;\n\n    <span class="hljs-keyword">let</span> number = <span class="hljs-built_in">f64</span>::from_bits(<span class="hljs-built_in">u64</span>::from_be_bytes(number_bytes));\n\n    <span class="hljs-literal">Ok</span>(AmfData::Number(number))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_boolean</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> boolean = data[*offset] &gt; <span class="hljs-number">0</span>;\n\n    *offset += <span class="hljs-number">1</span>;\n    <span class="hljs-literal">Ok</span>(AmfData::Boolean(boolean))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_string</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">2</span>];\n\n    length_bytes.copy_from_slice(&amp;data[*offset..(*offset + <span class="hljs-number">2</span>)]);\n    *offset += <span class="hljs-number">2</span>;\n\n    <span class="hljs-keyword">let</span> string = <span class="hljs-built_in">String</span>::from_utf8(data[*offset..(*offset + length)].to_vec()).map_err(\n        |_| IOError::from(ErrorKind::InvalidData)\n    )?;\n\n    *offset += length;\n    <span class="hljs-literal">Ok</span>(AmfData::<span class="hljs-built_in">String</span>(string))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_object</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n    <span class="hljs-keyword">while</span> &amp;data[*offset..(*offset + <span class="hljs-number">3</span>)] != &amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>] {\n        <span class="hljs-keyword">let</span> name = decode_amf_string(data, offset)?.string().unwrap();\n        <span class="hljs-keyword">let</span> value = decode_amf_data(data, offset)?;\n\n        object.insert(name, value);\n    }\n\n    <span class="hljs-literal">Ok</span>(AmfData::Object(object))\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_null</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-literal">Ok</span>(AmfData::Null)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_unknown</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-comment">/* 当該部分の実装は後述する. */</span>\n    <span class="hljs-literal">Ok</span>(AmfData::Unknown)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_amf_data</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;AmfData&gt; {\n    <span class="hljs-keyword">match</span> data[*offset] {\n        <span class="hljs-number">0</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_number(data, offset)\n        },\n        <span class="hljs-number">1</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_boolean(data, offset)\n        },\n        <span class="hljs-number">2</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_string(data, offset)\n        },\n        <span class="hljs-number">3</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_object(data, offset)\n        },\n        <span class="hljs-number">5</span> =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_null(data, offset)\n        },\n        _ =&gt; {\n            *offset += <span class="hljs-number">1</span>;\n            decode_amf_unknown()\n        }\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_basic_header</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream) -&gt; IOResult&lt;BasicHeader&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> first_byte: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n    stream.read(&amp;<span class="hljs-keyword">mut</span> first_byte)?;\n\n    <span class="hljs-keyword">let</span> message_header_format = (first_byte[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0xc0</span>) &gt;&gt; <span class="hljs-number">6</span>;\n    <span class="hljs-keyword">let</span> chunk_id = <span class="hljs-keyword">match</span> first_byte[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x3f</span> {\n        <span class="hljs-number">0</span> =&gt; {\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> chunk_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n            stream.read(&amp;<span class="hljs-keyword">mut</span> chunk_id_bytes)?;\n            (<span class="hljs-built_in">u8</span>::from_be_bytes(chunk_id_bytes) + <span class="hljs-number">64</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>\n        },\n        <span class="hljs-number">1</span> =&gt; {\n            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> chunk_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">2</span>];\n\n            stream.read(&amp;<span class="hljs-keyword">mut</span> chunk_id_bytes)?;\n            <span class="hljs-built_in">u16</span>::from_le_bytes(chunk_id_bytes) + <span class="hljs-number">64</span>\n        },\n        n =&gt; n\n    };\n\n    <span class="hljs-literal">Ok</span>(\n        BasicHeader {\n            message_header_format,\n            chunk_id\n        }\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_message_header</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, message_header_format: <span class="hljs-built_in">u8</span>) -&gt; IOResult&lt;MessageHeader&gt; {\n    <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">0</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_type_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_id_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_length_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_type_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_id_bytes)?;\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n        message_length_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;message_length_bytes);\n\n        <span class="hljs-keyword">let</span> timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n        <span class="hljs-keyword">let</span> message_length = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(message_length_tmp));\n        <span class="hljs-keyword">let</span> message_type = <span class="hljs-literal">Some</span>(message_type_bytes[<span class="hljs-number">0</span>]);\n        <span class="hljs-keyword">let</span> message_id = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_le_bytes(message_id_bytes));\n\n        <span class="hljs-literal">Ok</span>(\n            MessageHeader {\n                timestamp,\n                message_length,\n                message_type,\n                message_id\n            }\n        )\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">1</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_type_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">1</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">1</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_length_bytes)?;\n        stream.read(&amp;<span class="hljs-keyword">mut</span> message_type_bytes)?;\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> message_length_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n        message_length_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;message_length_bytes);\n\n        <span class="hljs-keyword">let</span> timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n        <span class="hljs-keyword">let</span> message_length = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(message_length_tmp));\n        <span class="hljs-keyword">let</span> message_type = <span class="hljs-literal">Some</span>(message_type_bytes[<span class="hljs-number">0</span>]);\n\n        <span class="hljs-literal">Ok</span>(\n            MessageHeader {\n                timestamp,\n                message_length,\n                message_type,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        )\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> message_header_format == <span class="hljs-number">2</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> timestamp_bytes)?;\n\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> timestamp_tmp: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        timestamp_tmp[<span class="hljs-number">1</span>..].copy_from_slice(&amp;timestamp_bytes);\n\n        <span class="hljs-keyword">let</span> timestamp = <span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(timestamp_tmp));\n\n        <span class="hljs-literal">Ok</span>(\n            MessageHeader {\n                timestamp,\n                message_length: <span class="hljs-literal">None</span>,\n                message_type: <span class="hljs-literal">None</span>,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        )\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-literal">Ok</span>(\n            MessageHeader {\n                timestamp: <span class="hljs-literal">None</span>,\n                message_length: <span class="hljs-literal">None</span>,\n                message_type: <span class="hljs-literal">None</span>,\n                message_id: <span class="hljs-literal">None</span>\n            }\n        )\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_extended_timestamp</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, timestamp: <span class="hljs-built_in">u32</span>) -&gt; IOResult&lt;<span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;&gt; {\n    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0x00ffffff</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> extended_timestamp_bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">4</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">4</span>];\n\n        stream.read(&amp;<span class="hljs-keyword">mut</span> extended_timestamp_bytes)?;\n        <span class="hljs-literal">Ok</span>(<span class="hljs-literal">Some</span>(<span class="hljs-built_in">u32</span>::from_be_bytes(extended_timestamp_bytes)))\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-literal">Ok</span>(<span class="hljs-literal">None</span>)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_connect</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = decode_amf_data(data, offset)?.number().unwrap();\n    <span class="hljs-keyword">let</span> command_object = decode_amf_data(data, offset)?.object().unwrap();\n\n    <span class="hljs-literal">Ok</span>(\n        Data::Invoke(\n            InvokeCommand::NetConnection(\n                NetConnectionCommand::Connect(\n                    ConnectCommand::Request {\n                        transaction_id,\n                        command_object\n                    }\n                )\n            )\n        )\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_release_stream</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = decode_amf_data(data, offset)?.number().unwrap();\n\n    decode_amf_data(data, offset)?;\n\n    <span class="hljs-keyword">let</span> playpath = decode_amf_data(data, offset)?.string().unwrap();\n\n    <span class="hljs-literal">Ok</span>(\n        Data::Invoke(\n            InvokeCommand::NetConnection(\n                NetConnectionCommand::ReleaseStream(\n                    ReleaseStreamCommand::Request {\n                        transaction_id,\n                        playpath\n                    }\n                )\n            )\n        )\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_fc_publish</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = decode_amf_data(data, offset)?.number().unwrap();\n\n    decode_amf_data(data, offset)?;\n\n    <span class="hljs-keyword">let</span> playpath = decode_amf_data(data, offset)?.string().unwrap();\n\n    <span class="hljs-literal">Ok</span>(\n        Data::Invoke(\n            InvokeCommand::FCPublish(\n                FCPublishCommand::Request {\n                    transaction_id,\n                    playpath\n                }\n            )\n        )\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_create_stream</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = decode_amf_data(data, offset)?.number().unwrap();\n\n    decode_amf_data(data, offset)?;\n\n    <span class="hljs-literal">Ok</span>(\n        Data::Invoke(\n            InvokeCommand::NetConnection(\n                NetConnectionCommand::CreateStream(\n                    CreateStreamCommand::Request {\n                        transaction_id\n                    }\n                )\n            )\n        )\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_publish</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, offset: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">usize</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = decode_amf_data(data, offset)?.number().unwrap();\n\n    decode_amf_data(data, offset)?;\n\n    <span class="hljs-keyword">let</span> publishing_name = decode_amf_data(data, offset)?.string().unwrap();\n    <span class="hljs-keyword">let</span> publishing_type = decode_amf_data(data, offset)?.string().unwrap();\n\n    <span class="hljs-literal">Ok</span>(\n        Data::Invoke(\n            InvokeCommand::NetStream(\n                NetStreamCommand::Publish(\n                    PublishCommand::Request {\n                        transaction_id,\n                        publishing_name,\n                        publishing_type\n                    }\n                )\n            )\n        )\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">decode_invoke</span></span>(data: &amp;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> offset = <span class="hljs-built_in">usize</span>::default();\n    <span class="hljs-keyword">let</span> command_name = decode_amf_data(data, &amp;<span class="hljs-keyword">mut</span> offset)?.string().unwrap();\n\n    <span class="hljs-keyword">if</span> command_name == <span class="hljs-string">"connect"</span> {\n        decode_connect(data, &amp;<span class="hljs-keyword">mut</span> offset)\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> command_name == <span class="hljs-string">"releaseStream"</span> {\n        decode_release_stream(data, &amp;<span class="hljs-keyword">mut</span> offset)\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> command_name == <span class="hljs-string">"FCPublish"</span> {\n        decode_fc_publish(data, &amp;<span class="hljs-keyword">mut</span> offset)\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> command_name == <span class="hljs-string">"createStream"</span> {\n        decode_create_stream(data, &amp;<span class="hljs-keyword">mut</span> offset)\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> command_name == <span class="hljs-string">"publish"</span> {\n        decode_publish(data, &amp;<span class="hljs-keyword">mut</span> offset)\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"unknown command!: {}"</span>, command_name)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_data</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, message_type: <span class="hljs-built_in">u8</span>, message_length: <span class="hljs-built_in">u32</span>) -&gt; IOResult&lt;Data&gt; {\n    <span class="hljs-keyword">let</span> splits = <span class="hljs-keyword">if</span> message_length &lt;= DEFAULT_CHUNK_SIZE {\n        <span class="hljs-number">0</span>\n    } <span class="hljs-keyword">else</span> {\n        message_length / DEFAULT_CHUNK_SIZE + (message_length % DEFAULT_CHUNK_SIZE &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>\n    };\n    <span class="hljs-keyword">let</span> actual_message_length = (message_length + splits) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::with_capacity(actual_message_length);\n\n    <span class="hljs-keyword">unsafe</span> {\n        data_bytes.set_len(actual_message_length);\n    }\n\n    stream.read(data_bytes.as_mut_slice())?;\n\n    <span class="hljs-keyword">if</span> splits &gt; <span class="hljs-number">0</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> split_data: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..splits {\n            <span class="hljs-keyword">let</span> start = <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> {\n                (DEFAULT_CHUNK_SIZE * i) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>\n            } <span class="hljs-keyword">else</span> {\n                (DEFAULT_CHUNK_SIZE * i + <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n            };\n            <span class="hljs-keyword">let</span> end = start + DEFAULT_CHUNK_SIZE <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n\n            split_data.extend_from_slice(&amp;data_bytes[start..end]);\n        }\n\n        data_bytes = split_data;\n    }\n\n    <span class="hljs-keyword">match</span> message_type {\n        <span class="hljs-number">20</span> =&gt; decode_invoke(data_bytes),\n        _ =&gt; <span class="hljs-literal">Ok</span>(Data::Unknown(data_bytes))\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">receive_chunk</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, last_received_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;Chunk&gt; {\n    <span class="hljs-keyword">let</span> basic_header = receive_basic_header(stream)?;\n    <span class="hljs-keyword">let</span> chunk_id = basic_header.get_chunk_id();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_message_header = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span> (<span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> last_message_header) = last_received_chunks.get_mut(&amp;chunk_id) {\n        *last_message_header\n    } <span class="hljs-keyword">else</span> {\n        MessageHeader {\n            timestamp: <span class="hljs-literal">None</span>,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        }\n    };\n    <span class="hljs-keyword">let</span> received_message_header = receive_message_header(stream, basic_header.get_message_header_format())?;\n    <span class="hljs-keyword">let</span> timestamp = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(timestamp) = received_message_header.get_timestamp() {\n        timestamp\n    } <span class="hljs-keyword">else</span> {\n        last_message_header.get_timestamp().unwrap()\n    };\n    <span class="hljs-keyword">let</span> message_length = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = received_message_header.get_message_length() {\n        message_length\n    } <span class="hljs-keyword">else</span> {\n        last_message_header.unwrap().get_message_length().unwrap()\n    };\n    <span class="hljs-keyword">let</span> message_type = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_type) = received_message_header.get_message_type() {\n        message_type\n    } <span class="hljs-keyword">else</span> {\n        last_message_header.get_message_type().unwrap()\n    };\n    <span class="hljs-keyword">let</span> message_id = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_id) = received_message_header.get_message_id() {\n        message_id\n    } <span class="hljs-keyword">else</span> {\n        last_message_header.get_message_id().unwrap()\n    };\n    <span class="hljs-keyword">let</span> extended_timestamp = receive_extended_timestamp(stream, timestamp)?;\n    <span class="hljs-keyword">let</span> data = receive_data(stream, message_type, message_length)?;\n\n    last_message_header.set_timestamp(timestamp);\n    last_message_header.set_message_length(message_length);\n    last_message_header.set_message_type(message_type);\n    last_message_header.set_message_id(message_id);\n    last_received_chunks.insert(chunk_id, last_message_header);\n\n    <span class="hljs-literal">Ok</span>(\n        Chunk {\n            basic_header,\n            message_header,\n            extended_timestamp,\n            data\n        }\n    )\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_basic_header</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, basic_header: BasicHeader) {\n    <span class="hljs-keyword">let</span> message_header_format = basic_header.get_message_header_format();\n    <span class="hljs-keyword">let</span> chunk_id = basic_header.get_chunk_id();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> second_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n    <span class="hljs-keyword">let</span> first_byte = <span class="hljs-keyword">if</span> chunk_id &gt; <span class="hljs-number">319</span> {\n        second_bytes.extend_from_slice(&amp;chunk_id.to_le_bytes());\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | <span class="hljs-number">1</span>\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> chunk_id &gt; <span class="hljs-number">63</span> {\n        second_bytes.push(chunk_id <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | <span class="hljs-number">0</span>\n    } <span class="hljs-keyword">else</span> {\n        (message_header_format &lt;&lt; <span class="hljs-number">6</span>) | chunk_id\n    };\n\n    v.push(first_byte);\n    v.append(&amp;<span class="hljs-keyword">mut</span> second_bytes);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_message_header</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, message_header: MessageHeader) {\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(timestamp) = message_header.get_timestamp() {\n        v.extend_from_slice(&amp;timestamp.to_be_bytes()[<span class="hljs-number">1</span>..]);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = message_header.get_message_length() {\n        v.extend_from_slice(&amp;message_length.to_be_bytes()[<span class="hljs-number">1</span>..]);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_type) = message_header.get_message_type() {\n        v.push(message_type);\n    }\n\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> some(message_id) = message_header.get_message_id() {\n        v.extend_from_slice(&amp;message_id.to_le_bytes());\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_extended_timestamp</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, extended_timestamp: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">u32</span>&gt;) {\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(extended_timestamp) = extended_timestamp {\n        v.extend_from_slice(&amp;extended_timestamp.to_be_bytes());\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_chunk_size</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, chunk_size: <span class="hljs-built_in">u32</span>) {\n    v.extend_from_slice(&amp;chunk_size.to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_ping</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, ping_type: <span class="hljs-built_in">u16</span>, ping_data: PingData) {\n    v.extend_from_slice(&amp;ping_type.to_be_bytes());\n\n    <span class="hljs-keyword">match</span> ping_data {\n        PingData::StreamBegin(message_id) =&gt; v.extend_from_slice(&amp;message_id.to_be_bytes())\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_server_bandwidth</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, server_bandwidth: <span class="hljs-built_in">u32</span>) {\n    v.extend_from_slice(&amp;server_bandwidth.to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_client_bandwidth</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, client_bandwidth: <span class="hljs-built_in">u32</span>, limit: <span class="hljs-built_in">u8</span>) {\n    v.extend_from_slice(&amp;client_bandwidth.to_be_bytes());\n    v.push(limit);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_number</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, number: <span class="hljs-built_in">f64</span>) {\n    v.push(<span class="hljs-number">0</span>);\n    v.extend_from_slice(&amp;number.to_bits().to_be_bytes());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_boolean</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, boolean: <span class="hljs-built_in">bool</span>) {\n    v.push(<span class="hljs-number">1</span>);\n    v.push(boolean <span class="hljs-keyword">as</span> <span class="hljs-built_in">u8</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_string</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, <span class="hljs-keyword">mut</span> string: <span class="hljs-built_in">String</span>) {\n    v.push(<span class="hljs-number">2</span>);\n    v.extend_from_slice(&amp;(string.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n    v.append(string.as_mut_vec());\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_object</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, object: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt;) {\n    v.push(<span class="hljs-number">3</span>);\n\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">mut</span> name, value) <span class="hljs-keyword">in</span> object {\n        v.extend_from_slice(&amp;(name.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u16</span>).to_be_bytes());\n        v.append(name.as_mut_vec());\n        encode_amf_data(v, value);\n    }\n\n    v.extend_from_slice(&amp;[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>]);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_null</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;) {\n    v.push(<span class="hljs-number">5</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_amf_data</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, data: AmfData) {\n    <span class="hljs-keyword">match</span> data {\n        AmfData::Number(number) =&gt; encode_amf_number(v, number),\n        AmfData::Boolean(boolean) =&gt; encode_amf_boolean(v, boolean),\n        AmfData::<span class="hljs-built_in">String</span>(string) =&gt; encode_amf_string(v, string),\n        AmfData::Object(object) =&gt; encode_amf_object(v, object),\n        AmfData::Null =&gt; encode_amf_null(v),\n        <span class="hljs-comment">// まだ上記以外の AMF 型のデータを特定できていないため, 現段階では無視することとする.</span>\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_connect</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, connect_command: ConnectCommand) {\n    <span class="hljs-keyword">match</span> connect_command {\n        Connect::Response {\n            transaction_id,\n            properties,\n            information\n        } =&gt; {\n            encode_amf_string(v, <span class="hljs-string">"_result"</span>.to_string());\n            encode_amf_number(v, transaction_id);\n            encode_amf_object(v, properties);\n            encode_amf_object(v, information);\n        },\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_release_stream</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, release_stream_command: ReleaseStreamCommand) {\n    <span class="hljs-keyword">match</span> release_stream_command {\n        ReleaseStreamCommand::Response {\n            transaction_id\n        } =&gt; {\n            encode_amf_string(v, <span class="hljs-string">"_result"</span>.to_string());\n            encode_amf_number(v, transaction_id);\n            encode_amf_null(v);\n        },\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_create_stream</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, create_stream_command: CreateStreamCommand) {\n    <span class="hljs-keyword">match</span> create_stream_command {\n        CreateStreamCommand::Response {\n            transaction_id,\n            message_id\n        } =&gt; {\n            encode_amf_string(v, <span class="hljs-string">"_result"</span>.to_string);\n            encode_amf_number(v, transaction_id);\n            encode_amf_null(v);\n            encode_amf_number(v, message_id);\n        },\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_net_connection</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, net_connection_command: NetConnectionCommand) {\n    <span class="hljs-keyword">match</span> net_connection_command {\n        Connect(connect_command) =&gt; encode_connect(v, connect_command),\n        ReleaseStream(release_stream_command) =&gt; encode_release_stream(v, release_stream_command),\n        CreateStream(create_stream_command) =&gt; encode_create_stream(v, create_stream_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_fc_publish</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, fc_publish_command: FCPublishCommand) {\n    <span class="hljs-keyword">match</span> fc_publish_command {\n        FCPublishCommand::Response =&gt; encode_amf_string(v, <span class="hljs-string">"onFCPublish"</span>.to_string()),\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_publish</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, publish_command: PublishCommand) {\n    <span class="hljs-keyword">match</span> publish_command {\n        PublishCommand::Response {\n            transaction_id,\n            information\n        } =&gt; {\n            encode_amf_string(v, <span class="hljs-string">"onStatus"</span>.to_string());\n            encode_amf_number(v, transaction_id);\n            encode_amf_null(v);\n            encode_amf_object(v, information);\n        },\n        _ =&gt; {}\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_net_stream</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, net_stream_command: NetStreamCommand) {\n    <span class="hljs-keyword">match</span> net_stream_command {\n        NetStreamCommand::Publish(publish_command) =&gt; encode_publish(v, publish_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_invoke</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, invoke_command: InvokeCommand) {\n    <span class="hljs-keyword">match</span> invoke_command {\n        InvokeCommand::NetConnection(net_connection_command) =&gt; encode_net_connection(v, net_connection_command),\n        InvokeCommand::NetStream(net_stream_command) =&gt; encode_net_stream(v, net_stream_command),\n        InvokeCommand::FCPublish(fc_publish_command) =&gt; encode_fc_publish(v, fc_publish_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_data</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, data: Data) {\n    <span class="hljs-keyword">match</span> data {\n        Data::ChunkSize(chunk_size) =&gt; encode_chunk_size(v, chunk_size),\n        Data::Ping(ping_type, ping_data) =&gt; encode_ping(v, ping_type, ping_data),\n        Data::ServerBandwidth(server_bandwidth) =&gt; encode_server_bandwidth(v, server_bandwidth),\n        Data::ClientBandwidth(client_bandwidth, limit) =&gt; encode_client_bandwidth(v, client_bandwidth, limit),\n        Data::Invoke(invoke_command) =&gt; encode_invoke(v, invoke_command)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">encode_chunk</span></span>(v: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;, chunk: Chunk) {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data_bytes: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_data(&amp;<span class="hljs-keyword">mut</span> data_bytes, chunk.get_data().clone());\n\n    <span class="hljs-keyword">let</span> message_length = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(message_length) = chunk.get_message_header().get_message_length() {\n        message_length\n    } <span class="hljs-keyword">else</span> {\n        data_bytes.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>\n    };\n    <span class="hljs-keyword">let</span> splits = <span class="hljs-keyword">if</span> message_length &lt;= DEFAULT_CHUNK_SIZE {\n        <span class="hljs-number">0</span>\n    } <span class="hljs-keyword">else</span> {\n        message_length / DEFAULT_CHUNK_SIZE + (message_length % DEFAULT_CHUNK != <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>\n    };\n\n    <span class="hljs-keyword">if</span> splits &gt; <span class="hljs-number">0</span> {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> added: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n        <span class="hljs-keyword">let</span> basic_header = BasicHeader {\n            message_header_format: <span class="hljs-number">3</span>,\n            chunk_id: chunk.get_basic_header().get_chunk_id()\n        };\n\n        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..splits {\n            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> {\n                encode_basic_header(&amp;<span class="hljs-keyword">mut</span> added, basic_header);\n            }\n\n            <span class="hljs-keyword">let</span> start = (DEFAULT_CHUNK_SIZE * i) <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;\n            <span class="hljs-keyword">let</span> end = start + min(DEFAULT_CHUNK_SIZE, data_bytes[start..].len());\n\n            added.extend_from_slice(&amp;data_bytes[start..end]);\n        }\n\n        data_bytes = added;\n    }\n\n    encode_basic_header(v, chunk.get_basic_header());\n    encode_message_header(\n        v,\n        MessageHeader {\n            message_length,\n            ..chunk.get_message_header()\n        }\n    );\n    encode_extended_timestamp(v, chunk.get_extended_timestamp());\n    v.append(&amp;<span class="hljs-keyword">mut</span> data_bytes);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_chunk</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, chunk_id: <span class="hljs-built_in">u16</span>, <span class="hljs-keyword">mut</span> timestamp: <span class="hljs-built_in">u32</span>, message_length: <span class="hljs-built_in">u32</span>, message_type: <span class="hljs-built_in">u8</span>, message_id: <span class="hljs-built_in">u32</span>, data: Data, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_message_header = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> last_message_header) = last_sent_chunks.get_mut(&amp;chunk_id) {\n        *last_message_header\n    } <span class="hljs-keyword">else</span> {\n        MessageHeader {\n            timestamp: <span class="hljs-literal">None</span>,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        }\n    };\n    <span class="hljs-keyword">let</span> last_timestamp = last_message_header.get_timestamp().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_length = last_message_header.get_message_length().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_type = last_message_header.get_message_type().unwrap_or_default();\n    <span class="hljs-keyword">let</span> last_message_id = last_message_header.get_message_id().unwrap_or_default();\n    <span class="hljs-keyword">let</span> message_header_format: <span class="hljs-built_in">u8</span> = <span class="hljs-keyword">if</span> message_id == last_message_id {\n        <span class="hljs-keyword">if</span> message_length == last_message_length &amp;&amp; message_type == last_message_type {\n            <span class="hljs-keyword">if</span> timestamp == last_timestamp {\n                <span class="hljs-number">3</span>\n            } <span class="hljs-keyword">else</span> {\n                <span class="hljs-number">2</span>\n            }\n        } <span class="hljs-keyword">else</span> {\n            <span class="hljs-number">1</span>\n        }\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-number">0</span>\n    };\n    <span class="hljs-keyword">let</span> basic_header = BasicHeader {\n        message_header_format,\n        chunk_id\n    };\n    <span class="hljs-keyword">let</span> extended_timestamp = <span class="hljs-keyword">if</span> timestamp &gt;= <span class="hljs-number">0x00ffffff</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span> {\n        <span class="hljs-keyword">let</span> extended_timestamp = <span class="hljs-literal">Some</span>(timestamp);\n\n        timestamp = <span class="hljs-number">0x00ffffff</span>;\n        extended_timestamp\n    } <span class="hljs-keyword">else</span> {\n        <span class="hljs-literal">None</span>\n    };\n    <span class="hljs-keyword">let</span> message_header = <span class="hljs-keyword">match</span> message_header_format {\n        <span class="hljs-number">0</span> =&gt; MessageHeader {\n            timestamp,\n            message_length,\n            message_type,\n            message_id\n        },\n        <span class="hljs-number">1</span> =&gt; MessageHeader {\n            timestamp,\n            message_length,\n            message_type,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        <span class="hljs-number">2</span> =&gt; MessageHeader {\n            timestamp,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        <span class="hljs-number">3</span> =&gt; MessageHeader {\n            timestamp: <span class="hljs-literal">None</span>,\n            message_length: <span class="hljs-literal">None</span>,\n            message_type: <span class="hljs-literal">None</span>,\n            message_id: <span class="hljs-literal">None</span>\n        },\n        n =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"what\'s this!?: {}"</span>, n)\n    };\n    <span class="hljs-keyword">let</span> chunk = Chunk {\n        basic_header,\n        message_header,\n        extended_timestamp,\n        data\n    };\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_chunk(&amp;<span class="hljs-keyword">mut</span> v, chunk);\n    stream.write(v.as_slice()).map(|_| ())\n}\n\n<span class="hljs-comment">/* 送信時のタイムスタンプやメッセージストリーム ID の実際の渡し方については後述する. */</span>\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_chunk_size</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, chunk_size: <span class="hljs-built_in">u32</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">if</span> chunk_size &lt; <span class="hljs-number">1</span> || chunk_size &gt; <span class="hljs-number">0x7fffffff</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(ErrorKind::InvalidData.into());\n    }\n\n    send_chunk(stream, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, Data::ChunkSize(chunk_size), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_stream_begin</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    send_chunk(stream, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, Data::Ping(<span class="hljs-number">1</span>, PingData::StreamBegin(<span class="hljs-number">0</span>)), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_ping</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, ping_type: <span class="hljs-built_in">u16</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">match</span> ping_type {\n        <span class="hljs-number">1</span> =&gt; send_stream_begin(stream, last_sent_chunks),\n        n =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"what\'s this!?: {}"</span>, n)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_server_bandwidth</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, server_bandwidth: <span class="hljs-built_in">u32</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    send_chunk(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, Data::ServerBandwidth(server_bandwidth), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_client_bandwidth</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, client_bandwidth: <span class="hljs-built_in">u32</span>, limit: <span class="hljs-built_in">u8</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    send_chunk(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, Data::ClientBandwidth(client_bandwidth, limit), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_invoke</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, invoke_command: InvokeCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();\n\n    encode_data(&amp;<span class="hljs-keyword">mut</span> v, Data::Invoke(invoke_command.clone()));\n    send_chunk(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, v.len(), <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, Data::Invoke(invoke_command), last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_connect_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, connect_command: ConnectCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = connect_command.get_received_transaction_id().unwrap();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> properties: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n    properties.insert(<span class="hljs-string">"fmsVer"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"FMS/3,0,1,123"</span>.to_string()));\n    properties.insert(<span class="hljs-string">"capabilities"</span>.to_string(), AmfData::Number(<span class="hljs-number">31</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n    information.insert(<span class="hljs-string">"level"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"status"</span>.to_string()));\n    information.insert(<span class="hljs-string">"code"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"NetConnection.Connect.Success"</span>.to_string()));\n    information.insert(<span class="hljs-string">"description"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"Connection succeeded."</span>.to_string()));\n    information.insert(<span class="hljs-string">"objectEncoding"</span>.to_string(), AmfData::Number(<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>));\n\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::NetConnection(\n            NetConnectionCommand::Connect(\n                ConnectCommand::Response {\n                    transaction_id,\n                    properties,\n                    information\n                }\n            )\n        )\n    );\n\n    send_invoke(stream, invoke.clone(), last_sent_chunks)?;\n    send_server_bandwidth(stream, DEFAULT_BANDWIDTH, last_sent_chunks)?;\n    send_client_bandwidth(stream, DEFAULT_BANDWIDTH, last_sent_chunks)?;\n    send_ping(stream, <span class="hljs-number">1</span>, last_sent_chunks)?;\n    send_chunk_size(stream, DEFAULT_CHUNK_SIZE, last_sent_chunks)?;\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_release_stream_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, release_stream_command: ReleaseStreamCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = release_stream_command.get_received_trnasaction_id().unwrap();\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::NetConnection(\n            NetConnectionCommand::ReleaseStream(\n                ReleaseStreamCommand::Response {\n                    transaction_id\n                }\n            )\n        )\n    );\n\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_create_stream_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, create_stream_command: CreateStreamCommand, message_id: <span class="hljs-built_in">f64</span>, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = create_stream_command.get_received_transaction_id().unwrap();\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::NetConnection(\n            NetConnectionCommand::CreateStream(\n                CreateStreamCommand::Response {\n                    transaction_id,\n                    message_id\n                }\n            )\n        )\n    );\n\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_net_connection_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, net_connection_command: NetConnectionCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">match</span> net_connection_command {\n        NetConnectionCommand::Connect(connect_command) =&gt; send_connect_response(stream, connect_command, last_sent_chunks),\n        NetConnectionCommand::ReleaseStream(release_stream_command) =&gt; send_release_stream_response(stream, release_stream_command, last_sent_chunks),\n        NetConnectionCommand::CreateStream(create_stream_command) =&gt; send_create_stream_command(stream, create_stream_command, last_sent_chunks)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_fc_publish_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, fc_publish_command: FCPublishCommand) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = fc_publish_command.get_received_transaction_id().unwrap();\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::FCPublish(\n            FCPublishCommand::Response\n        )\n    );\n\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_publish_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, publish_command: PublishCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> transaction_id = publish_command.get_received_transaction_id().unwrap();\n    <span class="hljs-keyword">let</span> publishing_name = publish_command.get_received_publishing_name().unwrap();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> information: HashMap&lt;<span class="hljs-built_in">String</span>, AmfData&gt; = HashMap::new();\n\n    information.insert(<span class="hljs-string">"level"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"status"</span>.to_string()));\n    information.insert(<span class="hljs-string">"code"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-string">"NetStream.Publish.Start"</span>.to_string()));\n    information.insert(<span class="hljs-string">"description"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">"{} is now published"</span>, publishing_name)));\n    information.insert(<span class="hljs-string">"details"</span>.to_string(), AmfData::<span class="hljs-built_in">String</span>(publishing_name));\n\n    <span class="hljs-keyword">let</span> invoke = Data::Invoke(\n        InvokeCommand::NetStream(\n            NetStreamCommand::Publish(\n                PublishCommand::Response {\n                    transaction_id,\n                    information\n                }\n            )\n        )\n    );\n\n    send_invoke(stream, invoke, last_sent_chunks)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_net_stream_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, net_stream_command: NetStreamCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">match</span> net_stream_command {\n        NetStreamCommand::Publish(publish_command) =&gt; send_publish_response(stream, publish_command, last_sent_chunks)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_invoke_response</span></span>(stream: &amp;<span class="hljs-keyword">mut</span> TcpStream, invoke_command: InvokeCommand, last_sent_chunks: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt;) -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">match</span> invoke_command {\n        InvokeCommand::NetConnection(net_connection_command) =&gt; send_net_connection_response(stream, net_connection_command, last_sent_chunks),\n        InvokeCommand::NetStream(net_stream_command) =&gt; send_net_stream_response(stream, net_stream_command, last_sent_chunks),\n        InvokeCommand::FCPublish(fc_publish_command) =&gt; send_fc_publish_response(stream, fc_publish, last_sent_chunks)\n    }\n}\n\n<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; IOResult&lt;()&gt; {\n    <span class="hljs-keyword">let</span> listener: TcpListener::bind(<span class="hljs-string">"127.0.0.1:1935"</span>)?;\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_received_chunks: HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt; = HashMap::new();\n    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_sent_chunks: HashMap&lt;<span class="hljs-built_in">u16</span>, MessageHeader&gt; = HashMap::new();\n\n    <span class="hljs-keyword">for</span> incoming <span class="hljs-keyword">in</span> listener.incoming() {\n        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = incoming?;\n        <span class="hljs-keyword">let</span> s1 = handle_first_handshake(&amp;<span class="hljs-keyword">mut</span> stream)?;\n\n        handle_second_handshake(&amp;<span class="hljs-keyword">mut</span> stream, s1)?;\n\n        <span class="hljs-keyword">loop</span> {\n            <span class="hljs-keyword">let</span> received_chunk = receive_chunk(&amp;<span class="hljs-keyword">mut</span> stream, &amp;<span class="hljs-keyword">mut</span> last_received_chunks)?;\n\n            <span class="hljs-keyword">match</span> received_chunk.get_data().clone() {\n                Data::Invoke(invoke_command) =&gt; send_invoke_response(&amp;<span class="hljs-keyword">mut</span> stream, invoke_command, &amp;<span class="hljs-keyword">mut</span> last_sent_chunks)?,\n                _ =&gt; {}\n            }\n        }\n    }\n}\n</code></pre>\n<p>次回は Notify チャンクを処理する方法と, Audio/Video チャンクをデコードする方法について記していく.</p>\n<h2 id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><a class="header-anchor" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">¶</a> 参考文献</h2>\n<hr class="footnotes-sep">\n<section class="footnotes">\n<ol class="footnotes-list">\n<li id="fn1" class="footnote-item"><p>Adobe Systems Inc., “RTMP Specification 1.0”, <a href="http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/rtmp/pdf/rtmp_specification_1.0.pdf">http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/rtmp/pdf/rtmp_specification_1.0.pdf</a> <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a> <a href="#fnref1:2" class="footnote-backref">↩︎</a></p>\n</li>\n</ol>\n</section>\n'}),head(){return{title:this.title,meta:[{hid:"description",name:"description",content:this.description},{hid:"title",property:"og:title",content:this.title},{hid:"og:description",property:"og:description",content:this.description},{hid:"url",property:"og:url",content:"https://t-matsudate.github.io/rtmp-reports/articles/connection-implementation"},{hid:"type",property:"og:type",content:"article"},{hid:"published_time",property:"og:article:published_time",content:this.published},{hid:"section",property:"og:article:section",content:"Implementation"},{hid:"author",property:"og:article:author",content:this.author},{hid:"tag1",property:"og:article:tag",content:"RTMP"},{hid:"tag2",property:"og:article:tag",content:"実装"},{hid:"tag3",property:"og:article:tag",content:"Rust"}]}}},o=(e(121),e(2)),component=Object(o.a)(m,(function(){var n=this,l=n.$createElement,e=n._self._c||l;return e("article",{attrs:{id:"report"}},[e("Author",{attrs:{author:n.author,published:n.published}}),n._v(" "),e("ReportTitle",{attrs:{"report-title":n.title}}),n._v(" "),e("Markdown",{attrs:{source:n.source}}),n._v(" "),e("ShareButtons",{attrs:{text:n.title,path:n.$route.path}})],1)}),[],!1,null,null,null);l.default=component.exports},35:function(n,l,e){var t=e(6),content=e(41);"string"==typeof(content=content.__esModule?content.default:content)&&(content=[[n.i,content,""]]);var c={insert:"head",singleton:!1},h=(t(content,c),content.locals?content.locals:{});n.exports=h},36:function(n,l,e){var t=e(6),content=e(43);"string"==typeof(content=content.__esModule?content.default:content)&&(content=[[n.i,content,""]]);var c={insert:"head",singleton:!1},h=(t(content,c),content.locals?content.locals:{});n.exports=h},38:function(n,l,e){var t=e(6),content=e(48);"string"==typeof(content=content.__esModule?content.default:content)&&(content=[[n.i,content,""]]);var c={insert:"head",singleton:!1},h=(t(content,c),content.locals?content.locals:{});n.exports=h},40:function(n,l,e){"use strict";var t=e(35);e.n(t).a},41:function(n,l,e){(l=e(5)(!1)).push([n.i,"#grids #main main article #author {\n  text-align: right;\n}\n#grids #main main article #author .datetime {\n  list-style: none;\n}\n#grids #main main article #author .datetime .published,\n#grids #main main article #author .datetime .modified {\n  font-family: sans-serif;\n}\n#grids #main main article #author .datetime .published time,\n#grids #main main article #author .datetime .modified time {\n  font-family: sans-serif;\n}\n",""]),n.exports=l},42:function(n,l,e){"use strict";var t=e(36);e.n(t).a},43:function(n,l,e){(l=e(5)(!1)).push([n.i,"#grids #main main article #report-title {\n  padding: 1em;\n  text-align: center;\n  font-size: 200%;\n  font-style: normal;\n  font-weight: bold;\n  font-family: sans-serif;\n}\n",""]),n.exports=l},44:function(n,l,e){"use strict";var t={props:{author:{type:String,required:!0},published:{type:String,required:!0,validator:n=>!isNaN(new Date(n))},modified:{type:String,validator:n=>!isNaN(new Date(n))}}},c=(e(40),e(2)),component=Object(c.a)(t,(function(){var n=this,l=n.$createElement,e=n._self._c||l;return e("p",{attrs:{id:"author"}},[n._v("\n  "+n._s(n.author)+"\n  "),e("ul",{staticClass:"datetime"},[n.modified?e("li",{staticClass:"modified"},[n._v("更新日: "),e("time",{attrs:{datetime:n.modified}},[n._v(n._s(n.modified))])]):n._e(),n._v(" "),e("li",{staticClass:"published"},[n._v("投稿日: "),e("time",{attrs:{datetime:n.published}},[n._v(n._s(n.published))])])])])}),[],!1,null,null,null);l.a=component.exports},45:function(n,l,e){"use strict";var t={props:{reportTitle:{type:String,required:!0}}},c=(e(42),e(2)),component=Object(c.a)(t,(function(){var n=this.$createElement;return(this._self._c||n)("h1",{attrs:{id:"report-title"}},[this._v(this._s(this.reportTitle))])}),[],!1,null,null,null);l.a=component.exports},46:function(n,l,e){"use strict";var t={props:{text:{type:String,required:!0},path:{type:String,required:!0}},computed:{url(){return"https://t-matsudate.github.io/rtmp-reports"+this.path}}},c=e(2),component=Object(c.a)(t,(function(){var n=this.$createElement,l=this._self._c||n;return l("div",{attrs:{id:"share-buttons"}},[l("a",{staticClass:"twitter-share-button",attrs:{href:"https://twitter.com/share?ref_src=twsrc%5Etfw","data-text":this.text,"data-url":this.url,"data-show-count":"true"}},[this._v("Tweet")])])}),[],!1,null,null,null);l.a=component.exports},47:function(n,l,e){"use strict";var t=e(38);e.n(t).a},48:function(n,l,e){var t=e(5),c=e(54),h=e(55),r=e(56);(l=t(!1)).i(c),l.i(h),l.i(r),l.push([n.i,"#grids #main main article {\n  padding: 1em;\n}\n#grids #main main article .markdown-body,\n#grids #main main article #grids #main main article {\n  font-family: serif;\n}\n#grids #main main article .markdown-body strong,\n#grids #main main article #grids #main main article strong {\n  font-weight: bold;\n}\n#grids #main main article .markdown-body em,\n#grids #main main article #grids #main main article em {\n  font-style: italic;\n}\n#grids #main main article .markdown-body .footnotes,\n#grids #main main article #grids #main main article .footnotes {\n  word-break: break-word;\n}\n#grids #main main article .markdown-body .hljs,\n#grids #main main article #grids #main main article .hljs {\n  /* 4K */\n  /* WQHD */\n  /* Desktop or Laptop (Full HD) */\n  /* iPad (up to 12 inchs) */\n  /* iPhone (up to X) */\n  /* Android (based on Pixel XL) */\n}\n@media (orientation: landscape) and (max-width: 3840px) {\n#grids #main main article .markdown-body .hljs,\n  #grids #main main article #grids #main main article .hljs {\n    max-width: 3340.8px;\n}\n}\n@media (orientation: portrait) and (max-width: 2160px) {\n#grids #main main article .markdown-body .hljs,\n  #grids #main main article #grids #main main article .hljs {\n    max-width: 1879.2px;\n}\n}\n@media (orientation: landscape) and (max-width: 2560px) {\n#grids #main main article .markdown-body .hljs,\n  #grids #main main article #grids #main main article .hljs {\n    max-width: 2227.2px;\n}\n}\n@media (orientation: portrait) and (max-width: 1440px) {\n#grids #main main article .markdown-body .hljs,\n  #grids #main main article #grids #main main article .hljs {\n    max-width: 1252.8px;\n}\n}\n@media (orientation: landscape) and (max-width: 1920px) {\n#grids #main main article .markdown-body .hljs,\n  #grids #main main article #grids #main main article .hljs {\n    max-width: 1670.4px;\n}\n}\n@media (orientation: portrait) and (max-width: 1080px) {\n#grids #main main article .markdown-body .hljs,\n  #grids #main main article #grids #main main article .hljs {\n    max-width: 939.6px;\n}\n}\n@media (orientation: landscape) and (max-width: 1366px) {\n#grids #main main article .markdown-body .hljs,\n  #grids #main main article #grids #main main article .hljs {\n    max-width: 1188.42px;\n}\n}\n@media (orientation: portrait) and (max-width: 1024px) {\n#grids #main main article .markdown-body .hljs,\n  #grids #main main article #grids #main main article .hljs {\n    max-width: 890.88px;\n}\n}\n@media (orientation: landscape) and (max-width: 812px) {\n#grids #main main article .markdown-body .hljs,\n  #grids #main main article #grids #main main article .hljs {\n    max-width: 706.44px;\n}\n}\n@media (orientation: portrait) and (max-width: 375px) {\n#grids #main main article .markdown-body .hljs,\n  #grids #main main article #grids #main main article .hljs {\n    max-width: 326.25px;\n}\n}\n@media (orientation: landscape) and (max-width: 640px) {\n#grids #main main article .markdown-body .hljs,\n  #grids #main main article #grids #main main article .hljs {\n    max-width: 556.8px;\n}\n}\n@media (orientation: portrait) and (max-width: 360px) {\n#grids #main main article .markdown-body .hljs,\n  #grids #main main article #grids #main main article .hljs {\n    max-width: 313.2px;\n}\n}\n",""]),n.exports=l},49:function(n,l,e){var t=e(6),content=e(122);"string"==typeof(content=content.__esModule?content.default:content)&&(content=[[n.i,content,""]]);var c={insert:"head",singleton:!1},h=(t(content,c),content.locals?content.locals:{});n.exports=h},53:function(n,l,e){"use strict";var t={props:{source:{type:String,required:!0}},mounted(){let n=document.getElementsByTagName("h1")[1].innerHTML,menu=document.getElementById("menu-list").getElementsByTagName("li");for(let i=0;i<menu.length;i++)if(menu[i].getElementsByTagName("a")[0].innerHTML===n){menu[i].id="current-article",document.getElementById("app-title").innerHTML=n;break}let l=document.getElementById("submenu");if(null===l){let n=document.getElementsByClassName("table-of-contents")[0],menu=document.getElementById("menu"),l=document.createElement("div"),nav=document.createElement("nav");l.id="submenu",nav.innerHTML=n.innerHTML,l.appendChild(nav),menu.appendChild(l),n.outerHTML=null}else{let n=document.getElementsByClassName("table-of-contents")[0];l.getElementsByTagName("nav")[0].innerHTML=n.innerHTML,n.outerHTML=null}},destroyed(){let menu=document.getElementById("menu-list").getElementsByTagName("li");for(let i=0;i<menu.length;i++)menu[i].id&&menu[i].removeAttribute("id");document.getElementById("submenu").outerHTML=null,document.getElementById("app-title").innerHTML="RTMP Implementation Reports"}},c=(e(47),e(2)),component=Object(c.a)(t,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"markdown-body",domProps:{innerHTML:this._s(this.source)}})}),[],!1,null,null,null);l.a=component.exports}}]);