(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{130:function(n,t,e){"use strict";var r=e(45);e.n(r).a},131:function(n,t,e){(t=e(5)(!1)).push([n.i,"#grids #main main #report {\n  padding: 1em;\n  font-family: serif;\n}\n#grids #main main #report strong {\n  font-weight: bold;\n}\n#grids #main main #report em {\n  font-style: italic;\n}\n#grids #main main #report .footnotes {\n  word-break: break-word;\n}\n#grids #main main #report .hljs {\n  /* 4K */\n  /* WQHD */\n  /* Desktop or Laptop (Full HD) */\n  /* iPad (up to 12 inchs) */\n  /* iPhone (up to X) */\n  /* Android (based on Pixel XL) */\n}\n@media (orientation: landscape) and (max-width: 3840px) {\n#grids #main main #report .hljs {\n    max-width: 3072px;\n}\n}\n@media (orientation: portrait) and (max-width: 2160px) {\n#grids #main main #report .hljs {\n    max-width: 1728px;\n}\n}\n@media (orientation: landscape) and (max-width: 2560px) {\n#grids #main main #report .hljs {\n    max-width: 2048px;\n}\n}\n@media (orientation: portrait) and (max-width: 1440px) {\n#grids #main main #report .hljs {\n    max-width: 1152px;\n}\n}\n@media (orientation: landscape) and (max-width: 1920px) {\n#grids #main main #report .hljs {\n    max-width: 1536px;\n}\n}\n@media (orientation: portrait) and (max-width: 1080px) {\n#grids #main main #report .hljs {\n    max-width: 864px;\n}\n}\n@media (orientation: landscape) and (max-width: 1366px) {\n#grids #main main #report .hljs {\n    max-width: 1092px;\n}\n}\n@media (orientation: portrait) and (max-width: 1024px) {\n#grids #main main #report .hljs {\n    max-width: 819px;\n}\n}\n@media (orientation: landscape) and (max-width: 812px) {\n#grids #main main #report .hljs {\n    max-width: 649px;\n}\n}\n@media (orientation: portrait) and (max-width: 375px) {\n#grids #main main #report .hljs {\n    max-width: 300px;\n}\n}\n@media (orientation: landscape) and (max-width: 640px) {\n#grids #main main #report .hljs {\n    max-width: 512px;\n}\n}\n@media (orientation: portrait) and (max-width: 360px) {\n#grids #main main #report .hljs {\n    max-width: 288px;\n}\n}\n#grids #main main article .markdown-body #rtmp-connection-flows,\n#grids #main main article .markdown-body #rtmp-handshake-sequences-official,\n#grids #main main article .markdown-body #rtmp-handshake-sequences-current,\n#grids #main main article .markdown-body #rtmp-application-connect-sequences,\n#grids #main main article .markdown-body #rtmp-invoke-connect-sequences-official,\n#grids #main main article .markdown-body #rtmp-invoke-connect-sequences-ffmpeg,\n#grids #main main article .markdown-body #rtmp-invoke-connect-sequences-fixed,\n#grids #main main article .markdown-body #rtmp-invoke-publish-sequences-official,\n#grids #main main article .markdown-body #rtmp-invoke-publish-sequences-ffmpeg,\n#grids #main main article .markdown-body #rtmp-connection-seqeunces-current {\n  text-align: center;\n}\n#grids #main main article .markdown-body #caption-rtmp-connection-flows,\n#grids #main main article .markdown-body #caption-rtmp-handshake-sequnces-official,\n#grids #main main article .markdown-body #caption-rtmp-handshake-sequences-current,\n#grids #main main article .markdown-body #caption-rtmp-application-connect-sequences,\n#grids #main main article .markdown-body #caption-rtmp-invoke-connect-sequences-official,\n#grids #main main article .markdown-body #caption-rtmp-invoke-connect-sequences-ffmpeg,\n#grids #main main article .markdown-body #caption-rtmp-invoke-connect-sequences-fixed,\n#grids #main main article .markdown-body #caption-rtmp-invoke-publish-sequences-official,\n#grids #main main article .markdown-body #caption-rtmp-invoke-publish-sequences-ffmpeg,\n#grids #main main article .markdown-body #caption-rtmp-connection-sequences-current {\n  text-align: center;\n}\n",""]),n.exports=t},134:function(n,t,e){"use strict";e.r(t);var r=e(47),l=e(48),o={props:{source:{type:String,required:!0}},mounted(){let n=document.getElementsByClassName("table-of-contents"),menu=document.getElementById("menu"),t=document.createElement("div"),nav=document.createElement("nav");t.id="submenu",nav.innerHTML=n[0].innerHTML,t.appendChild(nav),menu.appendChild(t);for(let i=0;i<n.length;i++)n[i].innerHTML=null}},d=(e(53),e(2)),c=Object(d.a)(o,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"markdown-body",domProps:{innerHTML:this._s(this.source)}})}),[],!1,null,null,null).exports,m=e(49),h=e(119),f=e.n(h),_={components:{Author:r.a,ReportTitle:l.a,Markdown:c,ShareButtons:m.a},data:()=>({author:"T.Matsudate",published:"2019-09-09",modified:"2020-01-04",title:"RTMP の概要",description:"RTMP とは何か. 基本的な通信手順は何か. 既存製品はどのように通信しているか. 私達はそれらの製品とどのように通信していけばよいか.",source:'<p><div class="table-of-contents"><ul><li><a href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB">はじめに</a></li><li><a href="#rtmp-%E3%81%A8%E3%81%AF">RTMP とは</a><ul><li><a href="#%E5%BD%93%E8%A9%B2%E3%83%97%E3%83%AD%E3%83%88%E3%82%B3%E3%83%AB%E3%82%92%E6%8E%A1%E7%94%A8%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E8%A3%BD%E5%93%81(oss)">当該プロトコルを採用している製品(OSS)</a></li></ul></li><li><a href="#rtmp-%E6%8E%A5%E7%B6%9A%E3%81%AE%E6%89%8B%E9%A0%86">RTMP 接続の手順</a><ul><li><a href="#rtmp-%E3%83%8F%E3%83%B3%E3%83%89%E3%82%B7%E3%82%A7%E3%82%A4%E3%82%AF">RTMP ハンドシェイク</a><ul><li><a href="#c0-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%8A%E3%82%88%E3%81%B3-s0-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF">C0 チャンクおよび S0 チャンク</a></li><li><a href="#c1-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%8A%E3%82%88%E3%81%B3-s1-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF">C1 チャンクおよび S1 チャンク</a></li><li><a href="#c2-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%8A%E3%82%88%E3%81%B3-s2-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF">C2 チャンクおよび S2 チャンク</a></li></ul></li><li><a href="#invoke(connect)-%E3%81%8B%E3%82%89%E6%98%A0%E5%83%8F%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E5%8F%97%E4%BF%A1%E3%81%BE%E3%81%A7">Invoke(connect) から映像データの受信まで</a><ul><li><a href="#%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E6%A7%8B%E9%80%A0">メッセージチャンクの構造</a><ul><li><a href="#%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E7%A8%AE%E9%A1%9E">メッセージの種類</a></li><li><a href="#user-control-message-%E3%81%AE%E7%A8%AE%E9%A1%9E%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF">User Control Message の種類とデータ</a></li><li><a href="#metadata-%E3%81%AE%E6%A7%8B%E9%80%A0">Metadata の構造</a></li></ul></li><li><a href="#invoke(connect)">Invoke(connect)</a></li><li><a href="#invoke(releasestream)%2C-invoke(fcpublish)%2C-invoke(createstream)">Invoke(releaseStream), Invoke(FCPublish), Invoke(createStream)</a></li><li><a href="#invoke(publish)">Invoke(publish)</a></li></ul></li><li><a href="#%E7%8F%BE%E5%9C%A8%E3%81%AE-rtmp-%E6%8E%A5%E7%B6%9A%E3%81%AE%E6%B5%81%E3%82%8C">現在の RTMP 接続の流れ</a></li><li><a href="#%E3%83%91%E3%82%B1%E3%83%83%E3%83%88%E3%81%AE%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%83%E3%83%88">パケットのメッセージフォーマット</a><ul><li><a href="#amf0">AMF0</a></li><li><a href="#amf3">AMF3</a><ul><li><a href="#integer-%E5%9E%8B%2C-%E9%95%B7%E3%81%95%2C-%E8%A6%81%E7%B4%A0%E3%81%AE%E7%B7%8F%E6%95%B0">Integer 型, 長さ, 要素の総数</a></li><li><a href="#%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%81%AE%E3%83%90%E3%82%A4%E3%83%8A%E3%83%AA%2C-%E3%83%A1%E3%83%B3%E3%83%90%E3%81%AE%E7%B7%8F%E6%95%B0%2C-%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%81%AE%E5%8F%82%E7%85%A7">トレイトのバイナリ, メンバの総数, トレイトの参照</a></li></ul></li></ul></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">参考文献</a></li></ul></div></p>\n<h2 id="%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB"><a class="header-anchor" href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB">¶</a> はじめに</h2>\n<p>私は <abbr title="Real-Time Messaging Protocol">RTMP</abbr> サーバを実装するにあたって, まず Adobe Systems Inc. が公式に発行しているドキュメントや既存の <abbr title="Open Source Software">OSS</abbr> 製品を参照した. しかし, それらには以下の問題があることがわかった.</p>\n<ul>\n<li>公式のドキュメントが 2012 年発行のものと古く, 既存製品の最新の通信手順/通信内容からかけ離れてきている.\n<ul>\n<li>ブログ等の既出の実装記事/解説記事についても, 時と共に最新の実装や仕様からはかけ離れてしまうという問題がある.</li>\n</ul>\n</li>\n<li>既存製品(<abbr title="Open Source Software">OSS</abbr> 製品等目視確認できる範囲に限る)についても実装箇所を整理しにくい部分がある.</li>\n<li>また, 既存製品は用いたプログラミング言語やフレームワークによって実装内容に差異があり, プロトコルで共通化されている部分なのか製品側が独自に実装している部分なのかの区別をつけにくいことがある.</li>\n</ul>\n<p>上記を解消する方法の一つとして, 私は自分自身で実装を行いながら, 当該プロトコルのサーバサイド/クライアントサイド両面の概要, 処理手順, 実装内容, およびそれらを解説する情報を随時更新していこうと考えた.</p>\n<h2 id="rtmp-%E3%81%A8%E3%81%AF"><a class="header-anchor" href="#rtmp-%E3%81%A8%E3%81%AF">¶</a> <abbr title="Real-Time Messaging Protocol">RTMP</abbr> とは</h2>\n<p><abbr title="Real-Time Messaging Protocol">RTMP</abbr> とは, <abbr title="Transmission Control Protocol">TCP</abbr> 上で映像や音声の送受信を行うプロトコルの 1 つである. Adobe Systems Inc. によって, 当時の Flash Player および Adobe Media Server 間で帯域の圧迫を避けながら映像/音声パケットを効率よく送受信するためのパケットのフォーマットおよび当該パケットの送受信手順について取り決められている.<br>\nまた,  <abbr title="Real-Time Messaging Protocol">RTMP</abbr> には同じ手段で通信するものとして以下のような派生プロトコルも存在している.</p>\n<ul>\n<li><abbr title="Real-Time Messaging Protocol Encrypted">RTMPE</abbr>: 送信側が <abbr title="Real-Time Messaging Protocol">RTMP</abbr> のハンドシェイクパケットを <abbr title="Diffie-Hellman">DH</abbr> 暗号により暗号化してから通信を行うプロトコルである. ただし, あくまでパケットの暗号化であり通信経路自体は保護されていないため, 中間者攻撃等によりパケットごとすり替えられる脆弱性が存在する.</li>\n<li><abbr title="Real-Time Messaging Protocol over TLS/SSL">RTMPS</abbr>: <abbr title="Real-Time Messaging Protocol">RTMP</abbr> に <abbr title="Transport Layer Security">TLS</abbr>/<abbr title="Secure Socket Layer">SSL</abbr> による暗号化および接続手順を合成したプロトコルである. <abbr title="Transport Layer Security">TLS</abbr>/<abbr title="Secure Socket Layer">SSL</abbr> の証明書を付随させることにより、中間者攻撃等の被害を受けるリスクは軽減されている.</li>\n<li><abbr title="Real-Time Messaging Protocol over HTTP">RTMPT</abbr>/<abbr title="Real-Time Messaging Protocol Encrypted over HTTP">RTMPTE</abbr>/<abbr title="Real-Time Messaging Protocol over HTTPS">RTMPTS</abbr>: <abbr title="Real-Time Messaging Protocol">RTMP</abbr>/<abbr title="Real-Time Messaging Protocol Encrypted">RTMPE</abbr> の通信を <abbr title="Hyper Text Transfer Protocol">HTTP</abbr>/<abbr title="HTTP over SSL">HTTPS</abbr> 上で行うプロトコルである. これらは <abbr title="Real-Time Messaging Protocol">RTMP</abbr> に依存しない各種マネージドサービスとの連携による負荷分散が可能であり, 特に <abbr title="Real-Time Messaging Protocol over HTTPS">RTMPTS</abbr> は <abbr title="HTTP over SSL">HTTPS</abbr> によって通信経路が保護されているため, <abbr title="Real-Time Messaging Protocol">RTMP</abbr>/<abbr title="Real-Time Messaging Protocol Encrypted">RTMPE</abbr> はもとより <abbr title="Real-Time Messaging Protocol over TLS/SSL">RTMPS</abbr> と比べてもセキュリティの信頼性が高いプロトコルと言える.</li>\n</ul>\n<p><abbr title="Real-Time Messaging Protocol">RTMP</abbr> および上記派生プロトコルのいずれも本質的には</p>\n<ol>\n<li>当該プロトコルとしてのハンドシェイクを成立させる.</li>\n<li>アプリケーション間接続に必要な情報を相互に伝達しあう.</li>\n<li>単位あたりのデータ量を帯域を圧迫しない程度に抑えつつ, 映像/音声データの送受信を行う.</li>\n</ol>\n<p>の 3 つの要件が大前提である. また, 上記 3 要件を満たせればよいことから, 近年では SIP 等の通話向けプロトコルの代替としての採用も確認され始めている.</p>\n<h3 id="%E5%BD%93%E8%A9%B2%E3%83%97%E3%83%AD%E3%83%88%E3%82%B3%E3%83%AB%E3%82%92%E6%8E%A1%E7%94%A8%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E8%A3%BD%E5%93%81(oss)"><a class="header-anchor" href="#%E5%BD%93%E8%A9%B2%E3%83%97%E3%83%AD%E3%83%88%E3%82%B3%E3%83%AB%E3%82%92%E6%8E%A1%E7%94%A8%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E8%A3%BD%E5%93%81(oss)">¶</a> 当該プロトコルを採用している製品(<abbr title="Open Source Software">OSS</abbr>)</h3>\n<ul>\n<li><a href="https://github.com/Red5/red5-server/">Red5</a></li>\n</ul>\n<p>Java 言語で実装されたマルチメディアサーバである. <abbr title="Real-Time Messaging Protocol">RTMP</abbr> を始め <abbr title="HTTP Live Streaming">HLS</abbr> による <abbr title="MPEG2 Transport Straming">MPEG2-TS</abbr> の転送や WebSocket を利用したコミュニケーションにも対応している. 有償ではあるがより高度な機能を搭載した Pro 版も存在している.</p>\n<ul>\n<li><a href="https://github.com/FFmpeg/FFmpeg/">FFmpeg</a></li>\n</ul>\n<p>動画や音声のエンコーダソフトである. C 言語で実装されている. 本来は動画や音声の変換がメインであるが, <abbr title="Real-Time Messaging Protocol">RTMP</abbr> の登場に合わせて当該プロトコルでの外部サーバへの映像データの送信に対応した.<br>\nまた, ffserver というパッケージを導入することによってサーバとしての動きにも対応可能である.</p>\n<ul>\n<li><a href="https://github.com/obsproject/obs-studio/"><abbr title="Open Broadcaster Software">OBS</abbr></a></li>\n</ul>\n<p>クライアントとしての映像/音声の配置や送信に注力したソフトウェアである. C 言語で実装されている. Windows を始め MacOS や Linux 等各種 OS に対してそれぞれパッケージが用意されているため, マルチプラットフォームと言っても差し支えないと思われる.</p>\n<h2 id="rtmp-%E6%8E%A5%E7%B6%9A%E3%81%AE%E6%89%8B%E9%A0%86"><a class="header-anchor" href="#rtmp-%E6%8E%A5%E7%B6%9A%E3%81%AE%E6%89%8B%E9%A0%86">¶</a> <abbr title="Real-Time Messaging Protocol">RTMP</abbr> 接続の手順</h2>\n<div id="rtmp-connection-flows"></div>\n<p id="caption-rtmp-connection-flows">図1. RTMPの大まかな流れ</p>\n<ol>\n<li>サーバ側は <abbr title="Transmission Control Protocol">TCP</abbr> の 1935 番ポートを開放し, クライアント側からの接続を待ち受ける.</li>\n<li>クライアント側はサーバ側に <abbr title="Transmission Control Protocol">TCP</abbr> での接続を受理されたなら, <abbr title="Transmission Control Protocol">TCP</abbr> ハンドシェイクの後に <abbr title="Real-Time Messaging Protocol">RTMP</abbr> 層でのハンドシェイクを行う.<br>\n(<abbr title="Transmission Control Protocol">TCP</abbr> パケットの受信方法や <abbr title="Transmission Control Protocol">TCP</abbr> ハンドシェイクの実装がまだである場合は, それも行う必要がある.)</li>\n<li>クライアント側はサーバ側に送信したハンドシェイクチャンクが妥当であると判断されたなら, <abbr title="Real-Time Messaging Protocol">RTMP</abbr> 層でのアプリケーション接続を開始する.</li>\n<li>アプリケーション接続に成功したなら, サーバ側はクライアント側とやり取りするメッセージストリームに一意に ID を割り当てる.</li>\n<li>映像/音声チャンクの送受信を開始する.</li>\n</ol>\n<h3 id="rtmp-%E3%83%8F%E3%83%B3%E3%83%89%E3%82%B7%E3%82%A7%E3%82%A4%E3%82%AF"><a class="header-anchor" href="#rtmp-%E3%83%8F%E3%83%B3%E3%83%89%E3%82%B7%E3%82%A7%E3%82%A4%E3%82%AF">¶</a> <abbr title="Real-Time Messaging Protocol">RTMP</abbr> ハンドシェイク</h3>\n<p><abbr title="Real-Time Messaging Protocol">RTMP</abbr> ハンドシェイクの手順は公式ドキュメント<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>では以下のように定義されている.</p>\n<div id="rtmp-handshake-sequences-official">\n<a href="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuRArLNWsPzNJZhdFvin_sZDDmTQMopadCpMlH47NJi4ljQGyloZRIi7PW0lA1Wa7fnQLfHQ1HR6fDUJAooz9LSX9JIlXKW22e13V08N7pHCUD-zvtBJZSVFonysR7pVsWELUDZG-sR_mSUFKnqqzZnldwt6bvgKeWBHpGIn1CJdO0AierBwYpFGCIYn4yY34Ls0BiOaQOWqCGwo1OOJLoKQWS7_HjFxfkbbFzyzvldOAq7deBWD51JRRZR3Q3ZRnSNC_oAlDdO-RjZzkMlwuQSdZflL0ev-kwtcog-rnutIOkGv0NmDZ7m00" target="_self"><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuRArLNWsPzNJZhdFvin_sZDDmTQMopadCpMlH47NJi4ljQGyloZRIi7PW0lA1Wa7fnQLfHQ1HR6fDUJAooz9LSX9JIlXKW22e13V08N7pHCUD-zvtBJZSVFonysR7pVsWELUDZG-sR_mSUFKnqqzZnldwt6bvgKeWBHpGIn1CJdO0AierBwYpFGCIYn4yY34Ls0BiOaQOWqCGwo1OOJLoKQWS7_HjFxfkbbFzyzvldOAq7deBWD51JRRZR3Q3ZRnSNC_oAlDdO-RjZzkMlwuQSdZflL0ev-kwtcog-rnutIOkGv0NmDZ7m00" alt=""></a></div>\n<p id="caption-rtmp-handshake-sequences-official">図2. 公式ドキュメントが説明している <abbr title="Real-Time Messaging Protocol">RTMP</abbr> ハンドシェイクのシーケンス</p>\n<blockquote>\n<p>5.2.1.  Handshake Sequence</p>\n<p>The handshake begins with the client sending the C0 and C1 chunks.</p>\n<p>The client MUST wait until S1 has been received before sending C2.\nThe client MUST wait until S2 has been received before sending any other data.</p>\n<p>The server MUST wait until C0 has been received before sending S0 and S1, and MAY wait until after C1 as well.\nThe server MUST wait until C1 has been received before sending S2.\nThe server MUST wait until C2 has been received before sending any other data.</p>\n</blockquote>\n<ul>\n<li>ハンドシェイクはクライアント側がサーバ側に C0 チャンクと C1 チャンクを送信することで始まる.</li>\n<li>クライアント側は C2 チャンクの送信前に S1 の受信を待た<strong>なければならない</strong>.</li>\n<li>クライアント側はその後の他のチャンクの送信前に S2 チャンクの受信を待た<strong>なければならない</strong>.</li>\n<li>サーバ側は S2 チャンクの送信前に C1 チャンクの受信を待た<strong>なければならない</strong>.</li>\n<li>サーバ側はその後の他のチャンクの送信前に C2 チャンクの受信を待た<strong>なければならない</strong>.</li>\n</ul>\n<blockquote>\n<p>The following describes the states mentioned in the handshake diagram:</p>\n<p>Uninitialized: The protocol version is sent during this stage. Both the client and server are uninitialized. The The client sends the protocol version in packet C0. If the server supports the version, it sends S0 and S1 in response. If not, the server responds by taking the appropriate action. In <abbr title="Real-Time Messaging Protocol">RTMP</abbr>, this action is terminating the connection.<br>\nVersion Sent:  Both client and server are in the Version Sent state after the Uninitialized state. The client is waiting for the packet S1 and the server is waiting for the packet C1. On receiving the awaited packets, the client sends the packet C2 and the server sends the packet S2. The state then becomes Ack Sent.<br>\nAck Sent: The client and the server wait for S2 and C2 respectively.<br>\nHandshake Done: The client and the server exchange messages.</p>\n</blockquote>\n<ul>\n<li>未初期化</li>\n</ul>\n<p>プロトコルのバージョンが送信される. クライアント側もサーバ側も未初期化である. クライアント側はプロトコルのバージョンを C0 パケットで送信する. サーバ側はそのバージョンをサポートしているならば, クライアント側に応答メッセージで S0 パケットと S1 パケットを送信する. そうでなければ, サーバ側は適切なアクションをとって応答メッセージを送信する. <abbr title="Real-Time Messaging Protocol">RTMP</abbr> では, そのアクションは接続の終了である.</p>\n<ul>\n<li><abbr title="Real-Time Messaging Protocol">RTMP</abbr> バージョンが送信された</li>\n</ul>\n<p>サーバ側もクライアント側も未初期化状態の後は <abbr title="Real-Time Messaging Protocol">RTMP</abbr> バージョンが送信された状態である. クライアント側は S1 パケットを待ちサーバ側は C1 パケットを待つ. 待機パケットの受信時に, クライアント側はサーバ側に C2 パケットを送信し, サーバ側はクライアント側に S2 パケットを送信する. それから肯定応答が送信された状態になる.</p>\n<ul>\n<li>肯定応答が送信された</li>\n</ul>\n<p>クライアント側とサーバ側はそれぞれ S2 と C2 を待つ.</p>\n<ul>\n<li>ハンドシェイクが完了した</li>\n</ul>\n<p>クライアント側とサーバ側はメッセージを交換する.</p>\n<p>各種チャンクのフィールドは, 公式ドキュメント<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>では以下のように定義されている.</p>\n<h4 id="c0-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%8A%E3%82%88%E3%81%B3-s0-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF"><a class="header-anchor" href="#c0-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%8A%E3%82%88%E3%81%B3-s0-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF">¶</a> C0 チャンクおよび S0 チャンク</h4>\n<ol>\n<li>利用する <abbr title="Real-Time Messaging Protocol">RTMP</abbr> のバージョン(1 byte)</li>\n</ol>\n<blockquote>\n<p>In C0, this field identifies the <abbr title="Real-Time Messaging Protocol">RTMP</abbr> version requested by the client.\nIn S0, this field identifies the <abbr title="Real-Time Messaging Protocol">RTMP</abbr> version selected by the server.\nThe version defined by this specification is 3.\nValues 0-2 are deprecated values used by earlier proprietary products; 4-31 are reserved for future implementations; and 32-255 are not allowed (to allow distinguishing <abbr title="Real-Time Messaging Protocol">RTMP</abbr> from text-based protocols, which always start with a printable character).\nA server that does not recognize the client’s requested version SHOULD respond with 3.\nThe client MAY choose to degrade to version 3, or to abandon the handshake.</p>\n</blockquote>\n<ul>\n<li>双方が利用する <abbr title="Real-Time Messaging Protocol">RTMP</abbr> のバージョンを指定する.</li>\n<li>基本的に, 指定できるバージョンは 3 である.\n<ul>\n<li>0 から 2 は本リリース前の企業製品によって使用されていたため非推奨である.</li>\n<li>4 から 31 は未来のために予約している.</li>\n<li>31 より大きい数はそもそも認めていない.</li>\n</ul>\n</li>\n<li>サーバ側は, クライアント側から要求されたバージョンを認識できない時は 3 と<strong>すべきである</strong>.</li>\n<li>その場合, クライアント側はバージョンを 3 にグレードダウンするか接続を中止するかを選んで<strong>よい</strong>.</li>\n</ul>\n<p>とされているが, 2019 年現在このフィールドに指定できるバージョンは以下の通りである.</p>\n<ul>\n<li>3(<abbr title="Real-Time Messaging Protocol">RTMP</abbr>)</li>\n<li>6(<abbr title="Real-Time Messaging Protocol Encrypted">RTMPE</abbr>)</li>\n</ul>\n<p>以下は Red5 および <abbr title="Open Broadcaster Software">OBS</abbr> が認識しているバージョンである.</p>\n<ul>\n<li>8(<abbr title="Real-Time Messaging Protocol Encrypted">RTMPE</abbr>/XTEA)</li>\n<li>9(<abbr title="Real-Time Messaging Protocol Encrypted">RTMPE</abbr>/Blowfish)</li>\n</ul>\n<p>以下に各 <abbr title="Open Source Software">OSS</abbr> 製品の該当部分の実装を示す.</p>\n<p>FFmpeg/rtmpproto.c#L1200-L1236<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-keyword">uint8_t</span> tosend [RTMP_HANDSHAKE_PACKET_SIZE+<span class="hljs-number">1</span>] = {\n    <span class="hljs-number">3</span>,                <span class="hljs-comment">// unencrypted data</span>\n    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,       <span class="hljs-comment">// client uptime</span>\n    RTMP_CLIENT_VER1,\n    RTMP_CLIENT_VER2,\n    RTMP_CLIENT_VER3,\n    RTMP_CLIENT_VER4,\n};\n\n<span class="hljs-comment">// 中略</span>\n\n<span class="hljs-keyword">if</span> (CONFIG_FFRTMPCRYPT_PROTOCOL &amp;&amp; rt-&gt;encrypted) {\n    <span class="hljs-comment">/* When the client wants to use RTMPE, we have to change the command\n     * byte to 0x06 which means to use encrypted data and we have to set\n     * the flash version to at least 9.0.115.0. */</span>\n    tosend[<span class="hljs-number">0</span>] = <span class="hljs-number">6</span>;\n    tosend[<span class="hljs-number">5</span>] = <span class="hljs-number">128</span>;\n    tosend[<span class="hljs-number">6</span>] = <span class="hljs-number">0</span>;\n    tosend[<span class="hljs-number">7</span>] = <span class="hljs-number">3</span>;\n    tosend[<span class="hljs-number">8</span>] = <span class="hljs-number">2</span>;\n\n    <span class="hljs-comment">/* Initialize the Diffie-Hellmann context and generate the public key\n     * to send to the server. */</span>\n    <span class="hljs-keyword">if</span> ((ret = ff_rtmpe_gen_pub_key(rt-&gt;stream, tosend + <span class="hljs-number">1</span>)) &lt; <span class="hljs-number">0</span>)\n        <span class="hljs-keyword">return</span> ret;\n}\n</code></pre>\n<p>obs-studio/rtmp.c#L4062<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p>\n<pre class="hljs"><code>clientbuf[<span class="hljs-number">0</span>] = <span class="hljs-number">0x03</span>;\t\t<span class="hljs-comment">/* not encrypted */</span>\n</code></pre>\n<p>obs-studio/handshake.h#L831-L837<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-keyword">if</span> (encrypted)\n{\n    clientsig[<span class="hljs-number">-1</span>] = <span class="hljs-number">0x06</span>;\t<span class="hljs-comment">/* 0x08 is RTMPE as well */</span>\n    offalg = <span class="hljs-number">1</span>;\n}\n<span class="hljs-keyword">else</span>\n    clientsig[<span class="hljs-number">-1</span>] = <span class="hljs-number">0x03</span>;\n</code></pre>\n<p>red5-server-common/RTMPHandshake.java#L56<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String[] HANDSHAKE_TYPES = {<span class="hljs-string">"Undefined0"</span>, <span class="hljs-string">"Undefined1"</span>, <span class="hljs-string">"Undefined2"</span>, <span class="hljs-string">"RTMP"</span>, <span class="hljs-string">"Undefined4"</span>, <span class="hljs-string">"Undefined5"</span>, <span class="hljs-string">"RTMPE"</span>, <span class="hljs-string">"Undefined7"</span>, <span class="hljs-string">"RTMPE XTEA"</span>, <span class="hljs-string">"RTMPE BLOWFISH"</span>};\n</code></pre>\n<h4 id="c1-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%8A%E3%82%88%E3%81%B3-s1-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF"><a class="header-anchor" href="#c1-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%8A%E3%82%88%E3%81%B3-s1-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF">¶</a> C1 チャンクおよび S1 チャンク</h4>\n<ol>\n<li>タイムスタンプ(4 bytes)</li>\n</ol>\n<blockquote>\n<p>This field contains a timestamp, which SHOULD be used as the epoch for all future chunks sent from this endpoint.\nThis may be 0, or some arbitrary value.\nTo synchronize multiple chunkstreams, the endpoint may wish to send the current value of the other chunkstream’s timestamp.</p>\n</blockquote>\n<ul>\n<li>今後送られることになるすべてのチャンクのタイムスタンプの基準として使われる<strong>べきである</strong>.</li>\n<li>これは 0 でもよいし, 何らかの任意の値でもよい.</li>\n<li>複数のチャンクの同期のために, 現在のタイムスタンプを送信したりすることにも使える.</li>\n</ul>\n<ol start="2">\n<li>ゼロ埋め(4 bytes)</li>\n</ol>\n<blockquote>\n<p>This field MUST be all 0s.</p>\n</blockquote>\n<ul>\n<li>すべて 0 で<strong>なければならない</strong>.</li>\n</ul>\n<p>とされているが, 2019 年現在ここには利用している Flash Player/Adobe Media Server のバージョンが割り当てられている. 以下に各 <abbr title="Open Source Software">OSS</abbr> 製品の該当部分の実装を示す.</p>\n<p>C1 チャンクの場合:</p>\n<p>FFmpeg/rtmpproto.c#L1200-L1207<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-keyword">uint8_t</span> tosend    [RTMP_HANDSHAKE_PACKET_SIZE+<span class="hljs-number">1</span>] = {\n    <span class="hljs-number">3</span>,                <span class="hljs-comment">// unencrypted data</span>\n    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,       <span class="hljs-comment">// client uptime</span>\n    RTMP_CLIENT_VER1,\n    RTMP_CLIENT_VER2,\n    RTMP_CLIENT_VER3,\n    RTMP_CLIENT_VER4,\n};\n</code></pre>\n<p>FFmpeg/rtmp.h#L32-L41<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-comment">/**\n * emulated Flash client version - 9.0.124.2 on Linux\n * @{\n */</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RTMP_CLIENT_PLATFORM <span class="hljs-meta-string">"LNX"</span></span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RTMP_CLIENT_VER1    9</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RTMP_CLIENT_VER2    0</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RTMP_CLIENT_VER3  124</span>\n<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RTMP_CLIENT_VER4    2</span>\n<span class="hljs-comment">/** @} */</span> <span class="hljs-comment">//version defines</span>\n</code></pre>\n<p>obs-studio/handshake.h#L842-L865<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-keyword">if</span> (FP9HandShake)\n{\n    <span class="hljs-comment">/* set version to at least 9.0.115.0 */</span>\n    <span class="hljs-keyword">if</span> (encrypted)\n    {\n        clientsig[<span class="hljs-number">4</span>] = <span class="hljs-number">128</span>;\n        clientsig[<span class="hljs-number">6</span>] = <span class="hljs-number">3</span>;\n    }\n    <span class="hljs-keyword">else</span>\n    {\n        clientsig[<span class="hljs-number">4</span>] = <span class="hljs-number">10</span>;\n        clientsig[<span class="hljs-number">6</span>] = <span class="hljs-number">45</span>;\n    }\n    clientsig[<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>;\n    clientsig[<span class="hljs-number">7</span>] = <span class="hljs-number">2</span>;\n\n    RTMP_Log(RTMP_LOGDEBUG, <span class="hljs-string">"%s: Client type: %02X"</span>, __FUNCTION__, clientsig[<span class="hljs-number">-1</span>]);\n    getdig = digoff[offalg];\n    getdh  = dhoff[offalg];\n}\n<span class="hljs-keyword">else</span>\n{\n    <span class="hljs-built_in">memset</span>(&amp;clientsig[<span class="hljs-number">4</span>], <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);\n}\n</code></pre>\n<p>S1 チャンクの場合:</p>\n<p>red5-server/InboundHandshake.java#L337-L341<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-comment">// version 4</span>\nhandshakeBytes[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span>;\nhandshakeBytes[<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>;\nhandshakeBytes[<span class="hljs-number">6</span>] = <span class="hljs-number">0</span>;\nhandshakeBytes[<span class="hljs-number">7</span>] = <span class="hljs-number">1</span>;\n</code></pre>\n<p>これは, Flash Player 9 および Adobe Media Server 3 前後でハンドシェイクの手順や実装内容に変更が加えられているため, どのバージョンのハンドシェイクを利用するかを区別するために存在する.</p>\n<ol start="3">\n<li>ランダムなバイト列(1528 bytes)</li>\n</ol>\n<blockquote>\n<p>This field can contain any arbitrary values.\nSince each endpoint has to distinguish between the response to the handshake it has initiated and the handshake initiated by its peer, this data SHOULD send something sufficiently random.\nBut there is no need for cryptographically-secure randomness, or even dynamic values.</p>\n</blockquote>\n<ul>\n<li>このフィールドはあらゆる任意の値を含むことができる.</li>\n<li>送受信する相手を区別しなければいけないため, このフィールドの値は十分にランダムである<strong>べき</strong>だが, それが暗号的に安全であったり動的な値である必要はない.</li>\n</ul>\n<p><a name="fp9"></a>\nとされているが, 2019 年現在これは単にランダムな値ではなく, Flash Player 9 および Adobe Media Server 3 以降は送信時に HMAC-SHA256 のダイジェストを埋め込むようになっている. ダイジェストの位置は C0 チャンクおよび S0 チャンクで指定された <abbr title="Real-Time Messaging Protocol">RTMP</abbr> のバージョンによって差異がある.<br>\nそれらの位置はそれぞれ以下の計算式で求めることができる.</p>\n<p>ランダムなバイト列を<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>とおく.</p>\n<p><abbr title="Real-Time Messaging Protocol">RTMP</abbr>(3) の場合:</p>\n<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>4</mn></munderover><msub><mi>R</mi><mi>i</mi></msub><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>728</mn><mo>+</mo><mn>12</mn></mstyle></mrow><annotation encoding="application/x-tex">\\displaystyle\\sum_{i=0}^4 R_{i}\\mod 728 + 12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">2</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span></p>\n<p><abbr title="Real-Time Messaging Protocol Encrypted">RTMPE</abbr>(6, 8 および 9) の場合:</p>\n<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>764</mn></mrow><mn>4</mn></munderover><msub><mi>R</mi><mi>i</mi></msub><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>728</mn><mo>+</mo><mn>776</mn></mstyle></mrow><annotation encoding="application/x-tex">\\displaystyle\\sum_{i=764}^4 R_{i}\\mod 728 + 776</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">7</span><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">2</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span><span class="mord">7</span><span class="mord">6</span></span></span></span></p>\n<p>ここで, ダイジェスト生成に使う鍵はクライアント/サーバ側でそれぞれ以下の通りである.</p>\n<p>クライアント側:</p>\n<ul>\n<li>C1 チャンクの送信時</li>\n</ul>\n<p>“Genuine Adobe Flash Player 001”</p>\n<ul>\n<li>返送された C1 チャンクの受信時</li>\n</ul>\n<p>“Genuine Adobe Flash Player 001 <strong>0x</strong>F0EEC24A8068BEE82E00D0D1029E7E576EEC5D2D29806FAB93B8E636CFEB31AE”</p>\n<p>サーバ側:</p>\n<ul>\n<li>S1 チャンクの送信時</li>\n</ul>\n<p>“Genuine Adobe Flash Media Server 001”</p>\n<ul>\n<li>返送された S1 チャンクの受信時</li>\n</ul>\n<p>“Genuine Adobe Flash Media Server 001 <strong>0x</strong>F0EEC24A8068BEE82E00D0D1029E7E576EEC5D2D29806FAB93B8E636CFEB31AE”</p>\n<h4 id="c2-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%8A%E3%82%88%E3%81%B3-s2-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF"><a class="header-anchor" href="#c2-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%8A%E3%82%88%E3%81%B3-s2-%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF">¶</a> C2 チャンクおよび S2 チャンク</h4>\n<ol>\n<li>タイムスタンプ(4 bytes)</li>\n</ol>\n<blockquote>\n<p>This field MUST contain the timestamp sent by the peer in S1 (for C2) or C1 (for S2).</p>\n</blockquote>\n<ul>\n<li>このフィールドはお互いに相手の第一チャンクが<strong>送られた</strong>時点のタイムスタンプを含め<strong>なければならない</strong>.</li>\n</ul>\n<ol start="2">\n<li>タイムスタンプ(4 bytes)</li>\n</ol>\n<blockquote>\n<p>This field MUST contain the timestamp at which the previous packet(s1 or c1) sent by the peer was read.</p>\n</blockquote>\n<ul>\n<li>このフィールドはお互いに相手から送られた第一チャンクを<strong>読み込んだ</strong>時点のタイムスタンプを含め<strong>なければならない</strong>.</li>\n</ul>\n<ol start="3">\n<li>ランダムなバイト列の<strong>エコー</strong>(1528 bytes)</li>\n</ol>\n<blockquote>\n<p>This field MUST contain the random data field sent by the peer in S1 (for C2) or S2 (for C1).\nEither peer can use the time and time2 fields together with the current timestamp as a quick estimate of the bandwidth and/or latency of the connection, but this is unlikely to be useful.</p>\n</blockquote>\n<ul>\n<li>このフィールドは C2 チャンクの場合は S1 チャンクによって送られたランダムなバイト列を, C1 チャンクの場合は S2 チャンクによって送られたランダムなバイト列を含め<strong>なければならない</strong>.</li>\n<li>どちら側も 2 つのタイムスタンプを接続の帯域幅や待ち時間の簡易な見積もりとして使えるが, あまり役に立たない.</li>\n</ul>\n<p>公式ドキュメントの文言だけではわかりにくいが, 各種 <abbr title="Open Source Software">OSS</abbr> 製品の実装の中にその答えがあったので以下に示す.</p>\n<p>クライアント側の場合:</p>\n<p>FFmpeg/rtmpproto.c#L1248-L1258<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-keyword">if</span> ((ret = ffurl_read_complete(rt-&gt;stream, serverdata,\n                               RTMP_HANDSHAKE_PACKET_SIZE + <span class="hljs-number">1</span>)) &lt; <span class="hljs-number">0</span>) {\n    av_log(s, AV_LOG_ERROR, <span class="hljs-string">"Cannot read RTMP handshake response\\n"</span>);\n    <span class="hljs-keyword">return</span> ret;\n}\n\n<span class="hljs-keyword">if</span> ((ret = ffurl_read_complete(rt-&gt;stream, clientdata,\n                               RTMP_HANDSHAKE_PACKET_SIZE)) &lt; <span class="hljs-number">0</span>) {\n    av_log(s, AV_LOG_ERROR, <span class="hljs-string">"Cannot read RTMP handshake response\\n"</span>);\n    <span class="hljs-keyword">return</span> ret;\n}\n</code></pre>\n<p>obs-studio/rtmp.c#L4089-L4112<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-keyword">if</span> (ReadN(r, serversig, RTMP_SIG_SIZE) != RTMP_SIG_SIZE)\n    <span class="hljs-keyword">return</span> FALSE;\n\n<span class="hljs-comment">/* decode server response */</span>\n\n<span class="hljs-built_in">memcpy</span>(&amp;suptime, serversig, <span class="hljs-number">4</span>);\nsuptime = ntohl(suptime);\n\nRTMP_Log(RTMP_LOGDEBUG, <span class="hljs-string">"%s: Server Uptime : %d"</span>, __FUNCTION__, suptime);\nRTMP_Log(RTMP_LOGDEBUG, <span class="hljs-string">"%s: FMS Version   : %d.%d.%d.%d"</span>, __FUNCTION__,\n         serversig[<span class="hljs-number">4</span>], serversig[<span class="hljs-number">5</span>], serversig[<span class="hljs-number">6</span>], serversig[<span class="hljs-number">7</span>]);\n\n<span class="hljs-comment">/* 2nd part of handshake */</span>\n<span class="hljs-keyword">if</span> (!WriteN(r, serversig, RTMP_SIG_SIZE))\n    <span class="hljs-keyword">return</span> FALSE;\n\n<span class="hljs-keyword">if</span> (ReadN(r, serversig, RTMP_SIG_SIZE) != RTMP_SIG_SIZE)\n    <span class="hljs-keyword">return</span> FALSE;\n\nbMatch = (<span class="hljs-built_in">memcmp</span>(serversig, clientsig, RTMP_SIG_SIZE) == <span class="hljs-number">0</span>);\n<span class="hljs-keyword">if</span> (!bMatch)\n{\n    RTMP_Log(RTMP_LOGWARNING, <span class="hljs-string">"%s, client signature does not match!"</span>, __FUNCTION__);\n}\n</code></pre>\n<p>obs-studio/handshake.h#L936-L945<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>\nobs-studio/handshake.h#L1078-L1083<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>\nobs-studio/handshake.h#L1170-L1174<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-keyword">if</span> (ReadN(r, (<span class="hljs-keyword">char</span> *)serversig, RTMP_SIG_SIZE) != RTMP_SIG_SIZE)\n    <span class="hljs-keyword">return</span> FALSE;\n\n<span class="hljs-comment">/* decode server response */</span>\n<span class="hljs-built_in">memcpy</span>(&amp;uptime, serversig, <span class="hljs-number">4</span>);\nuptime = ntohl(uptime);\n\nRTMP_Log(RTMP_LOGDEBUG, <span class="hljs-string">"%s: Server Uptime : %d"</span>, __FUNCTION__, uptime);\nRTMP_Log(RTMP_LOGDEBUG, <span class="hljs-string">"%s: FMS Version   : %d.%d.%d.%d"</span>, __FUNCTION__, serversig[<span class="hljs-number">4</span>],\n         serversig[<span class="hljs-number">5</span>], serversig[<span class="hljs-number">6</span>], serversig[<span class="hljs-number">7</span>]);\n\n<span class="hljs-comment">// 中略</span>\n\n<span class="hljs-keyword">if</span> (!WriteN(r, (<span class="hljs-keyword">char</span> *)reply, RTMP_SIG_SIZE))\n    <span class="hljs-keyword">return</span> FALSE;\n\n<span class="hljs-comment">/* 2nd part of handshake */</span>\n<span class="hljs-keyword">if</span> (ReadN(r, (<span class="hljs-keyword">char</span> *)serversig, RTMP_SIG_SIZE) != RTMP_SIG_SIZE)\n    <span class="hljs-keyword">return</span> FALSE;\n\n<span class="hljs-comment">// 中略</span>\n\n<span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(serversig, clientsig, RTMP_SIG_SIZE) != <span class="hljs-number">0</span>)\n{\n    RTMP_Log(RTMP_LOGWARNING, <span class="hljs-string">"%s: client signature does not match!"</span>,\n             __FUNCTION__);\n}\n</code></pre>\n<p>サーバ側の場合:</p>\n<p>FFmpeg/rtmpproto.c#L1452-L1472<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-comment">/* Send S1 */</span>\n<span class="hljs-comment">/* By now same epoch will be sent */</span>\nhs_my_epoch = hs_epoch;\n<span class="hljs-comment">/* Generate random */</span>\n<span class="hljs-keyword">for</span> (randomidx = <span class="hljs-number">8</span>; randomidx &lt; (RTMP_HANDSHAKE_PACKET_SIZE);\n     randomidx += <span class="hljs-number">4</span>)\n    AV_WB32(hs_s1 + randomidx, av_get_random_seed());\n\nret = rtmp_send_hs_packet(rt, hs_my_epoch, <span class="hljs-number">0</span>, hs_s1,\n                          RTMP_HANDSHAKE_PACKET_SIZE);\n<span class="hljs-keyword">if</span> (ret) {\n    av_log(s, AV_LOG_ERROR, <span class="hljs-string">"RTMP Handshake S1 Error\\n"</span>);\n    <span class="hljs-keyword">return</span> ret;\n}\n<span class="hljs-comment">/* Send S2 */</span>\nret = rtmp_send_hs_packet(rt, hs_epoch, <span class="hljs-number">0</span>, hs_c1,\n                          RTMP_HANDSHAKE_PACKET_SIZE);\n<span class="hljs-keyword">if</span> (ret) {\n    av_log(s, AV_LOG_ERROR, <span class="hljs-string">"RTMP Handshake S2 Error\\n"</span>);\n    <span class="hljs-keyword">return</span> ret;\n}\n</code></pre>\n<p>obs-studio/rtmp.c#L4152-L4178<sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-keyword">if</span> (!WriteN(r, serverbuf, RTMP_SIG_SIZE + <span class="hljs-number">1</span>))\n    <span class="hljs-keyword">return</span> FALSE;\n\n<span class="hljs-keyword">if</span> (ReadN(r, clientsig, RTMP_SIG_SIZE) != RTMP_SIG_SIZE)\n    <span class="hljs-keyword">return</span> FALSE;\n\n<span class="hljs-comment">/* decode client response */</span>\n\n<span class="hljs-built_in">memcpy</span>(&amp;uptime, clientsig, <span class="hljs-number">4</span>);\nuptime = ntohl(uptime);\n\nRTMP_Log(RTMP_LOGDEBUG, <span class="hljs-string">"%s: Client Uptime : %d"</span>, __FUNCTION__, uptime);\nRTMP_Log(RTMP_LOGDEBUG, <span class="hljs-string">"%s: Player Version: %d.%d.%d.%d"</span>, __FUNCTION__,\n         clientsig[<span class="hljs-number">4</span>], clientsig[<span class="hljs-number">5</span>], clientsig[<span class="hljs-number">6</span>], clientsig[<span class="hljs-number">7</span>]);\n\n<span class="hljs-comment">/* 2nd part of handshake */</span>\n<span class="hljs-keyword">if</span> (!WriteN(r, clientsig, RTMP_SIG_SIZE))\n    <span class="hljs-keyword">return</span> FALSE;\n\n<span class="hljs-keyword">if</span> (ReadN(r, clientsig, RTMP_SIG_SIZE) != RTMP_SIG_SIZE)\n    <span class="hljs-keyword">return</span> FALSE;\n\nbMatch = (<span class="hljs-built_in">memcmp</span>(serversig, clientsig, RTMP_SIG_SIZE) == <span class="hljs-number">0</span>);\n<span class="hljs-keyword">if</span> (!bMatch)\n{\n    RTMP_Log(RTMP_LOGWARNING, <span class="hljs-string">"%s, client signature does not match!"</span>, __FUNCTION__);\n}\n</code></pre>\n<p>obs-studio/hansdhake.h#L1442-L1447<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup>\nobs-studio/handshake.h#L1524-L1528<sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-keyword">if</span> (!WriteN(r, (<span class="hljs-keyword">char</span> *)clientsig, RTMP_SIG_SIZE))\n    <span class="hljs-keyword">return</span> FALSE;\n\n<span class="hljs-comment">/* 2nd part of handshake */</span>\n<span class="hljs-keyword">if</span> (ReadN(r, (<span class="hljs-keyword">char</span> *)clientsig, RTMP_SIG_SIZE) != RTMP_SIG_SIZE)\n    <span class="hljs-keyword">return</span> FALSE;\n\n<span class="hljs-comment">// 中略</span>\n\n<span class="hljs-keyword">if</span> (<span class="hljs-built_in">memcmp</span>(serversig, clientsig, RTMP_SIG_SIZE) != <span class="hljs-number">0</span>)\n{\n    RTMP_Log(RTMP_LOGWARNING, <span class="hljs-string">"%s: client signature does not match!"</span>,\n             __FUNCTION__);\n}\n</code></pre>\n<p>red5-server/InboundHandshake.java#L202-L213<sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>\nred5-server/InboundHandshake.java#L293-L295<sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup></p>\n<pre class="hljs"><code>IoBuffer s0s1s2 = IoBuffer.allocate(Constants.HANDSHAKE_SIZE * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 3073</span>\n<span class="hljs-comment">// set handshake with encryption type</span>\ns0s1s2.put(handshakeType); <span class="hljs-comment">// 1</span>\ns0s1s2.put(s1); <span class="hljs-comment">// 1536</span>\ns0s1s2.put(c1); <span class="hljs-comment">// 1536</span>\ns0s1s2.flip();\n<span class="hljs-comment">// clear original base bytes</span>\nhandshakeBytes = <span class="hljs-keyword">null</span>;\n<span class="hljs-keyword">if</span> (log.isTraceEnabled()) {\n    log.trace(<span class="hljs-string">"S0+S1+S2 size: {}"</span>, s0s1s2.limit());\n}\n<span class="hljs-keyword">return</span> s0s1s2;\n\n<span class="hljs-comment">// 中略</span>\n\n<span class="hljs-keyword">if</span> (!Arrays.equals(s1, c2)) {\n    log.info(<span class="hljs-string">"Client signature doesn\'t match!"</span>);\n}\n</code></pre>\n<p>用いているプログラミング言語の違い等によって実装内容に差異はあるものの, 上記の各種実装を参考にすると以下に要約できる.</p>\n<ul>\n<li>C2 チャンク: S1 チャンクと同じ内容を書き込み, 送信する.</li>\n<li>S2 チャンク: C1 チャンクと同じ内容を書き込み, 送信する.</li>\n</ul>\n<p>ただし, Flash Player 9 および Adobe Media Server 3 以上の場合は C1 チャンクおよび S1 チャンクのランダムバイト列の所定の位置を HMAC-SHA256 で求めたダイジェストに置き換えて送受信を行い, 受信時に<a href="#fp9">ダイジェストの位置を探し当てて</a>送信前のダイジェストと照合することでメッセージの正当性を検証する必要がある.</p>\n<p>上記の各実装より, 現在の <abbr title="Real-Time Messaging Protocol">RTMP</abbr> 層におけるハンドシェイクの手順は以下に要約できる.</p>\n<div id="rtmp-handshake-sequences-current">\n<a href="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuNhSjFvnyyh7JKiUDorwtBpvSNE7WgwTmkEchO-Rzpnkdc2bu6oWxMp81HU0oABhiL88Dj0EDjGEDYB2G2CkMri5iEpqnysh7ZTj1CaqRN_Sl1oe_bdVqkVRPZrktA5WQylba9gN0dGa0000" target="_self"><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuNhSjFvnyyh7JKiUDorwtBpvSNE7WgwTmkEchO-Rzpnkdc2bu6oWxMp81HU0oABhiL88Dj0EDjGEDYB2G2CkMri5iEpqnysh7ZTj1CaqRN_Sl1oe_bdVqkVRPZrktA5WQylba9gN0dGa0000" alt=""></a></div>\n<p id="caption-rtmp-handshake-sequences-current">図3. 現在の <abbr title="Real-Time Messaging Protocol">RTMP</abbr> ハンドシェイクの手順</p>\n<ol>\n<li>クライアント側はサーバ側に C0 チャンクと C1 チャンクをそれぞれ送信する.</li>\n<li>サーバ側はクライアント側から C0 チャンク と C1 チャンクをそれぞれ受信したなら, S0 チャンク, S1 チャンクおよび S2 チャンクをそれぞれクライアント側に送信する.</li>\n<li>クライアント側はサーバ側から S0 チャンク, S1 チャンクおよび S2 チャンクをそれぞれ受信したなら, C2 チャンクをサーバ側へ送信する.</li>\n<li>サーバ側はクライアント側から C2 チャンクを受け取ったなら, アプリケーション接続に移行する.</li>\n</ol>\n<h3 id="invoke(connect)-%E3%81%8B%E3%82%89%E6%98%A0%E5%83%8F%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E5%8F%97%E4%BF%A1%E3%81%BE%E3%81%A7"><a class="header-anchor" href="#invoke(connect)-%E3%81%8B%E3%82%89%E6%98%A0%E5%83%8F%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E5%8F%97%E4%BF%A1%E3%81%BE%E3%81%A7">¶</a> Invoke(connect) から映像データの受信まで</h3>\n<p><abbr title="Real-Time Messaging Protocol">RTMP</abbr> 層におけるハンドシェイクが完了したなら, サーバ側とクライアント側は映像の送受信に必要な情報を相互に伝達しあう. それは以下の手順で行う.</p>\n<div id="rtmp-application-connect-sequences">\n<a href="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuRArLNZStF-uUVFZvix7JTiVDor_tBJaSTFwnuqzJzVrFDdLzhXn-kF6-NeAjhPS8E7cbM3vHM0T7GgwTWgFcxO-Rjxpk7c2bO9dNbb-Tgf6SdvUNcfoYIONN0gY3bqtN4DyKMfnQGvO0v4s5AKcbgG6bm2fN1fQKr2Qb9DPd46y3VbvmIM99QN5cg1mVJPZmLDGqEv-EN_pqyKR7ZUtWynesl-uSTtBXiQd_TEVx5_uk747A6GTKlDIWB410000" target="_self"><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuRArLNZStF-uUVFZvix7JTiVDor_tBJaSTFwnuqzJzVrFDdLzhXn-kF6-NeAjhPS8E7cbM3vHM0T7GgwTWgFcxO-Rjxpk7c2bO9dNbb-Tgf6SdvUNcfoYIONN0gY3bqtN4DyKMfnQGvO0v4s5AKcbgG6bm2fN1fQKr2Qb9DPd46y3VbvmIM99QN5cg1mVJPZmLDGqEv-EN_pqyKR7ZUtWynesl-uSTtBXiQd_TEVx5_uk747A6GTKlDIWB410000" alt=""></a></div>\n<p id="caption-rtmp-application-connect-sequences">図4. アプリケーション接続の大まかなシーケンス</p>\n<ol>\n<li>クライアント側はサーバ側に Invoke(connect) メッセージを送信する.</li>\n<li>サーバ側はクライアント側から受信した Invoke(connect) メッセージをデコードし, 応答メッセージをクライアント側に送信する.</li>\n<li>クライアント側はサーバ側から Invoke(_result) を受信したなら, Invoke(createStream) メッセージをサーバ側に送信し, メッセージストリームへの一意な ID の付番を要求する.</li>\n<li>サーバ側はクライアント側から受信した Invoke(createStream) メッセージをデコードし, 応答メッセージをクライアント側に送信する.</li>\n<li>クライアント側はサーバ側から Invoke(_result) を受信したなら, Invoke(publish) をサーバ側に送信し, 映像の送信開始を伝える.</li>\n<li>サーバ側はクライアント側から受信した Invoke(publish) をデコードし, 応答メッセージをクライアント側に送信する.</li>\n<li>クライアント側はサーバ側から Invoke(onStatus) を受信したなら, 映像/音声の送信を開始する.</li>\n</ol>\n<p>なお, <abbr title="Real-Time Messaging Protocol">RTMP</abbr> ハンドシェイク以降に送受信されるチャンクの構造は以下の通りである. ここから Big Endian と Little Endian の違いを考慮していく必要があるので注意が必要である.</p>\n<h4 id="%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E6%A7%8B%E9%80%A0"><a class="header-anchor" href="#%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%81%AE%E6%A7%8B%E9%80%A0">¶</a> メッセージチャンクの構造</h4>\n<p>ハンドシェイク後に送受信されるチャンクは公式ドキュメント<sup class="footnote-ref"><a href="#fn1" id="fnref1:2">[1:2]</a></sup>では以下のように定義されている.</p>\n<ol>\n<li>チャンクベーシックヘッダ (最大 3 bytes)</li>\n</ol>\n<ul>\n<li>チャンクメッセージヘッダのフォーマット (2 <strong>bits</strong>)\n<ul>\n<li>後に続くチャンクメッセージヘッダのパターンを入力する.</li>\n<li>0b00: Type 0 (11 bytes)</li>\n<li>0b01: Type 1 (7 bytes)</li>\n<li>0b10: Type 2 (3 bytes)</li>\n<li>0b11: Type 3 (0 byte)</li>\n</ul>\n</li>\n<li>チャンクストリーム ID (6 <strong>bits</strong>, 1 byte および 2 bytes)\n<ul>\n<li>チャンクメッセージの<strong>種類</strong>に応じて割り当てられる. 一意になるとは限らない.</li>\n<li>ID が 3 以上 63 以下である場合は 6 bits に収めて 1 byte にまとめる.</li>\n<li>64 以上 319 以下である場合は 1 byte で表現する. その場合はフォーマット直後の 6 bits には 0 を入力する.</li>\n<li>320 以上 65599 以下である場合は 2 bytes で表現する. その場合はフォーマット直後の 6 bits には 1 を入力する.</li>\n<li>64 以上の場合は実際の ID よりも 64 少ないものとして扱われるため, デコード後に 64 を加えてから利用する必要がある.</li>\n<li>320 以上の場合に限り当該 ID のバイト順序が <strong>Little Endian</strong> であるため, このパターンをデコードする際は更に注意しなければならない.</li>\n<li>なお, 3 未満の ID は予約済みである.</li>\n</ul>\n</li>\n</ul>\n<ol start="2">\n<li>チャンクメッセージヘッダ (最大 11 bytes. 0 byte を含む.)</li>\n</ol>\n<p>チャンクメッセージヘッダのパターンは, 上述のチャンクベーシックヘッダの上位 2 bits の値に応じて以下の 4 パターンに分けられる.</p>\n<p>Type 0 (11 bytes):</p>\n<p>チャンクストリームの始まりはこの Type 0 パターンで<strong>なければならない</strong>.</p>\n<ul>\n<li>タイムスタンプ (3 bytes)\n<ul>\n<li>チャンクストリームの送信を開始した時点のタイムスタンプを入力する.</li>\n<li>タイムスタンプが 0xFFFFFF より大きくなる場合は後述の拡張タイムスタンプフィールドに入力し, このフィールドの値を 0xFFFFFF で固定する.</li>\n</ul>\n</li>\n<li>メッセージ長 (3 bytes)\n<ul>\n<li>チャンクデータの長さを入力する. ただし, チャンクデータ自体の長さしか考慮されていない. (詳細は後述する)</li>\n</ul>\n</li>\n<li>メッセージ種類 ID (1 byte)\n<ul>\n<li>後に続くチャンクデータの種類を入力する. 現在仕様書に存在している, または利用が確認されている種類は<a href="#%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E7%A8%AE%E9%A1%9E">メッセージの種類</a>を参照.</li>\n</ul>\n</li>\n<li>メッセージストリーム ID (4 bytes)\n<ul>\n<li>アプリケーション間接続が完全に成功した際にサーバ側から割り振られる.</li>\n<li>チャンクストリームの中ではこの ID を利用して相互に存在を保証しあうため, 一意である必要がある.</li>\n<li><strong>Little Endian</strong>である.</li>\n</ul>\n</li>\n</ul>\n<p>Type 1 (7 bytes):</p>\n<p>直前のチャンクとメッセージストリーム ID のみが同一である場合はこの Type 1 パターンを入力する.<br>\n音声・映像チャンク等の可変かつ複数のデータを同時に送信するような場合は, 2 番目に送るチャンクのチャンクメッセージヘッダをこの Type 1 パターンに<strong>すべきである</strong>.</p>\n<ul>\n<li>タイムスタンプ (3 bytes)\n<ul>\n<li>Type 0 パターンが送られた時点からのタイムスタンプの<strong>差分</strong>を入力する.</li>\n<li>Type 0 パターンと同様に, 0xFFFFFF より大きくなる場合は拡張タイムスタンプを利用する.</li>\n</ul>\n</li>\n<li>メッセージ長 (3 bytes)\n<ul>\n<li>Type 0 パターンと同様である.</li>\n</ul>\n</li>\n<li>メッセージ種類 ID (1 byte)\n<ul>\n<li>Type 0 パターンと同様である.</li>\n</ul>\n</li>\n</ul>\n<p>Type 2 (3 bytes):</p>\n<p>直前のチャンクとメッセージストリーム ID, チャンクデータの種類およびチャンクデータのメッセージ長が同一である場合はこの Type 2 パターンを入力する.<br>\n固定長の同一の種類のチャンクデータを同じメッセージストリームに送信し続けるような場合は, 2 番目に送るチャンクのチャンクメッセージヘッダをこの Type 2 パターンに<strong>すべきである</strong>.</p>\n<ul>\n<li>タイムスタンプ (3 bytes)\n<ul>\n<li>Type 1 パターンと同様の<strong>差分</strong>である.</li>\n<li>タイムスタンプが 0xFFFFFF より大きくなる場合も Type 1 と同様にする.</li>\n</ul>\n</li>\n</ul>\n<p>Type 3 (0 byte):</p>\n<p>この Type 3 パターンを入力する時は, 以下の 2 つの場合がある:</p>\n<ul>\n<li>同一のメッセージストリームに種類もサイズも同一のチャンクデータを同時に送信する場合.\n<ul>\n<li>チャンクデータの内容まで同一である必要はない.</li>\n</ul>\n</li>\n<li>チャンクデータが所定のチャンクサイズより大きくなってしまった場合.\n<ul>\n<li>所定のチャンクサイズ分のチャンクデータの直後に入力する.</li>\n</ul>\n</li>\n</ul>\n<p>特に後者で扱う場合は注意が必要である. その理由は以下の通りである:</p>\n<ul>\n<li>チャンクメッセージヘッダのメッセージ長フィールドにおいて, クライアント側もサーバ側もチャンクデータを区切っている Type 3 ヘッダの数は考慮されて<strong>いない</strong>ため.\n<ul>\n<li>つまり, チャンクメッセージヘッダのメッセージ長フィールドをチャンクデータを読み取るための数としてそのまま使おうとすると, <strong>チャンクデータの総量が所定のチャンクサイズを超えている場合に正しく読み取れない</strong>.</li>\n</ul>\n</li>\n<li>また, サーバ側もクライアント側もチャンクメッセージヘッダのメッセージ長フィールドの値とは別に Type 3 パターンのチャンクメッセージヘッダで区切られているチャンクデータを繋げる処理を独自に実装してしまっている.\n<ul>\n<li>送信時に入力する Type 3 パターンのチャンクメッセージヘッダの数を当該フィールドに含めても<strong>エラー</strong>扱いされてしまう.</li>\n</ul>\n</li>\n</ul>\n<p>上記の解決手段については別記事で紹介する.</p>\n<ol start="3">\n<li>拡張タイムスタンプ (4 bytes)</li>\n</ol>\n<p>入力するタイムスタンプが 0xFFFFFF より大きくなった場合に, そのタイムスタンプをチャンクメッセージヘッダのタイムスタンプフィールドに入力する代わりに当該フィールドに入力する.<br>\nタイムスタンプを拡張する必要がない場合はこのフィールドは入力されないため, 無視してチャンクデータを読むように実装する必要もある.</p>\n<ol start="4">\n<li>チャンクデータ (可変)</li>\n</ol>\n<p>チャンクの本文である. 内容はチャンクメッセージヘッダのメッセージ種類 ID フィールドおよびメッセージ長フィールドの値に依存しているほか, 以下の点にも気をつけなければならない.</p>\n<ul>\n<li>メッセージの種類が同じであっても, チャンクデータの内容も同じであるとは限らない.</li>\n<li>チャンクデータの長さが所定のチャンクサイズより大きくなる場合はチャンクデータをそのチャンクサイズ毎に区切り, 残りの各チャンクデータにチャンクベーシックヘッダおよび Type 3 パターンのチャンクメッセージヘッダを添えてから送信すべきである.</li>\n</ul>\n<h5 id="%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E7%A8%AE%E9%A1%9E"><a class="header-anchor" href="#%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E7%A8%AE%E9%A1%9E">¶</a> メッセージの種類</h5>\n<table>\n<thead>\n<tr>\n<th>メッセージ種類 ID</th>\n<th>チャンクデータの種類</th>\n<th>サイズ</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Chunk Size</td>\n<td>4 bytes</td>\n<td>チャンク<strong>データ</strong>を一度に受け取るデータ量. (チャンク全体を指していないことに注意)<br>公式ドキュメントでは Set Chunk Size と呼んでいるが, 既存 <abbr title="Open Source Software">OSS</abbr> 製品では Chunk Size と呼ばれているため, ソースコードとの統一性のために本稿でも Chunk Size と呼ぶことにする.<br>最上位ビットは 0 で<strong>なければならない</strong>.<br>4 bytes が確保されているが実際のチャンクデータの長さの値は高々 3 bytes であるため, 0xFFFFFF よりも大きくなることはまずない.<br>仕様書では少なくとも 128 (bytes) である<strong>べき</strong>で, かつ少なくとも 1 (byte) で<strong>なければならない</strong>としている.<br>一方でデフォルト値を 128 (bytes) としており, 多くの製品はこれに従っている.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Abort</td>\n<td>4 bytes</td>\n<td>送受信を中止する対象のチャンクストリーム ID.<br>何らかの理由でチャンクストリームを強制的に閉じなければならない時に当該チャンクデータにチャンクストリーム ID を入力して終了を伝える.</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Bytes Read</td>\n<td>4 bytes</td>\n<td>これまでに受信したデータ量.<br>公式ドキュメントでは Acknowledgement と呼んでいるが既存 <abbr title="Open Source Software">OSS</abbr> 製品では Bytes Read と呼ばれているため, ソースコードとの統一性のために本稿でも Bytes Read と呼ぶことにする.<br>サーバ側もクライアント側も, 受信したデータ量が事前に通知しているウィンドウサイズに等しくなった場合に当該チャンクデータにそのデータ量を入力して送信し<strong>なければならない</strong>.<br>ウィンドウサイズは相手側から当該チャンクデータを受信せずに送れるデータ量の最大値である.</td>\n</tr>\n<tr>\n<td>4</td>\n<td>User Control</td>\n<td>2 bytes<br>+<br>4 bytes から 8 bytes</td>\n<td>主にメッセージストリーム ID だが, どの種類のイベントを入力するかによって具体的な内容に違いがある.<br>詳細は <a href="#user-control-message-%E3%81%AE%E7%A8%AE%E9%A1%9E%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF">User Control Message の種類とデータ</a>を参照.</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Window Acknowledgement Size (Official, FFmpeg),<br>Server BandWidth (Red5, <abbr title="Open Broadcaster Software">OBS</abbr>)</td>\n<td>4 bytes</td>\n<td>サーバ側が Acknowledgement チャンクを送信せずに送れる最大のデータ量.<br>つまりサーバ側の回線帯域である.<br>多くの場合, 3 Mbps 前後をデフォルト値とされているが変更可能である.</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Set Peer BandWidth (Official, FFmpeg),<br>Client BandWidth (Red5, <abbr title="Open Broadcaster Software">OBS</abbr>)</td>\n<td>4 bytes</td>\n<td>クライアント側が Acknowledgement チャンク送信せずに送れる最大のデータ量.<br>つまりクライアント側の回線帯域である.<br>多くの場合, 3 Mbps 前後をデフォルト値とされているがこれも変更可能である.</td>\n</tr>\n<tr>\n<td>8</td>\n<td>Audio</td>\n<td>可変</td>\n<td>音声データ.<br>可変長の生のバイト列が入力される.<br>詳細は後日記載.</td>\n</tr>\n<tr>\n<td>9</td>\n<td>Video</td>\n<td>可変</td>\n<td>映像データ.<br>以下同上.<br>詳細は後日記載.</td>\n</tr>\n<tr>\n<td>15</td>\n<td>Data(Official),<br>Notify(FFmpeg, Red5)<br>Info(<abbr title="Open Broadcaster Software">OBS</abbr>)</td>\n<td>可変</td>\n<td>チャンク(主に映像・音声)のメタデータ.<br>AMF3 がチャンクデータに適用されている.</td>\n</tr>\n<tr>\n<td>18</td>\n<td>^^</td>\n<td>^^</td>\n<td>〃<br>AMF0 がチャンクデータに適用されている.</td>\n</tr>\n<tr>\n<td>16</td>\n<td>Shared Object</td>\n<td>可変</td>\n<td>名前と値のペアのコレクション.<br>複数のクライアント間やインスタンス間で同期をとるための Flash Objectである.<br>既存の <abbr title="Open Source Software">OSS</abbr> 製品では Red5 のみが実装しているが, 具体的なデータ構造を特定できないため詳細は割愛する.<br>AMF3 がチャンクデータに適用されている.</td>\n</tr>\n<tr>\n<td>19</td>\n<td>^^</td>\n<td>^^</td>\n<td>〃<br>AMF0 がチャンクデータに適用されている.</td>\n</tr>\n<tr>\n<td>17</td>\n<td>Invoke</td>\n<td>可変</td>\n<td>クライアントとサーバの間で映像の送受信の際に必要になるメッセージを入力する.<br>公式ドキュメントでは Command と呼んでいるが既存 <abbr title="Open Source Software">OSS</abbr> 製品では Invoke と呼ばれているため, ソースコードとの統一性のために本稿でも Invoke と呼ぶことにする.<br>映像・音声データの送受信より前に送受信される基本的なメッセージはすべてこの Invoke チャンクを介して行われる.<br>AMF3 がチャンクデータに適用されている.</td>\n</tr>\n<tr>\n<td>20</td>\n<td>^^</td>\n<td>^^</td>\n<td>〃<br>AMF0 がチャンクデータに適用されている.</td>\n</tr>\n<tr>\n<td>22</td>\n<td>Metadata</td>\n<td>可変</td>\n<td>音声や映像に関するメタデータ.<br>公式ドキュメントでは Aggregate と呼んでいるが既存 <abbr title="Open Source Software">OSS</abbr> 製品では Metadata と呼ばれているため, ソースコードとの統一性のために本稿でも MetaData と呼ぶことにする.<br>詳細は <a href="#metadata-%E3%81%AE%E6%A7%8B%E9%80%A0">Metadata の構造</a>を参照.</td>\n</tr>\n</tbody>\n</table>\n<h5 id="user-control-message-%E3%81%AE%E7%A8%AE%E9%A1%9E%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF"><a class="header-anchor" href="#user-control-message-%E3%81%AE%E7%A8%AE%E9%A1%9E%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF">¶</a> User Control Message の種類とデータ</h5>\n<p>以下は公式ドキュメントに記載されており, 既存 <abbr title="Open Source Software">OSS</abbr> 製品の実装にも見られるイベントである.</p>\n<table>\n<thead>\n<tr>\n<th>ID</th>\n<th>イベントの種類</th>\n<th>サイズ</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>Stream Begin</td>\n<td>4 bytes</td>\n<td>クライアントに割り当てられているメッセージストリーム ID.<br>クライアント側からの Invoke(connect) の受信直後は通信の仕様上必然的に 0 になる.</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Stream EOF</td>\n<td>4 bytes</td>\n<td>〃<br>プレイバックが終了したクライアントのメッセージストリーム ID を入力する.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Stream Dry</td>\n<td>4 bytes</td>\n<td>〃<br>一定時間以上ストリーム上にデータがないクライアントのメッセージストリーム ID を入力する.</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Set Buffer Length</td>\n<td>8 bytes</td>\n<td>クライアントに割り当てられているメッセージストリームID (4 bytes) とミリ秒単位のバッファの長さ (4 bytes).<br>クライアント側がストリームを渡来するデータをバッファリングするために使われるバッファのサイズをサーバ側に通知する.<br>サーバ側がストリームを処理し始める前に送信される.</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Stream Is Recorded</td>\n<td>4 bytes</td>\n<td>クライアントに割り当てられているメッセージストリーム ID.<br>サーバ側が当該ストリームが<strong>録画用</strong>として使われていることをクライアント側に通知する.</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Ping</td>\n<td>4 bytes</td>\n<td><strong>サーバ側</strong>のタイムスタンプ.<br>公式ドキュメントでは Ping Request と呼んでいるが既存の <abbr title="Open Source Software">OSS</abbr> 製品では Ping と呼ばれているため, ソースコードとの統一性のために本稿でも Ping と呼ぶことにする.<br>サーバ側が通信がクライアントに到達するかどうかを試すために送信する.</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Pong</td>\n<td>4 bytes</td>\n<td><strong>クライアント側が Ping と共に受け取った</strong>タイムスタンプ.<br>公式ドキュメントでは Ping Response と呼んでいるが既存の <abbr title="Open Source Software">OSS</abbr> 製品では Pong と呼ばれているため, ソースコードとの統一性のために本稿でも Pong と呼ぶことにする.<br>クライアント側がサーバ側からの Ping が到達したことをサーバ側に伝えるために送信する.</td>\n</tr>\n</tbody>\n</table>\n<p>以下は公式ドキュメントには記載されていないが, 既存 <abbr title="Open Source Software">OSS</abbr> 製品の実装で見られるイベントである.</p>\n<table>\n<thead>\n<tr>\n<th>ID</th>\n<th>イベントの種類</th>\n<th>サイズ</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>26</td>\n<td>SWF Verification Request</td>\n<td>0 byte</td>\n<td>相手側に SWF の内容が正しいことを確かめてもらうためのリクエスト.</td>\n</tr>\n<tr>\n<td>27</td>\n<td>SWF Verification Response</td>\n<td>42 bytes</td>\n<td>相手側から返される SWF のバイト列から生成された HMAC-SHA256 ダイジェスト.<br>メッセージの内訳は以下の通りである:  \\</td>\n</tr>\n<tr>\n<td>* 0 byte目: 1  \\</td>\n</tr>\n<tr>\n<td>* 1 byte目: 1  \\</td>\n</tr>\n<tr>\n<td>* 2 - 5 bytes目: 解凍された SWF のサイズ  \\</td>\n</tr>\n<tr>\n<td>* 6 - 9 bytes目: 同上  \\</td>\n</tr>\n<tr>\n<td>* 10 - 31 bytes目: 解凍された SWF のハッシュをハンドシェイクチャンクのダイジェストで署名したバイト列</td>\n</tr>\n</tbody>\n</table>\n<p>以下は公式ドキュメントには記載されておらず, Red5 と <abbr title="Open Broadcaster Software">OBS</abbr> の実装で見られるイベントである.</p>\n<table>\n<thead>\n<tr>\n<th>ID</th>\n<th>イベントの種類</th>\n<th>サイズ</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>31</td>\n<td>Buffer Empty</td>\n<td>4 bytes</td>\n<td>クライアントに割り当てられているメッセージストリーム ID.<br>rtmpdump などの一部のプログラムはバッファのサイズをできるだけ大きく設定し, サーバ側にできるだけ高速にデータを送信させる.<br>サーバ側が完全なバッファをそのようなクライアント側へ送信した際に, バッファを完全に送信し現在のバッファは空の状態であることをクライアント側へ伝えるためにこのイベントを送信する.<br>その後, サーバ側はクライアント側がそのバッファを消費しきるまで送信を待つ.</td>\n</tr>\n<tr>\n<td>32</td>\n<td>Buffer Ready (<abbr title="Open Broadcaster Software">OBS</abbr>),<br>Buffer Full (Red5)</td>\n<td>4 bytes</td>\n<td>クライアントに割り当てられているメッセージストリーム ID.<br>サーバ側がバッファを送信する準備が出来たことをクライアント側に伝えるためにこのイベントを送信する.</td>\n</tr>\n</tbody>\n</table>\n<h5 id="metadata-%E3%81%AE%E6%A7%8B%E9%80%A0"><a class="header-anchor" href="#metadata-%E3%81%AE%E6%A7%8B%E9%80%A0">¶</a> Metadata の構造</h5>\n<p>Metadata は公式ドキュメント<sup class="footnote-ref"><a href="#fn1" id="fnref1:3">[1:3]</a></sup>では以下のように定義されている.</p>\n<blockquote>\n<p>An aggregate message is a single message that contains a series of <abbr title="Real-Time Messaging Protocol">RTMP</abbr> sub-messages.</p>\n</blockquote>\n<ul>\n<li>集約(Metadata)メッセージは一連の <abbr title="Real-Time Messaging Protocol">RTMP</abbr> サブメッセージを含む単一のメッセージである.</li>\n</ul>\n<p>そしてそのサブメッセージの内訳は以下のように定義されている.</p>\n<ol>\n<li>ヘッダ</li>\n<li>メッセージデータ</li>\n<li>バックポインタ</li>\n</ol>\n<p>一方で, 各種 <abbr title="Open Source Software">OSS</abbr> 製品では以下のようにデコードしている.</p>\n<p>FFmpeg/rtmpproto.c#L2347-L2395<sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">handle_metadata</span><span class="hljs-params">(RTMPContext *rt, RTMPPacket *pkt)</span>\n</span>{\n    <span class="hljs-keyword">int</span> ret, old_flv_size, type;\n    <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *next;\n    <span class="hljs-keyword">uint8_t</span> *p;\n    <span class="hljs-keyword">uint32_t</span> <span class="hljs-built_in">size</span>;\n    <span class="hljs-keyword">uint32_t</span> ts, cts, pts = <span class="hljs-number">0</span>;\n\n    old_flv_size = update_offset(rt, pkt-&gt;<span class="hljs-built_in">size</span>);\n\n    <span class="hljs-keyword">if</span> ((ret = av_reallocp(&amp;rt-&gt;flv_data, rt-&gt;flv_size)) &lt; <span class="hljs-number">0</span>) {\n        rt-&gt;flv_size = rt-&gt;flv_off = <span class="hljs-number">0</span>;\n        <span class="hljs-keyword">return</span> ret;\n    }\n\n    next = pkt-&gt;data;\n    p    = rt-&gt;flv_data + old_flv_size;\n\n    <span class="hljs-comment">/* copy data while rewriting timestamps */</span>\n    ts = pkt-&gt;timestamp;\n\n    <span class="hljs-keyword">while</span> (next - pkt-&gt;data &lt; pkt-&gt;<span class="hljs-built_in">size</span> - RTMP_HEADER) {\n        type = bytestream_get_byte(&amp;next);\n        <span class="hljs-built_in">size</span> = bytestream_get_be24(&amp;next);\n        cts  = bytestream_get_be24(&amp;next);\n        cts |= bytestream_get_byte(&amp;next) &lt;&lt; <span class="hljs-number">24</span>;\n        <span class="hljs-keyword">if</span> (!pts)\n            pts = cts;\n        ts += cts - pts;\n        pts = cts;\n        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span> &gt; pkt-&gt;data + pkt-&gt;<span class="hljs-built_in">size</span> - next)\n            <span class="hljs-keyword">break</span>;\n        bytestream_put_byte(&amp;p, type);\n        bytestream_put_be24(&amp;p, <span class="hljs-built_in">size</span>);\n        bytestream_put_be24(&amp;p, ts);\n        bytestream_put_byte(&amp;p, ts &gt;&gt; <span class="hljs-number">24</span>);\n        <span class="hljs-built_in">memcpy</span>(p, next, <span class="hljs-built_in">size</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span>);\n        p    += <span class="hljs-built_in">size</span> + <span class="hljs-number">3</span>;\n        bytestream_put_be32(&amp;p, <span class="hljs-built_in">size</span> + RTMP_HEADER);\n        next += <span class="hljs-built_in">size</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span>;\n    }\n    <span class="hljs-keyword">if</span> (p != rt-&gt;flv_data + rt-&gt;flv_size) {\n        av_log(<span class="hljs-literal">NULL</span>, AV_LOG_WARNING, <span class="hljs-string">"Incomplete flv packets in "</span>\n                                     <span class="hljs-string">"RTMP_PT_METADATA packet\\n"</span>);\n        rt-&gt;flv_size = p - rt-&gt;flv_data;\n    }\n\n    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;\n}\n</code></pre>\n<p>obs-studio/rtmp.c#L1490-L1523<sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup>\nobs-studio/rtmp.c#L4972-L5059<sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-keyword">case</span> RTMP_PACKET_TYPE_FLASH_VIDEO:\n{\n    <span class="hljs-comment">/* go through FLV packets and handle metadata packets */</span>\n    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;\n    <span class="hljs-keyword">uint32_t</span> nTimeStamp = packet-&gt;m_nTimeStamp;\n\n    <span class="hljs-keyword">while</span> (pos + <span class="hljs-number">11</span> &lt; packet-&gt;m_nBodySize)\n    {\n        <span class="hljs-keyword">uint32_t</span> dataSize = AMF_DecodeInt24(packet-&gt;m_body + pos + <span class="hljs-number">1</span>);\t<span class="hljs-comment">/* size without header (11) and prevTagSize (4) */</span>\n\n        <span class="hljs-keyword">if</span> (pos + <span class="hljs-number">11</span> + dataSize + <span class="hljs-number">4</span> &gt; packet-&gt;m_nBodySize)\n        {\n            RTMP_Log(RTMP_LOGWARNING, <span class="hljs-string">"Stream corrupt?!"</span>);\n            <span class="hljs-keyword">break</span>;\n        }\n        <span class="hljs-keyword">if</span> (packet-&gt;m_body[pos] == <span class="hljs-number">0x12</span>)\n        {\n            HandleMetadata(r, packet-&gt;m_body + pos + <span class="hljs-number">11</span>, dataSize);\n        }\n        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (packet-&gt;m_body[pos] == <span class="hljs-number">8</span> || packet-&gt;m_body[pos] == <span class="hljs-number">9</span>)\n        {\n            nTimeStamp = AMF_DecodeInt24(packet-&gt;m_body + pos + <span class="hljs-number">4</span>);\n            nTimeStamp |= (packet-&gt;m_body[pos + <span class="hljs-number">7</span>] &lt;&lt; <span class="hljs-number">24</span>);\n        }\n        pos += (<span class="hljs-number">11</span> + dataSize + <span class="hljs-number">4</span>);\n    }\n    <span class="hljs-keyword">if</span> (!r-&gt;m_pausing)\n        r-&gt;m_mediaStamp = nTimeStamp;\n\n    <span class="hljs-comment">/* FLV tag(s) */</span>\n    <span class="hljs-comment">/*RTMP_Log(RTMP_LOGDEBUG, "%s, received: FLV tag(s) %lu bytes", __FUNCTION__, packet.m_nBodySize); */</span>\n    bHasMediaPacket = <span class="hljs-number">1</span>;\n    <span class="hljs-keyword">break</span>;\n}\n\n<span class="hljs-comment">// 中略</span>\n\n<span class="hljs-keyword">if</span> (packet.m_packetType == RTMP_PACKET_TYPE_FLASH_VIDEO)\n{\n    <span class="hljs-comment">/* basically we have to find the keyframe with the\n     * correct TS being nResumeTS\n     */</span>\n    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;\n    <span class="hljs-keyword">uint32_t</span> ts = <span class="hljs-number">0</span>;\n\n    <span class="hljs-keyword">while</span> (pos + <span class="hljs-number">11</span> &lt; nPacketLen)\n    {\n        <span class="hljs-comment">/* size without header (11) and prevTagSize (4) */</span>\n        <span class="hljs-keyword">uint32_t</span> dataSize =\n            AMF_DecodeInt24(packetBody + pos + <span class="hljs-number">1</span>);\n        ts = AMF_DecodeInt24(packetBody + pos + <span class="hljs-number">4</span>);\n        ts |= (packetBody[pos + <span class="hljs-number">7</span>] &lt;&lt; <span class="hljs-number">24</span>);\n\n<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _DEBUG</span>\n        RTMP_Log(RTMP_LOGDEBUG,\n                 <span class="hljs-string">"keyframe search: FLV Packet: type %02X, dataSize: %d, timeStamp: %d ms"</span>,\n                 packetBody[pos], dataSize, ts);\n<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>\n        <span class="hljs-comment">/* ok, is it a keyframe?:\n         * well doesn\'t work for audio!\n         */</span>\n        <span class="hljs-keyword">if</span> (packetBody[pos <span class="hljs-comment">/*6928, test 0 */</span> ] ==\n                r-&gt;m_read.initialFrameType\n                <span class="hljs-comment">/* &amp;&amp; (packetBody[11]&amp;0xf0) == 0x10 */</span> )\n        {\n            <span class="hljs-keyword">if</span> (ts == r-&gt;m_read.nResumeTS)\n            {\n                RTMP_Log(RTMP_LOGDEBUG,\n                         <span class="hljs-string">"Found keyframe with resume-keyframe timestamp!"</span>);\n                <span class="hljs-keyword">if</span> (r-&gt;m_read.nInitialFrameSize != dataSize\n                        || <span class="hljs-built_in">memcmp</span>(r-&gt;m_read.initialFrame,\n                                  packetBody + pos + <span class="hljs-number">11</span>,\n                                  r-&gt;m_read.\n                                  nInitialFrameSize) != <span class="hljs-number">0</span>)\n                {\n                    RTMP_Log(RTMP_LOGERROR,\n                             <span class="hljs-string">"FLV Stream: Keyframe doesn\'t match!"</span>);\n                    ret = RTMP_READ_ERROR;\n                    <span class="hljs-keyword">break</span>;\n                }\n                r-&gt;m_read.flags |= RTMP_READ_GOTFLVK;\n\n                <span class="hljs-comment">/* skip this packet?\n                 * check whether skippable:\n                 */</span>\n                <span class="hljs-keyword">if</span> (pos + <span class="hljs-number">11</span> + dataSize + <span class="hljs-number">4</span> &gt; nPacketLen)\n                {\n                    RTMP_Log(RTMP_LOGWARNING,\n                             <span class="hljs-string">"Non skipable packet since it doesn\'t end with chunk, stream corrupt!"</span>);\n                    ret = RTMP_READ_ERROR;\n                    <span class="hljs-keyword">break</span>;\n                }\n                packetBody += (pos + <span class="hljs-number">11</span> + dataSize + <span class="hljs-number">4</span>);\n                nPacketLen -= (pos + <span class="hljs-number">11</span> + dataSize + <span class="hljs-number">4</span>);\n\n                <span class="hljs-keyword">goto</span> stopKeyframeSearch;\n\n            }\n            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r-&gt;m_read.nResumeTS &lt; ts)\n            {\n                <span class="hljs-comment">/* the timestamp ts will only increase with\n                 * further packets, wait for seek\n                 */</span>\n                <span class="hljs-keyword">goto</span> stopKeyframeSearch;\n            }\n        }\n        pos += (<span class="hljs-number">11</span> + dataSize + <span class="hljs-number">4</span>);\n    }\n    <span class="hljs-keyword">if</span> (ts &lt; r-&gt;m_read.nResumeTS)\n    {\n        RTMP_Log(RTMP_LOGERROR,\n                 <span class="hljs-string">"First packet does not contain keyframe, all "</span>\n                 <span class="hljs-string">"timestamps are smaller than the keyframe "</span>\n                 <span class="hljs-string">"timestamp; probably the resume seek failed?"</span>);\n    }\nstopKeyframeSearch:\n    ;\n    <span class="hljs-keyword">if</span> (!(r-&gt;m_read.flags &amp; RTMP_READ_GOTFLVK))\n    {\n        RTMP_Log(RTMP_LOGERROR,\n                 <span class="hljs-string">"Couldn\'t find the seeked keyframe in this chunk!"</span>);\n        ret = RTMP_READ_IGNORE;\n        <span class="hljs-keyword">break</span>;\n    }\n}\n</code></pre>\n<p>red5-server-common/Aggregate.java#L108-L198<sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-comment">/**\n * Breaks-up the aggregate into its individual parts and returns them as a list. The parts are returned based on the ordering of the aggregate itself.\n * \n * <span class="hljs-doctag">@return</span> list of IRTMPEvent objects\n */</span>\n<span class="hljs-function"><span class="hljs-keyword">public</span> LinkedList&lt;IRTMPEvent&gt; <span class="hljs-title">getParts</span><span class="hljs-params">()</span> </span>{\n    LinkedList&lt;IRTMPEvent&gt; parts = <span class="hljs-keyword">new</span> LinkedList&lt;IRTMPEvent&gt;();\n    log.trace(<span class="hljs-string">"Aggregate data length: {}"</span>, data.limit());\n    <span class="hljs-keyword">int</span> position = data.position();\n    <span class="hljs-keyword">do</span> {\n        <span class="hljs-keyword">try</span> {\n            <span class="hljs-comment">// read the header</span>\n            <span class="hljs-comment">//log.trace("Hex: {}", data.getHexDump());</span>\n            <span class="hljs-keyword">byte</span> subType = data.get();\n            <span class="hljs-comment">// when we run into subtype 0 break out of here</span>\n            <span class="hljs-keyword">if</span> (subType == <span class="hljs-number">0</span>) {\n                log.debug(<span class="hljs-string">"Subtype 0 encountered within this aggregate, processing with exit"</span>);\n                <span class="hljs-keyword">break</span>;\n            }\n            <span class="hljs-keyword">int</span> size = IOUtils.readUnsignedMediumInt(data);\n            log.debug(<span class="hljs-string">"Data subtype: {} size: {}"</span>, subType, size);\n            <span class="hljs-comment">// TODO ensure the data contains all the bytes to support the specified size</span>\n            <span class="hljs-keyword">int</span> timestamp = IOUtils.readExtendedMediumInt(data);\n            <span class="hljs-comment">/*timestamp = ntohap((GETIBPOINTER(buffer) + 4)); 0x12345678 == 34 56 78 12*/</span>\n            <span class="hljs-keyword">int</span> streamId = IOUtils.readUnsignedMediumInt(data);\n            log.debug(<span class="hljs-string">"Data timestamp: {} stream id: {}"</span>, timestamp, streamId);\n            Header partHeader = <span class="hljs-keyword">new</span> Header();\n            partHeader.setChannelId(header.getChannelId());\n            partHeader.setDataType(subType);\n            partHeader.setSize(size);\n            <span class="hljs-comment">// use the stream id from the aggregate\'s header</span>\n            partHeader.setStreamId(header.getStreamId());\n            partHeader.setTimer(timestamp);\n            <span class="hljs-comment">// timer delta == time stamp - timer base</span>\n            <span class="hljs-comment">// the back pointer may be used to verify the size of the individual part</span>\n            <span class="hljs-comment">// it will be equal to the data size + header size</span>\n            <span class="hljs-keyword">int</span> backPointer = <span class="hljs-number">0</span>;\n            <span class="hljs-keyword">switch</span> (subType) {\n                <span class="hljs-keyword">case</span> TYPE_AUDIO_DATA:\n                    AudioData audio = <span class="hljs-keyword">new</span> AudioData(data.getSlice(size));\n                    audio.setTimestamp(timestamp);\n                    audio.setHeader(partHeader);\n                    log.debug(<span class="hljs-string">"Audio header: {}"</span>, audio.getHeader());\n                    parts.add(audio);\n                    <span class="hljs-comment">//log.trace("Hex: {}", data.getHexDump());</span>\n                    <span class="hljs-comment">// ensure 4 bytes left to read an int</span>\n                    <span class="hljs-keyword">if</span> (data.position() &lt; data.limit() - <span class="hljs-number">4</span>) {\n                        backPointer = data.getInt();\n                        <span class="hljs-comment">//log.trace("Back pointer: {}", backPointer);</span>\n                        <span class="hljs-keyword">if</span> (backPointer != (size + <span class="hljs-number">11</span>)) {\n                            log.debug(<span class="hljs-string">"Data size ({}) and back pointer ({}) did not match"</span>, size, backPointer);\n                        }\n                    }\n                    <span class="hljs-keyword">break</span>;\n                <span class="hljs-keyword">case</span> TYPE_VIDEO_DATA:\n                    VideoData video = <span class="hljs-keyword">new</span> VideoData(data.getSlice(size));\n                    video.setTimestamp(timestamp);\n                    video.setHeader(partHeader);\n                    log.debug(<span class="hljs-string">"Video header: {}"</span>, video.getHeader());\n                    parts.add(video);\n                    <span class="hljs-comment">//log.trace("Hex: {}", data.getHexDump());</span>\n                    <span class="hljs-comment">// ensure 4 bytes left to read an int</span>\n                    <span class="hljs-keyword">if</span> (data.position() &lt; data.limit() - <span class="hljs-number">4</span>) {\n                        backPointer = data.getInt();\n                        <span class="hljs-comment">//log.trace("Back pointer: {}", backPointer);</span>\n                        <span class="hljs-keyword">if</span> (backPointer != (size + <span class="hljs-number">11</span>)) {\n                            log.debug(<span class="hljs-string">"Data size ({}) and back pointer ({}) did not match"</span>, size, backPointer);\n                        }\n                    }\n                    <span class="hljs-keyword">break</span>;\n                <span class="hljs-keyword">default</span>:\n                    log.debug(<span class="hljs-string">"Non-A/V subtype: {}"</span>, subType);\n                    Unknown unk = <span class="hljs-keyword">new</span> Unknown(subType, data.getSlice(size));\n                    unk.setTimestamp(timestamp);\n                    unk.setHeader(partHeader);\n                    parts.add(unk);\n                    <span class="hljs-comment">// ensure 4 bytes left to read an int</span>\n                    <span class="hljs-keyword">if</span> (data.position() &lt; data.limit() - <span class="hljs-number">4</span>) {\n                        backPointer = data.getInt();\n                    }\n            }\n            position = data.position();\n        } <span class="hljs-keyword">catch</span> (Exception e) {\n            log.error(<span class="hljs-string">"Exception decoding aggregate parts"</span>, e);\n            <span class="hljs-keyword">break</span>;\n        }\n        log.trace(<span class="hljs-string">"Data position: {}"</span>, position);\n    } <span class="hljs-keyword">while</span> (position &lt; data.limit());\n    log.trace(<span class="hljs-string">"Aggregate processing complete, {} parts extracted"</span>, parts.size());\n    <span class="hljs-keyword">return</span> parts;\n}\n</code></pre>\n<p>上記の各実装において, <code>type/subType</code>, <code>size/dataSize</code> および <code>cts/nTimestamp/timestamp</code> として表れているフィールドは公式ドキュメント<sup class="footnote-ref"><a href="#fn1" id="fnref1:4">[1:4]</a></sup>中の以下の部分で定義されている.</p>\n<blockquote>\n<p>6.1.1.  Message Header</p>\n<p>The message header contains the following:</p>\n<p>Message Type: One byte field to represent the message type. A range of type IDs (1-6) are reserved for protocol control messages.<br>\nLength: Three-byte field that represents the size of the payload in bytes. It is set in big-endian format.<br>\nTimestamp: Four-byte field that contains a timestamp of the message. The 4 bytes are packed in the big-endian order.<br>\nMessage Stream Id: Three-byte field that identifies the stream of the message. These bytes are set in big-endian format.</p>\n</blockquote>\n<ol>\n<li>メッセージの種類 (ID, 1 byte)</li>\n</ol>\n<ul>\n<li>1 - 6 はプロトコル制御メッセージ用に予約されている.</li>\n</ul>\n<ol start="2">\n<li>長さ(3 bytes)</li>\n</ol>\n<ul>\n<li>Big Endianである.</li>\n</ul>\n<ol start="3">\n<li>タイムスタンプ (4 bytes)</li>\n</ol>\n<ul>\n<li>Big Endianである. と書かれているが, 上記の各実装では以下のデコードを行っている:\n<ul>\n<li>チャンク中の最下位の 1 byte を実際のタイムスタンプの最上位 1 byte とする.</li>\n<li>実際のタイムスタンプからチャンクにエンコードする場合は, 上記の逆の操作を行う.</li>\n</ul>\n</li>\n</ul>\n<ol start="4">\n<li>メッセージストリーム ID (3 bytes)</li>\n</ol>\n<ul>\n<li>Big Endian である.</li>\n</ul>\n<p>メッセージストリーム ID について:</p>\n<blockquote>\n<p>The message stream ID of the aggregate message overrides the message stream IDs of the sub-messages inside the aggregate.</p>\n</blockquote>\n<ul>\n<li>集約メッセージのチャンクに割り当てられているメッセージストリーム ID はサブメッセージに割り当てられているメッセージストリーム ID を無視する.</li>\n</ul>\n<p>タイムスタンプについて:</p>\n<blockquote>\n<p>The difference between the timestamps of the aggregate message and the first sub-message is the offset used to renormalize the timestamps of the sub-messages to the stream timescale.\nThe offset is added to each sub-message’s timestamp to arrive at the normalized stream time.\nThe timestamp of the first sub-message SHOULD be the same as the timestamp of the aggregate message, so the offset SHOULD be zero.</p>\n</blockquote>\n<ul>\n<li>サブメッセージのタイムスタンプはチャンクメッセージヘッダに入力されたタイムスタンプを基準にしたオフセットである.</li>\n<li>チャンクメッセージヘッダのタイムスタンプに当該フィールドの値を加算することで実際のタイムスタンプを求めることができる.</li>\n<li>最初のサブメッセージのタイムスタンプはチャンクメッセージヘッダのそれと同一で<strong>あるべき</strong>なので, オフセットは 0 で<strong>あるべき</strong>である.</li>\n</ul>\n<p>そして, バックポインタについては公式ドキュメント<sup class="footnote-ref"><a href="#fn1" id="fnref1:5">[1:5]</a></sup>では以下のように定義されている.</p>\n<blockquote>\n<p>The back pointer contains the size of the previous message including its header.\nIt is included to match the format of FLV file and is used for backward seek.</p>\n</blockquote>\n<ul>\n<li>サブヘッダを含む直前のサブメッセージのサイズである.</li>\n<li>FLV ファイルのフォーマットに一致しており, 逆シークに使われる.</li>\n</ul>\n<p>当該サブヘッダに入力するメッセージの種類は上記の各実装を参考にすると以下のようである.</p>\n<table>\n<thead>\n<tr>\n<th>ID</th>\n<th>サブメッセージの種類</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>8</td>\n<td>Audio</td>\n<td>音声データ.<br>生のバイト列である.</td>\n</tr>\n<tr>\n<td>9</td>\n<td>Video</td>\n<td>映像データ.<br>〃</td>\n</tr>\n<tr>\n<td>18</td>\n<td>Data(Official),<br>Notify(FFmpeg, Red5),<br>Info(<abbr title="Open Broadcaster Software">OBS</abbr>)</td>\n<td>サブメッセージのメタデータ.<br>AMF0 がサブメッセージに適用されている.</td>\n</tr>\n</tbody>\n</table>\n<p>上記の FFmpeg および <abbr title="Open Broadcaster Software">OBS</abbr> の実装に着目すると, いずれもメッセージストリーム ID に相当するフィールドを意図的にデコードして<strong>いない</strong>ことを確認できる. 同様に, バックポインタの値もデコードして<strong>いない</strong>ことを確認できる.<br>\nところで, 上記ソースコード中に <code>1</code>, <code>3</code>, <code>4</code>, <code>7</code> および <code>11</code> といったマジックナンバーが散見される. これらは以下の計算に用いられている.</p>\n<p>FFmpeg:</p>\n<ul>\n<li>3: メッセージストリーム ID のサイズ. デコードはしないがそのままコピーして使い回すため, コピーするサイズをその分だけ加算している.</li>\n<li>4: バックポインタのサイズ. 受信したチャンクに入力されている分に関してはデコードしないが, 送信するチャンクには入力が必須なため, サイズをその分だけ加算している.</li>\n<li><abbr title="Real-Time Messaging Protocol">RTMP</abbr>_HEADER: 11. つまり Metadata チャンクに入力されているサブヘッダ全体のサイズである.</li>\n</ul>\n<p><abbr title="Open Broadcaster Software">OBS</abbr>:</p>\n<ul>\n<li>1: サブメッセージの種類 (ID). <abbr title="Open Broadcaster Software">OBS</abbr> ではメッセージストリーム ID を読み飛ばしている箇所があるため, その分だけオフセットしている.</li>\n<li>4: タイムスタンプの開始位置. サブメッセージの種類を表す ID (1 byte) と サブメッセージの長さ (3 bytes) を合計した分だけオフセットしている.</li>\n<li>7: タイムスタンプの <strong>4 bytes目</strong>の位置. タイムスタンプの開始位置にタイムスタンプの上位 3 bytes のサイズをさらに合計した分だけオフセットしている.</li>\n<li>11: Metadata チャンクに入力されているサブヘッダのサイズ.</li>\n</ul>\n<h4 id="invoke(connect)"><a class="header-anchor" href="#invoke(connect)">¶</a> Invoke(connect)</h4>\n<p>Invoke(connect) およびその応答メッセージは公式ドキュメント<sup class="footnote-ref"><a href="#fn1" id="fnref1:6">[1:6]</a></sup>では以下のように定義されている.</p>\n<p>要求メッセージ:</p>\n<table>\n<thead>\n<tr>\n<th>フィールド名</th>\n<th>データ型</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>コマンド名</td>\n<td>String</td>\n<td>connect</td>\n</tr>\n<tr>\n<td>トランザクション ID</td>\n<td>Number</td>\n<td>1</td>\n</tr>\n<tr>\n<td>コマンドオブジェクト</td>\n<td>Object</td>\n<td>名前と値のペア.<br>クライアント側のアプリケーションを接続するために必要な情報が書き込まれている.</td>\n</tr>\n<tr>\n<td>追加のユーザ引数</td>\n<td>Object</td>\n<td>コマンドオブジェクトの他に必要な情報がある場合に入力する.</td>\n</tr>\n</tbody>\n</table>\n<p>応答メッセージ:</p>\n<table>\n<thead>\n<tr>\n<th>フィールド名</th>\n<th>データ型</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>コマンド名</td>\n<td>String</td>\n<td>_result(アプリケーションを接続できる時)<br>もしくは<br>_error(アプリケーションを接続できない時)</td>\n</tr>\n<tr>\n<td>トランザクション ID</td>\n<td>Number</td>\n<td>1</td>\n</tr>\n<tr>\n<td>プロパティ</td>\n<td>Object</td>\n<td>名前と値のペア.<br>サーバ側のアプリケーションを接続するために必要な情報を入力する.</td>\n</tr>\n<tr>\n<td>インフォメーション</td>\n<td>Object</td>\n<td>名前と値のペア.<br>サーバ側の応答の状態を表すために必要な情報を入力する.</td>\n</tr>\n</tbody>\n</table>\n<p>コマンドオブジェクト:</p>\n<table>\n<thead>\n<tr>\n<th>プロパティ</th>\n<th>データ型</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>app</td>\n<td>String</td>\n<td>クライアントが接続しているサーバアプリケーションの名前.<br>多くの場合において, 起動時に渡される URL から参照する.<br>そのパターンは次の通りである: protocol://server[:port][/app][/playpath]</td>\n</tr>\n<tr>\n<td>type</td>\n<td>String</td>\n<td>nonprivate.<br>公式ドキュメントには定義されていないが FFmpeg や <abbr title="Open Broadcaster Software">OBS</abbr> で入力されている.</td>\n</tr>\n<tr>\n<td>flashVer</td>\n<td>String</td>\n<td>Flash Player のバージョン.<br>入力側と出力側で入力内容が違う.<br>出力側の場合: FMLE/3.0 (compatible; &lt;クライアント側のツールやライブラリの識別情報&gt;)<br>入力側の場合: &lt;OSの識別名&gt; &lt;Flash Playerのバージョン(カンマ区切り)&gt;</td>\n</tr>\n<tr>\n<td>swfUrl</td>\n<td>String</td>\n<td>アプリケーション接続に必要な SWF ファイルの URL.<br>ツールによってデフォルトの入力内容に違いがある. 例えば:<br>FFmpeg の場合: 入力なし.<br><abbr title="Open Broadcaster Software">OBS</abbr> の場合: tcUrl と同じ値.</td>\n</tr>\n<tr>\n<td>tcUrl</td>\n<td>String</td>\n<td>接続先サーバの URL.<br>protocol://server[:port][/app] のフォーマットに従って入力する.<br>デフォルトは起動時にコマンドラインで渡された URL を参照する.</td>\n</tr>\n<tr>\n<td>fpad</td>\n<td>Boolean</td>\n<td>プロキシが使われているなら true を入力する.</td>\n</tr>\n<tr>\n<td>capabilities</td>\n<td>Number</td>\n<td>15. 公式ドキュメントには定義されていないが FFmpeg や <abbr title="Open Broadcaster Software">OBS</abbr> では入力されている.</td>\n</tr>\n<tr>\n<td>audioCodecs</td>\n<td>Number</td>\n<td>クライアントがサポートする音声コーデックの情報.</td>\n</tr>\n<tr>\n<td>videoCodecs</td>\n<td>Number</td>\n<td>クライアントがサポートする映像コーデックの情報.</td>\n</tr>\n<tr>\n<td>videoFunction</td>\n<td>Number</td>\n<td>クライアントがサポートする特別なビデオ機能の情報.</td>\n</tr>\n<tr>\n<td>pageUrl</td>\n<td>String</td>\n<td>SWF ファイルがロードされた Web ページの URL.</td>\n</tr>\n<tr>\n<td>objectEncoding</td>\n<td>Number</td>\n<td>AMF のエンコーディングメソッド.</td>\n</tr>\n</tbody>\n</table>\n<p>サポートしている音声コーデック:</p>\n<table>\n<thead>\n<tr>\n<th>ビットフラグ</th>\n<th>コーデック</th>\n<th>備考</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0x0001</td>\n<td>Raw</td>\n<td></td>\n</tr>\n<tr>\n<td>0x0002</td>\n<td>ADPCM</td>\n<td></td>\n</tr>\n<tr>\n<td>0x0004</td>\n<td>MP3</td>\n<td></td>\n</tr>\n<tr>\n<td>0x0008</td>\n<td>Intel</td>\n<td>使われていない.</td>\n</tr>\n<tr>\n<td>0x0010</td>\n<td>Unused</td>\n<td>使われていない.</td>\n</tr>\n<tr>\n<td>0x0020</td>\n<td>Nerry8</td>\n<td>NellyMoser at 8 kHz.</td>\n</tr>\n<tr>\n<td>0x0040</td>\n<td>Nerry</td>\n<td>NellyMoser at 5, 11, 22 and 44 kHz.</td>\n</tr>\n<tr>\n<td>0x0080</td>\n<td>G711A</td>\n<td>Adobe Media Server 限定のコーデックである.</td>\n</tr>\n<tr>\n<td>0x0100</td>\n<td>G711U</td>\n<td>同上.</td>\n</tr>\n<tr>\n<td>0x0200</td>\n<td>NELLY16</td>\n<td>NellyMouser at 16 kHz.</td>\n</tr>\n<tr>\n<td>0x0400</td>\n<td>AAC</td>\n<td></td>\n</tr>\n<tr>\n<td>0x0800</td>\n<td>Speex</td>\n<td></td>\n</tr>\n<tr>\n<td>0xFFFF</td>\n<td>上記のすべて</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>サポートしている映像コーデック:</p>\n<table>\n<thead>\n<tr>\n<th>ビットフラグ</th>\n<th>コーデック</th>\n<th>備考</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0x0001</td>\n<td>Unused</td>\n<td>廃れている.</td>\n</tr>\n<tr>\n<td>0x0002</td>\n<td>JPEG</td>\n<td>廃れている.</td>\n</tr>\n<tr>\n<td>0x0004</td>\n<td>Sorenson</td>\n<td></td>\n</tr>\n<tr>\n<td>0x0008</td>\n<td>Homebrew</td>\n<td></td>\n</tr>\n<tr>\n<td>0x0010</td>\n<td>On2VP6</td>\n<td>Flash 8 以降にサポートしている.</td>\n</tr>\n<tr>\n<td>0x0020</td>\n<td>On2VP6 with alpha channel</td>\n<td>同上.</td>\n</tr>\n<tr>\n<td>0x0040</td>\n<td>Homebrew v2</td>\n<td></td>\n</tr>\n<tr>\n<td>0x0080</td>\n<td>H264</td>\n<td></td>\n</tr>\n<tr>\n<td>0x00FF</td>\n<td>上記のすべて</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>サポートしているビデオ機能:</p>\n<table>\n<thead>\n<tr>\n<th>ビットフラグ</th>\n<th>機能</th>\n<th>備考</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Seek</td>\n<td>クライアント側はフレーム精度の高いシークを実行できる.</td>\n</tr>\n</tbody>\n</table>\n<p>サポートしているエンコーディングメソッド:</p>\n<table>\n<thead>\n<tr>\n<th>ビットフラグ</th>\n<th>エンコーディング</th>\n<th>備考</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>AMF0</td>\n<td>Flash 6 以降にサポートしている.</td>\n</tr>\n<tr>\n<td>3</td>\n<td>AMF3</td>\n<td>Flash 9 (ActionScript 3) 以降にサポートしている.</td>\n</tr>\n</tbody>\n</table>\n<p>応答メッセージのプロパティフィールドおよびインフォメーションフィールドには公式に定められた仕様が存在しない. よって, 各種 <abbr title="Open Source Software">OSS</abbr> 製品の実装内容から特定できる範囲で紹介する.</p>\n<p>FFmpeg/rtmpproto.c#L542-L575<sup class="footnote-ref"><a href="#fn25" id="fnref25">[25]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-comment">// Send _result NetConnection.Connect.Success to connect</span>\n<span class="hljs-keyword">if</span> ((ret = ff_rtmp_packet_create(&amp;pkt, RTMP_SYSTEM_CHANNEL,\n                                 RTMP_PT_INVOKE, <span class="hljs-number">0</span>,\n                                 RTMP_PKTDATA_DEFAULT_SIZE)) &lt; <span class="hljs-number">0</span>)\n    <span class="hljs-keyword">return</span> ret;\n\np = pkt.data;\nff_amf_write_string(&amp;p, <span class="hljs-string">"_result"</span>);\nff_amf_write_number(&amp;p, seqnum);\n\nff_amf_write_object_start(&amp;p);\nff_amf_write_field_name(&amp;p, <span class="hljs-string">"fmsVer"</span>);\nff_amf_write_string(&amp;p, <span class="hljs-string">"FMS/3,0,1,123"</span>);\nff_amf_write_field_name(&amp;p, <span class="hljs-string">"capabilities"</span>);\nff_amf_write_number(&amp;p, <span class="hljs-number">31</span>);\nff_amf_write_object_end(&amp;p);\n\nff_amf_write_object_start(&amp;p);\nff_amf_write_field_name(&amp;p, <span class="hljs-string">"level"</span>);\nff_amf_write_string(&amp;p, <span class="hljs-string">"status"</span>);\nff_amf_write_field_name(&amp;p, <span class="hljs-string">"code"</span>);\nff_amf_write_string(&amp;p, <span class="hljs-string">"NetConnection.Connect.Success"</span>);\nff_amf_write_field_name(&amp;p, <span class="hljs-string">"description"</span>);\nff_amf_write_string(&amp;p, <span class="hljs-string">"Connection succeeded."</span>);\nff_amf_write_field_name(&amp;p, <span class="hljs-string">"objectEncoding"</span>);\nff_amf_write_number(&amp;p, <span class="hljs-number">0</span>);\nff_amf_write_object_end(&amp;p);\n\npkt.<span class="hljs-built_in">size</span> = p - pkt.data;\nret = ff_rtmp_packet_write(rt-&gt;stream, &amp;pkt, rt-&gt;out_chunk_size,\n                           &amp;rt-&gt;prev_pkt[<span class="hljs-number">1</span>], &amp;rt-&gt;nb_prev_pkt[<span class="hljs-number">1</span>]);\nff_rtmp_packet_destroy(&amp;pkt);\n<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)\n    <span class="hljs-keyword">return</span> ret;\n</code></pre>\n<p>プロパティ:</p>\n<table>\n<thead>\n<tr>\n<th>プロパティ</th>\n<th>データ型</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>fmsVer</td>\n<td>String</td>\n<td>FMS/&lt;Adobe Media Serverのバージョン(カンマ区切り)&gt;</td>\n</tr>\n<tr>\n<td>capabilities</td>\n<td>Number</td>\n<td>31(暫定)</td>\n</tr>\n</tbody>\n</table>\n<p>インフォメーション:</p>\n<table>\n<thead>\n<tr>\n<th>プロパティ</th>\n<th>データ型</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>level</td>\n<td>String</td>\n<td>status</td>\n</tr>\n<tr>\n<td>code</td>\n<td>String</td>\n<td>NetConnection.Connect.Success</td>\n</tr>\n<tr>\n<td>description</td>\n<td>String</td>\n<td>Connection succeeded.</td>\n</tr>\n<tr>\n<td>objectEncoding</td>\n<td>Number</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>そして, 当該チャンクの送受信の手順は公式ドキュメント<sup class="footnote-ref"><a href="#fn1" id="fnref1:7">[1:7]</a></sup>では以下のように定義されている.</p>\n<div id="rtmp-invoke-connect-sequences-official">\n<a href="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuRArLGWAyGrGUDpS_xXvy-FcpiTDsnytBN_SjEHnq_h7ZJrFr_KysTNsk77wuyRvUWgsjbpEEPcfUIKAkdOAmQb5PQb5LWgUUMNvsQaQoVbvUQd99PfS476G2eXQAuNmpBoK_785n-JilFpodDIKzDHSa1d1cLMf2lfGSnIS4lDImZDJIZAm612SMg8Ga8gi2AWFwXA4FaodKMnnQ36GxvoVLrAKdwCHN5AKcfYhu9IQdfc7pPlGW8WlIYqkpG46X4DgNWemZ040" target="_self"><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuRArLGWAyGrGUDpS_xXvy-FcpiTDsnytBN_SjEHnq_h7ZJrFr_KysTNsk77wuyRvUWgsjbpEEPcfUIKAkdOAmQb5PQb5LWgUUMNvsQaQoVbvUQd99PfS476G2eXQAuNmpBoK_785n-JilFpodDIKzDHSa1d1cLMf2lfGSnIS4lDImZDJIZAm612SMg8Ga8gi2AWFwXA4FaodKMnnQ36GxvoVLrAKdwCHN5AKcfYhu9IQdfc7pPlGW8WlIYqkpG46X4DgNWemZ040" alt=""></a></div>\n<p id="caption-rtmp-invoke-connect-sequences-official">図5. 公式が説明している Invoke(connect) のシーケンス</p>\n<blockquote>\n<p>The message flow during the execution of the command is:</p>\n<ol>\n<li>Client sends the connect command to the server to request to connect with the server application instance.</li>\n<li>After receiving the connect command, the server sends the protocol message ’Window Acknowledgement Size’ to the client. The server also connects to the application mentioned in the connect command.</li>\n<li>The server sends the protocol message ’Set Peer Bandwidth’ to the client.</li>\n<li>The client sends the protocol message ’Window Acknowledgement Size’ to the server after processing the protocol message ’Set Peer Bandwidth’.</li>\n<li>The server sends an another protocol message of type User Control Message(StreamBegin) to the client.</li>\n<li>The server sends the result command message informing the client of the connection status (success/fail). The command specifies the transaction ID (always equal to 1 for the connect command). The message also specifies the properties, such as Flash Media Server version (string). In addition it specificies other connection response related information like level (string), code (string), description (string), objectencoding (number), etc.</li>\n</ol>\n</blockquote>\n<ul>\n<li>クライアント側はサーバ側のアプリケーションとの接続を要求するために, サーバ側に Invoke(connect) を送信する.</li>\n<li>Invoke(connect) の受信後, サーバ側は プロトコルメッセージ Window Acknowledgement Size / Client BandWidth をクライアント側に送信する. サーバ側もまた connect コマンドで指定されたアプリケーションに接続する.</li>\n<li>サーバ側はクライアント側にプロトコルメッセージ Set Peer BandWidth / Client BandWidth をクライアント側に送信する.</li>\n<li>Set Peer BandWidth / Client BandWidth の処理後に, クライアント側はサーバ側にプロトコルメッセージ Window Acknowledgement Size / Server BandWidth を送信する.</li>\n<li>サーバ側はクライアント側に他のプロトコルメッセージである User Control(Stream Begin) を送信する.</li>\n<li>サーバ側はクライアント側にクライアント側の接続状態を通知する Invoke(_result) を送信する.</li>\n</ul>\n<p>以下に FFmpeg が実際に送信しているメッセージを示す.</p>\n<p>FFmpeg/rtmpproto.c#L485-L588<sup class="footnote-ref"><a href="#fn26" id="fnref26">[26]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-comment">// Send Window Acknowledgement Size (as defined in specification)</span>\n<span class="hljs-keyword">if</span> ((ret = ff_rtmp_packet_create(&amp;pkt, RTMP_NETWORK_CHANNEL,\n                                 RTMP_PT_WINDOW_ACK_SIZE, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>)) &lt; <span class="hljs-number">0</span>)\n    <span class="hljs-keyword">return</span> ret;\np = pkt.data;\n<span class="hljs-comment">// Inform the peer about how often we want acknowledgements about what</span>\n<span class="hljs-comment">// we send. (We don\'t check for the acknowledgements currently.)</span>\nbytestream_put_be32(&amp;p, rt-&gt;max_sent_unacked);\npkt.<span class="hljs-built_in">size</span> = p - pkt.data;\nret = ff_rtmp_packet_write(rt-&gt;stream, &amp;pkt, rt-&gt;out_chunk_size,\n                           &amp;rt-&gt;prev_pkt[<span class="hljs-number">1</span>], &amp;rt-&gt;nb_prev_pkt[<span class="hljs-number">1</span>]);\nff_rtmp_packet_destroy(&amp;pkt);\n<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)\n    <span class="hljs-keyword">return</span> ret;\n<span class="hljs-comment">// Set Peer Bandwidth</span>\n<span class="hljs-keyword">if</span> ((ret = ff_rtmp_packet_create(&amp;pkt, RTMP_NETWORK_CHANNEL,\n                                 RTMP_PT_SET_PEER_BW, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)) &lt; <span class="hljs-number">0</span>)\n    <span class="hljs-keyword">return</span> ret;\np = pkt.data;\n<span class="hljs-comment">// Tell the peer to only send this many bytes unless it gets acknowledgements.</span>\n<span class="hljs-comment">// This could be any arbitrary value we want here.</span>\nbytestream_put_be32(&amp;p, rt-&gt;max_sent_unacked);\nbytestream_put_byte(&amp;p, <span class="hljs-number">2</span>); <span class="hljs-comment">// dynamic</span>\npkt.<span class="hljs-built_in">size</span> = p - pkt.data;\nret = ff_rtmp_packet_write(rt-&gt;stream, &amp;pkt, rt-&gt;out_chunk_size,\n                           &amp;rt-&gt;prev_pkt[<span class="hljs-number">1</span>], &amp;rt-&gt;nb_prev_pkt[<span class="hljs-number">1</span>]);\nff_rtmp_packet_destroy(&amp;pkt);\n<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)\n    <span class="hljs-keyword">return</span> ret;\n\n<span class="hljs-comment">// User control</span>\n<span class="hljs-keyword">if</span> ((ret = ff_rtmp_packet_create(&amp;pkt, RTMP_NETWORK_CHANNEL,\n                                 RTMP_PT_USER_CONTROL, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>)) &lt; <span class="hljs-number">0</span>)\n    <span class="hljs-keyword">return</span> ret;\n\np = pkt.data;\nbytestream_put_be16(&amp;p, <span class="hljs-number">0</span>); <span class="hljs-comment">// 0 -&gt; Stream Begin</span>\nbytestream_put_be32(&amp;p, <span class="hljs-number">0</span>); <span class="hljs-comment">// Stream 0</span>\nret = ff_rtmp_packet_write(rt-&gt;stream, &amp;pkt, rt-&gt;out_chunk_size,\n                           &amp;rt-&gt;prev_pkt[<span class="hljs-number">1</span>], &amp;rt-&gt;nb_prev_pkt[<span class="hljs-number">1</span>]);\nff_rtmp_packet_destroy(&amp;pkt);\n<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)\n    <span class="hljs-keyword">return</span> ret;\n\n<span class="hljs-comment">// Chunk size</span>\n<span class="hljs-keyword">if</span> ((ret = ff_rtmp_packet_create(&amp;pkt, RTMP_NETWORK_CHANNEL,\n                                 RTMP_PT_CHUNK_SIZE, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>)) &lt; <span class="hljs-number">0</span>)\n    <span class="hljs-keyword">return</span> ret;\n\np = pkt.data;\nbytestream_put_be32(&amp;p, rt-&gt;out_chunk_size);\nret = ff_rtmp_packet_write(rt-&gt;stream, &amp;pkt, rt-&gt;out_chunk_size,\n                           &amp;rt-&gt;prev_pkt[<span class="hljs-number">1</span>], &amp;rt-&gt;nb_prev_pkt[<span class="hljs-number">1</span>]);\nff_rtmp_packet_destroy(&amp;pkt);\n<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)\n    <span class="hljs-keyword">return</span> ret;\n\n<span class="hljs-comment">// Send _result NetConnection.Connect.Success to connect</span>\n<span class="hljs-keyword">if</span> ((ret = ff_rtmp_packet_create(&amp;pkt, RTMP_SYSTEM_CHANNEL,\n                                 RTMP_PT_INVOKE, <span class="hljs-number">0</span>,\n                                 RTMP_PKTDATA_DEFAULT_SIZE)) &lt; <span class="hljs-number">0</span>)\n    <span class="hljs-keyword">return</span> ret;\n\np = pkt.data;\nff_amf_write_string(&amp;p, <span class="hljs-string">"_result"</span>);\nff_amf_write_number(&amp;p, seqnum);\n\nff_amf_write_object_start(&amp;p);\nff_amf_write_field_name(&amp;p, <span class="hljs-string">"fmsVer"</span>);\nff_amf_write_string(&amp;p, <span class="hljs-string">"FMS/3,0,1,123"</span>);\nff_amf_write_field_name(&amp;p, <span class="hljs-string">"capabilities"</span>);\nff_amf_write_number(&amp;p, <span class="hljs-number">31</span>);\nff_amf_write_object_end(&amp;p);\n\nff_amf_write_object_start(&amp;p);\nff_amf_write_field_name(&amp;p, <span class="hljs-string">"level"</span>);\nff_amf_write_string(&amp;p, <span class="hljs-string">"status"</span>);\nff_amf_write_field_name(&amp;p, <span class="hljs-string">"code"</span>);\nff_amf_write_string(&amp;p, <span class="hljs-string">"NetConnection.Connect.Success"</span>);\nff_amf_write_field_name(&amp;p, <span class="hljs-string">"description"</span>);\nff_amf_write_string(&amp;p, <span class="hljs-string">"Connection succeeded."</span>);\nff_amf_write_field_name(&amp;p, <span class="hljs-string">"objectEncoding"</span>);\nff_amf_write_number(&amp;p, <span class="hljs-number">0</span>);\nff_amf_write_object_end(&amp;p);\n\npkt.<span class="hljs-built_in">size</span> = p - pkt.data;\nret = ff_rtmp_packet_write(rt-&gt;stream, &amp;pkt, rt-&gt;out_chunk_size,\n                           &amp;rt-&gt;prev_pkt[<span class="hljs-number">1</span>], &amp;rt-&gt;nb_prev_pkt[<span class="hljs-number">1</span>]);\nff_rtmp_packet_destroy(&amp;pkt);\n<span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)\n    <span class="hljs-keyword">return</span> ret;\n\n<span class="hljs-keyword">if</span> ((ret = ff_rtmp_packet_create(&amp;pkt, RTMP_SYSTEM_CHANNEL,\n                                 RTMP_PT_INVOKE, <span class="hljs-number">0</span>, <span class="hljs-number">30</span>)) &lt; <span class="hljs-number">0</span>)\n    <span class="hljs-keyword">return</span> ret;\np = pkt.data;\nff_amf_write_string(&amp;p, <span class="hljs-string">"onBWDone"</span>);\nff_amf_write_number(&amp;p, <span class="hljs-number">0</span>);\nff_amf_write_null(&amp;p);\nff_amf_write_number(&amp;p, <span class="hljs-number">8192</span>);\npkt.<span class="hljs-built_in">size</span> = p - pkt.data;\nret = ff_rtmp_packet_write(rt-&gt;stream, &amp;pkt, rt-&gt;out_chunk_size,\n                           &amp;rt-&gt;prev_pkt[<span class="hljs-number">1</span>], &amp;rt-&gt;nb_prev_pkt[<span class="hljs-number">1</span>]);\nff_rtmp_packet_destroy(&amp;pkt);\n</code></pre>\n<div id="rtmp-invoke-connect-sequences-ffmpeg">\n<a href="https://www.plantuml.com/plantuml/svg/bP51IyD048Nl-HLpR0_LUo5I4o_UX20vIiWExPBDB6msBVIMNH0B1Rrv54GGBteG4SH_C-t_C8r5n4lhTTvx7xmteyfcnjQb2i8Gs5-pVsM_OFVExf7T0xiNRfRhv-NguvARMsxk3Y0CWytPFtNwVPUuWi4Hi7jZ_yd-PWYdDDK5zd9DXBdj1p_Ij-zlUWYf9A5dS9mNf6SAnHXB90k9d2CSGe9cYWQYZ4GgXPtivYLeuGn_PrfChEG6-W_CUTKYOatMQDLBhC6iX0Z7alQe54zgAhe6kxtRlIuCLhNQPwzjG5EKdcZ2VZ124kqRlm00" target="_self"><img src="https://www.plantuml.com/plantuml/svg/bP51IyD048Nl-HLpR0_LUo5I4o_UX20vIiWExPBDB6msBVIMNH0B1Rrv54GGBteG4SH_C-t_C8r5n4lhTTvx7xmteyfcnjQb2i8Gs5-pVsM_OFVExf7T0xiNRfRhv-NguvARMsxk3Y0CWytPFtNwVPUuWi4Hi7jZ_yd-PWYdDDK5zd9DXBdj1p_Ij-zlUWYf9A5dS9mNf6SAnHXB90k9d2CSGe9cYWQYZ4GgXPtivYLeuGn_PrfChEG6-W_CUTKYOatMQDLBhC6iX0Z7alQe54zgAhe6kxtRlIuCLhNQPwzjG5EKdcZ2VZ124kqRlm00" alt=""></a></div>\n<p id="caption-rtmp-invoke-connect-sequences-ffmpeg">図6. FFmpeg が行っている Invoke(connect) のシーケンス</p>\n<p>以下の項目はすべてサーバ側からクライアント側への送信として記述する.</p>\n<ol>\n<li>Window Acknowledgement Size / Server BandWidth を送信する.</li>\n<li>Set Peer Bandwidth / Client BandWidth を送信する.</li>\n<li>User Control(Stream Begin) を送信する.</li>\n<li><strong>Chunk Size</strong> を送信する.</li>\n<li>Invoke(_result) を送信する.</li>\n<li><strong>Invoke(onBWDone)</strong> を送信する.</li>\n</ol>\n<p>公式ドキュメントが公開された <abbr title="Real-Time Messaging Protocol">RTMP</abbr> 1.0 当時と最新の <abbr title="Real-Time Messaging Protocol">RTMP</abbr> クライアント/サーバとで手順に変更があることを確認できる. しかし, どちらの手順もアプリケーション接続に<strong>失敗</strong>する.</p>\n<p>公式ドキュメントに従った場合:</p>\n<p>そもそも公開当時に対して手順が変更されてしまっているため, 当然に失敗してしまう.</p>\n<p>FFmpeg に従った場合:</p>\n<p>Invoke(onBWDone) を送信した段階で, FFmpeg が以下のメッセージと共にプロセスを終了してしまうはずである.</p>\n<blockquote>\n<p><abbr title="Real-Time Messaging Protocol">RTMP</abbr> packet size mismatch N != M</p>\n</blockquote>\n<p>ここで N は Invoke(onBWDone) チャンクのメッセージ長を, M はその直前に送信した Invoke(_result) チャンクのメッセージ長を指している. 上記のエラーメッセージから考えると, Invoke(_result) チャンクの受信後にもう一度同じサイズのメッセージを要求している. つまり, 何故か Invoke(_result) チャンクを<strong>二度</strong>送信しなければならない.<br>\nなお, 上記のエラーメッセージは当該製品中の以下の処理から発されている.</p>\n<p>FFmpeg/rtmppkt.c#L238-L244<sup class="footnote-ref"><a href="#fn27" id="fnref27">[27]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-keyword">if</span> (prev_pkt[channel_id].<span class="hljs-built_in">read</span> &amp;&amp; <span class="hljs-built_in">size</span> != prev_pkt[channel_id].<span class="hljs-built_in">size</span>) {\n    av_log(h, AV_LOG_ERROR, <span class="hljs-string">"RTMP packet size mismatch %d != %d\\n"</span>,\n                            <span class="hljs-built_in">size</span>, prev_pkt[channel_id].<span class="hljs-built_in">size</span>);\n    ff_rtmp_packet_destroy(&amp;prev_pkt[channel_id]);\n    prev_pkt[channel_id].<span class="hljs-built_in">read</span> = <span class="hljs-number">0</span>;\n    <span class="hljs-keyword">return</span> AVERROR_INVALIDDATA;\n}\n</code></pre>\n<p>上記の処理は当該製品中のソースコードにしか存在せず, 他方の <abbr title="Real-Time Messaging Protocol">RTMP</abbr> クライアントソフトウェアである <abbr title="Open Broadcaster Software">OBS</abbr> のソースコード中には存在しないことを確認できる.</p>\n<p>obs-studio/rtmp.c#L3857-L4049<sup class="footnote-ref"><a href="#fn28" id="fnref28">[28]</a></sup></p>\n<p>よって, 私は Invoke(connect) の応答メッセージの送信手順を以下に変更して再送信を試みた.</p>\n<div id="rtmp-invoke-connect-sequences-fixed">\n<a href="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuRArLNZStF-uUVFZvix7JTiVDor_tBJaSTFwnuqzJzVrFDdLzhXn-kF6-NeAjhPS8E7cbM3vHM0T7GgwTWgFcxO-Rjxpk7c2bO9dNbb-Tgf6SdvUNcfoYIONN0gY3bqtN4DyKMfnQGun6i8pyrBoonKSaxFpyijpKbFIKtDJyqeKWZEhKXNq5O9JYyfIYnIS4lDImZDJIZ88cnUSMg8Ga8gi1sYCSquco50IZ0aj1XhXd9zNKfIVen5SKfIQcAlWb9gUcKU4bvmpIlEomJuWFRmSKlDIWB480000" target="_self"><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuRArLNZStF-uUVFZvix7JTiVDor_tBJaSTFwnuqzJzVrFDdLzhXn-kF6-NeAjhPS8E7cbM3vHM0T7GgwTWgFcxO-Rjxpk7c2bO9dNbb-Tgf6SdvUNcfoYIONN0gY3bqtN4DyKMfnQGun6i8pyrBoonKSaxFpyijpKbFIKtDJyqeKWZEhKXNq5O9JYyfIYnIS4lDImZDJIZ88cnUSMg8Ga8gi1sYCSquco50IZ0aj1XhXd9zNKfIVen5SKfIQcAlWb9gUcKU4bvmpIlEomJuWFRmSKlDIWB480000" alt=""></a></div>\n<p id="caption-rtmp-invoke-connect-sequences-fixed">図7. エラーメッセージ対処後の Invoke(connect) のシーケンス</p>\n<p>以下の項目もサーバ側からクライアント側への送信として記述する.</p>\n<ol>\n<li><strong>Invoke(_result)</strong> を送信する.</li>\n<li>Window Acknowledgement Size / Server BandWidth を送信する.</li>\n<li>Set Peer Bandwidth / Client BandWidth を送信する.</li>\n<li>User Control(Stream Begin) を送信する.</li>\n<li>Chunk Size を送信する.</li>\n<li><strong>Invoke(_result)</strong> を送信する.</li>\n</ol>\n<p>すると上記のエラーメッセージは発されなくなったが, 今度は Invoke(onBWDone) チャンクを送信する前の段階で FFmpeg から新たな要求メッセージを受信した. それ(ら)は Invoke(createStream) チャンクとそれに付随して送信される<strong>新仕様の</strong> Invoke メッセージである.</p>\n<h4 id="invoke(releasestream)%2C-invoke(fcpublish)%2C-invoke(createstream)"><a class="header-anchor" href="#invoke(releasestream)%2C-invoke(fcpublish)%2C-invoke(createstream)">¶</a> Invoke(releaseStream), Invoke(FCPublish), Invoke(createStream)</h4>\n<p>Invoke(connect) での接続処理が終わった後に, 3 つに繋がった何らかのチャンクを受信する. それらは Invoke(createStream) と各種製品が公式ドキュメントの公開よりも後に実装した要求メッセージである.</p>\n<ol>\n<li>Invoke(releaseStream)</li>\n</ol>\n<p>Invoke(releaseStream) チャンクとその応答メッセージは FFmpeg および <abbr title="Open Broadcaster Software">OBS</abbr> によると以下の構造であるようだ.</p>\n<p>FFmpeg/rtmpproto.c#L593-L615<sup class="footnote-ref"><a href="#fn29" id="fnref29">[29]</a></sup>\nFFmpeg/rtmpproto.c#L1981-L1999<sup class="footnote-ref"><a href="#fn30" id="fnref30">[30]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-comment">/**\n * Generate \'releaseStream\' call and send it to the server. It should make\n * the server release some channel for media streams.\n */</span>\n<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gen_release_stream</span><span class="hljs-params">(URLContext *s, RTMPContext *rt)</span>\n</span>{\n    RTMPPacket pkt;\n    <span class="hljs-keyword">uint8_t</span> *p;\n    <span class="hljs-keyword">int</span> ret;\n\n    <span class="hljs-keyword">if</span> ((ret = ff_rtmp_packet_create(&amp;pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE,\n                                     <span class="hljs-number">0</span>, <span class="hljs-number">29</span> + <span class="hljs-built_in">strlen</span>(rt-&gt;playpath))) &lt; <span class="hljs-number">0</span>)\n        <span class="hljs-keyword">return</span> ret;\n\n    av_log(s, AV_LOG_DEBUG, <span class="hljs-string">"Releasing stream...\\n"</span>);\n    p = pkt.data;\n    ff_amf_write_string(&amp;p, <span class="hljs-string">"releaseStream"</span>);\n    ff_amf_write_number(&amp;p, ++rt-&gt;nb_invokes);\n    ff_amf_write_null(&amp;p);\n    ff_amf_write_string(&amp;p, rt-&gt;playpath);\n\n    <span class="hljs-keyword">return</span> rtmp_send_packet(rt, &amp;pkt, <span class="hljs-number">1</span>);\n}\n\n<span class="hljs-comment">// 中略</span>\n\n<span class="hljs-keyword">if</span> ((ret = ff_rtmp_packet_create(&amp;spkt, RTMP_SYSTEM_CHANNEL,\n                                 RTMP_PT_INVOKE, <span class="hljs-number">0</span>,\n                                 RTMP_PKTDATA_DEFAULT_SIZE)) &lt; <span class="hljs-number">0</span>) {\n    av_log(s, AV_LOG_ERROR, <span class="hljs-string">"Unable to create response packet\\n"</span>);\n    <span class="hljs-keyword">return</span> ret;\n}\npp = spkt.data;\nff_amf_write_string(&amp;pp, <span class="hljs-string">"_result"</span>);\nff_amf_write_number(&amp;pp, seqnum);\nff_amf_write_null(&amp;pp);\n<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">"createStream"</span>)) {\n    rt-&gt;nb_streamid++;\n    <span class="hljs-keyword">if</span> (rt-&gt;nb_streamid == <span class="hljs-number">0</span> || rt-&gt;nb_streamid == <span class="hljs-number">2</span>)\n        rt-&gt;nb_streamid++; <span class="hljs-comment">/* Values 0 and 2 are reserved */</span>\n    ff_amf_write_number(&amp;pp, rt-&gt;nb_streamid);\n    <span class="hljs-comment">/* By now we don\'t control which streams are removed in\n     * deleteStream. There is no stream creation control\n     * if a client creates more than 2^32 - 2 streams. */</span>\n}\n</code></pre>\n<p>obs-studio/rtmp.c#L1990-L2016<sup class="footnote-ref"><a href="#fn31" id="fnref31">[31]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>\n<span class="hljs-title">SendReleaseStream</span><span class="hljs-params">(RTMP *r, <span class="hljs-keyword">int</span> streamIdx)</span>\n</span>{\n    RTMPPacket packet;\n    <span class="hljs-keyword">char</span> pbuf[<span class="hljs-number">1024</span>], *pend = pbuf + <span class="hljs-keyword">sizeof</span>(pbuf);\n    <span class="hljs-keyword">char</span> *enc;\n\n    packet.m_nChannel = <span class="hljs-number">0x03</span>;\t<span class="hljs-comment">/* control channel (invoke) */</span>\n    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;\n    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;\n    packet.m_nTimeStamp = <span class="hljs-number">0</span>;\n    packet.m_nInfoField2 = <span class="hljs-number">0</span>;\n    packet.m_hasAbsTimestamp = <span class="hljs-number">0</span>;\n    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;\n\n    enc = packet.m_body;\n    enc = AMF_EncodeString(enc, pend, &amp;av_releaseStream);\n    enc = AMF_EncodeNumber(enc, pend, ++r-&gt;m_numInvokes);\n    *enc++ = AMF_NULL;\n    enc = AMF_EncodeString(enc, pend, &amp;r-&gt;Link.streams[streamIdx].playpath);\n    <span class="hljs-keyword">if</span> (!enc)\n        <span class="hljs-keyword">return</span> FALSE;\n\n    packet.m_nBodySize = enc - packet.m_body;\n\n    <span class="hljs-keyword">return</span> RTMP_SendPacket(r, &amp;packet, FALSE);\n}\n</code></pre>\n<p>要求メッセージ:</p>\n<table>\n<thead>\n<tr>\n<th>フィールド名</th>\n<th>データ型</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>コマンド名</td>\n<td>String</td>\n<td>releaseStream</td>\n</tr>\n<tr>\n<td>トランザクション ID</td>\n<td>Number</td>\n<td>2.<br>Invoke(connect) に割り振られた値より 1 多い値を割り振るようだ.</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>Null</td>\n<td>AMF における Null.<br>コマンドオブジェクトなどを入力しない場合はトランザクション ID の直後にこの値を 1 つ入力するようだ.</td>\n</tr>\n<tr>\n<td><strong>playpath</strong></td>\n<td>String</td>\n<td>mp4やmp3などのファイル名. mp4: などのプリフィックスを付けることができる.<br>起動時に渡される URL から参照する.<br>そのパターンは次の通りである: protocol://server[:port][/app][/playpath]</td>\n</tr>\n</tbody>\n</table>\n<p>応答メッセージ:</p>\n<table>\n<thead>\n<tr>\n<th>フィールド名</th>\n<th>データ型</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>コマンド名</td>\n<td>String</td>\n<td>_result<br>もしくは<br>_error</td>\n</tr>\n<tr>\n<td>トランザクション ID</td>\n<td>Number</td>\n<td>2.<br>Invoke(releaseStream) チャンクに入力されているものと同じものを使用する.</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>Null</td>\n<td>AMF における Null.<br>プロパティなどを入力しない場合はこの値を 1 つ入力するようだ.</td>\n</tr>\n</tbody>\n</table>\n<ol start="2">\n<li>Invoke(FCPublish)</li>\n</ol>\n<p>Invoke(FCPublish) チャンクとその応答メッセージは FFmpeg および <abbr title="Open Broadcaster Software">OBS</abbr> によると以下の構造であるようだ.</p>\n<p>FFmpeg/rtmpproto.c#L641-L663<sup class="footnote-ref"><a href="#fn32" id="fnref32">[32]</a></sup>\nFFmpeg/rtmpproto.c#L1956-L1965<sup class="footnote-ref"><a href="#fn33" id="fnref33">[33]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-comment">/**\n * Generate \'FCPublish\' call and send it to the server. It should make\n * the server prepare for receiving media streams.\n */</span>\n<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gen_fcpublish_stream</span><span class="hljs-params">(URLContext *s, RTMPContext *rt)</span>\n</span>{\n    RTMPPacket pkt;\n    <span class="hljs-keyword">uint8_t</span> *p;\n    <span class="hljs-keyword">int</span> ret;\n\n    <span class="hljs-keyword">if</span> ((ret = ff_rtmp_packet_create(&amp;pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE,\n                                     <span class="hljs-number">0</span>, <span class="hljs-number">25</span> + <span class="hljs-built_in">strlen</span>(rt-&gt;playpath))) &lt; <span class="hljs-number">0</span>)\n        <span class="hljs-keyword">return</span> ret;\n\n    av_log(s, AV_LOG_DEBUG, <span class="hljs-string">"FCPublish stream...\\n"</span>);\n    p = pkt.data;\n    ff_amf_write_string(&amp;p, <span class="hljs-string">"FCPublish"</span>);\n    ff_amf_write_number(&amp;p, ++rt-&gt;nb_invokes);\n    ff_amf_write_null(&amp;p);\n    ff_amf_write_string(&amp;p, rt-&gt;playpath);\n\n    <span class="hljs-keyword">return</span> rtmp_send_packet(rt, &amp;pkt, <span class="hljs-number">1</span>);\n}\n\n<span class="hljs-comment">// 中略</span>\n\n<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">"FCPublish"</span>)) {\n    <span class="hljs-keyword">if</span> ((ret = ff_rtmp_packet_create(&amp;spkt, RTMP_SYSTEM_CHANNEL,\n                                     RTMP_PT_INVOKE, <span class="hljs-number">0</span>,\n                                     RTMP_PKTDATA_DEFAULT_SIZE)) &lt; <span class="hljs-number">0</span>) {\n        av_log(s, AV_LOG_ERROR, <span class="hljs-string">"Unable to create response packet\\n"</span>);\n        <span class="hljs-keyword">return</span> ret;\n    }\n    pp = spkt.data;\n    ff_amf_write_string(&amp;pp, <span class="hljs-string">"onFCPublish"</span>);\n}\n</code></pre>\n<p>obs-studio/rtmp.c#L2020-L2046<sup class="footnote-ref"><a href="#fn34" id="fnref34">[34]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>\n<span class="hljs-title">SendFCPublish</span><span class="hljs-params">(RTMP *r, <span class="hljs-keyword">int</span> streamIdx)</span>\n</span>{\n    RTMPPacket packet;\n    <span class="hljs-keyword">char</span> pbuf[<span class="hljs-number">1024</span>], *pend = pbuf + <span class="hljs-keyword">sizeof</span>(pbuf);\n    <span class="hljs-keyword">char</span> *enc;\n\n    packet.m_nChannel = <span class="hljs-number">0x03</span>;\t<span class="hljs-comment">/* control channel (invoke) */</span>\n    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;\n    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;\n    packet.m_nTimeStamp = <span class="hljs-number">0</span>;\n    packet.m_nInfoField2 = <span class="hljs-number">0</span>;\n    packet.m_hasAbsTimestamp = <span class="hljs-number">0</span>;\n    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;\n\n    enc = packet.m_body;\n    enc = AMF_EncodeString(enc, pend, &amp;av_FCPublish);\n    enc = AMF_EncodeNumber(enc, pend, ++r-&gt;m_numInvokes);\n    *enc++ = AMF_NULL;\n    enc = AMF_EncodeString(enc, pend, &amp;r-&gt;Link.streams[streamIdx].playpath);\n    <span class="hljs-keyword">if</span> (!enc)\n        <span class="hljs-keyword">return</span> FALSE;\n\n    packet.m_nBodySize = enc - packet.m_body;\n\n    <span class="hljs-keyword">return</span> RTMP_SendPacket(r, &amp;packet, FALSE);\n}\n</code></pre>\n<p>要求メッセージ:</p>\n<table>\n<thead>\n<tr>\n<th>フィールド名</th>\n<th>データ型</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>コマンド名</td>\n<td>String</td>\n<td>FCPublish</td>\n</tr>\n<tr>\n<td>トランザクション ID</td>\n<td>Number</td>\n<td>3.<br>Invoke(releaseStream) に割り振られた値より 1 多い値を割り振るようだ.</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>Null</td>\n<td>AMF における Null.<br>コマンドオブジェクトなどを入力しない場合はトランザクション ID の直後にこの値を 1 つ入力するようだ.</td>\n</tr>\n<tr>\n<td>playpath</td>\n<td>String</td>\n<td>Invoke(releaseStream) に入力されたものと同じ値を入力する.</td>\n</tr>\n</tbody>\n</table>\n<p>応答メッセージ:</p>\n<table>\n<thead>\n<tr>\n<th>フィールド名</th>\n<th>データ型</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>コマンド名</td>\n<td>String</td>\n<td>onFCPublish</td>\n</tr>\n</tbody>\n</table>\n<ol start="3">\n<li>Invoke(createStream)</li>\n</ol>\n<p>Invoke(createStream) チャンクは公式ドキュメント<sup class="footnote-ref"><a href="#fn1" id="fnref1:8">[1:8]</a></sup>では以下のように定義されている.</p>\n<p>要求メッセージ:</p>\n<table>\n<thead>\n<tr>\n<th>フィールド名</th>\n<th>データ型</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>コマンド名</td>\n<td>String</td>\n<td>createStream</td>\n</tr>\n<tr>\n<td>トランザクション ID</td>\n<td>Number</td>\n<td>コマンドのトランザクション ID.</td>\n</tr>\n<tr>\n<td>コマンドオブジェクト</td>\n<td>Object<br>または<br>Null</td>\n<td>当該コマンドに設定する情報がある場合は Invoke(connect) と同じフォーマットのコマンドオブジェクトを入力する.<br>そうでなければ AMF における Null を入力する.</td>\n</tr>\n</tbody>\n</table>\n<p>応答メッセージ:</p>\n<table>\n<thead>\n<tr>\n<th>フィールド名</th>\n<th>データ型</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>コマンド名</td>\n<td>String</td>\n<td>_result<br>または<br>_error</td>\n</tr>\n<tr>\n<td>トランザクション ID.</td>\n<td>Number</td>\n<td>応答メッセージが属するコマンドの ID.</td>\n</tr>\n<tr>\n<td>コマンドオブジェクト</td>\n<td>Object<br>または<br>Null</td>\n<td>当該応答メッセージに設定する情報がある場合は Invoke(createStream) と同じフォーマットのコマンドオブジェクトを入力する.<br>そうでなければ AMF における Null を入力する.</td>\n</tr>\n<tr>\n<td><strong>メッセージストリーム ID</strong></td>\n<td>Number</td>\n<td>メッセージストリーム ID か<strong>エラー情報が入力されたインフォメーションオブジェクト</strong>を入力する.</td>\n</tr>\n</tbody>\n</table>\n<p>一方で, FFmpeg および <abbr title="Open Broadcaster Software">OBS</abbr> では以下の構造であるようだ.</p>\n<p>FFmpeg/rtmpproto.c#L665-L687<sup class="footnote-ref"><a href="#fn35" id="fnref35">[35]</a></sup>\nFFmpeg/rtmpproto.c#L1981-L1999<sup class="footnote-ref"><a href="#fn30" id="fnref30:1">[30:1]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-comment">/**\n * Generate \'createStream\' call and send it to the server. It should make\n * the server allocate some channel for media streams.\n */</span>\n<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gen_create_stream</span><span class="hljs-params">(URLContext *s, RTMPContext *rt)</span>\n</span>{\n    RTMPPacket pkt;\n    <span class="hljs-keyword">uint8_t</span> *p;\n    <span class="hljs-keyword">int</span> ret;\n\n    av_log(s, AV_LOG_DEBUG, <span class="hljs-string">"Creating stream...\\n"</span>);\n\n    <span class="hljs-keyword">if</span> ((ret = ff_rtmp_packet_create(&amp;pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE,\n                                     <span class="hljs-number">0</span>, <span class="hljs-number">25</span>)) &lt; <span class="hljs-number">0</span>)\n        <span class="hljs-keyword">return</span> ret;\n\n    p = pkt.data;\n    ff_amf_write_string(&amp;p, <span class="hljs-string">"createStream"</span>);\n    ff_amf_write_number(&amp;p, ++rt-&gt;nb_invokes);\n    ff_amf_write_null(&amp;p);\n\n    <span class="hljs-keyword">return</span> rtmp_send_packet(rt, &amp;pkt, <span class="hljs-number">1</span>);\n}\n\n<span class="hljs-comment">// 中略</span>\n\n<span class="hljs-keyword">if</span> ((ret = ff_rtmp_packet_create(&amp;spkt, RTMP_SYSTEM_CHANNEL,\n                                 RTMP_PT_INVOKE, <span class="hljs-number">0</span>,\n                                 RTMP_PKTDATA_DEFAULT_SIZE)) &lt; <span class="hljs-number">0</span>) {\n    av_log(s, AV_LOG_ERROR, <span class="hljs-string">"Unable to create response packet\\n"</span>);\n    <span class="hljs-keyword">return</span> ret;\n}\npp = spkt.data;\nff_amf_write_string(&amp;pp, <span class="hljs-string">"_result"</span>);\nff_amf_write_number(&amp;pp, seqnum);\nff_amf_write_null(&amp;pp);\n<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">"createStream"</span>)) {\n    rt-&gt;nb_streamid++;\n    <span class="hljs-keyword">if</span> (rt-&gt;nb_streamid == <span class="hljs-number">0</span> || rt-&gt;nb_streamid == <span class="hljs-number">2</span>)\n        rt-&gt;nb_streamid++; <span class="hljs-comment">/* Values 0 and 2 are reserved */</span>\n    ff_amf_write_number(&amp;pp, rt-&gt;nb_streamid);\n    <span class="hljs-comment">/* By now we don\'t control which streams are removed in\n     * deleteStream. There is no stream creation control\n     * if a client creates more than 2^32 - 2 streams. */</span>\n}\n</code></pre>\n<p>obs-studio/rtmp.c#L1899-L1922<sup class="footnote-ref"><a href="#fn36" id="fnref36">[36]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">int</span>\n<span class="hljs-title">RTMP_SendCreateStream</span><span class="hljs-params">(RTMP *r)</span>\n</span>{\n    RTMPPacket packet;\n    <span class="hljs-keyword">char</span> pbuf[<span class="hljs-number">256</span>], *pend = pbuf + <span class="hljs-keyword">sizeof</span>(pbuf);\n    <span class="hljs-keyword">char</span> *enc;\n\n    packet.m_nChannel = <span class="hljs-number">0x03</span>;\t<span class="hljs-comment">/* control channel (invoke) */</span>\n    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;\n    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;\n    packet.m_nTimeStamp = <span class="hljs-number">0</span>;\n    packet.m_nInfoField2 = <span class="hljs-number">0</span>;\n    packet.m_hasAbsTimestamp = <span class="hljs-number">0</span>;\n    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;\n\n    enc = packet.m_body;\n    enc = AMF_EncodeString(enc, pend, &amp;av_createStream);\n    enc = AMF_EncodeNumber(enc, pend, ++r-&gt;m_numInvokes);\n    *enc++ = AMF_NULL;\t\t<span class="hljs-comment">/* NULL */</span>\n\n    packet.m_nBodySize = enc - packet.m_body;\n\n    <span class="hljs-keyword">return</span> RTMP_SendPacket(r, &amp;packet, TRUE);\n}\n</code></pre>\n<p>要求メッセージ:</p>\n<table>\n<thead>\n<tr>\n<th>フィールド名</th>\n<th>データ型</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>コマンド名</td>\n<td>String</td>\n<td>createStream</td>\n</tr>\n<tr>\n<td>トランザクション ID</td>\n<td>Number</td>\n<td>4.<br>Invoke(FCPublish) に割り振られた値より 1 多い値を割り振るようだ.</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>Null</td>\n<td>AMF における Null.</td>\n</tr>\n</tbody>\n</table>\n<p>応答メッセージ:</p>\n<table>\n<thead>\n<tr>\n<th>フィールド名</th>\n<th>データ型</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>コマンド名</td>\n<td>String</td>\n<td>_result<br>または<br>_error</td>\n</tr>\n<tr>\n<td>トランザクション ID</td>\n<td>Number</td>\n<td>4.<br>Invoke(createStream) チャンクに入力されている値と同じ値を入力するようだ.</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>Null</td>\n<td>AMF における Null.</td>\n</tr>\n<tr>\n<td><strong>メッセージストリーム ID</strong></td>\n<td>Number</td>\n<td>サーバ側がクライアント側に割り振るメッセージストリーム ID.</td>\n</tr>\n</tbody>\n</table>\n<p>Invoke(releaseStream), Invoke(FCPublish) および Invoke(createStream) の 3 つのチャンクへの応答をすべて終えると, クライアント側はサーバ側に Invoke(publish) チャンクを送信する.</p>\n<h4 id="invoke(publish)"><a class="header-anchor" href="#invoke(publish)">¶</a> Invoke(publish)</h4>\n<p>Invoke(publish) チャンクは公式ドキュメント<sup class="footnote-ref"><a href="#fn1" id="fnref1:9">[1:9]</a></sup>では以下のように定義されている.</p>\n<p>要求メッセージ:</p>\n<table>\n<thead>\n<tr>\n<th>フィールド名</th>\n<th>データ型</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>コマンド名</td>\n<td>String</td>\n<td>publsh</td>\n</tr>\n<tr>\n<td>トランザクション ID</td>\n<td>Number</td>\n<td>0</td>\n</tr>\n<tr>\n<td>コマンドオブジェクト</td>\n<td>Null</td>\n<td>publish コマンドにコマンドオブジェクトは存在しないので AMF における Null を入力する.</td>\n</tr>\n<tr>\n<td>発行名</td>\n<td>String</td>\n<td>ストリームの発行に使用される名前.</td>\n</tr>\n<tr>\n<td>発行の種類</td>\n<td>String</td>\n<td>live, record, append のいずれか.  \\</td>\n</tr>\n<tr>\n<td>* record: ストリームが発行され, データが新しいファイルに記録される. ファイルはサーバーアプリケーションを含むディレクトリ内のサブディレクトリのサーバーに保存される. ファイルが既に存在する場合, 上書きされる.  \\</td>\n</tr>\n<tr>\n<td>* append: ストリームが発行され、データがファイルに追加される. ファイルが見つからなかった場合, 作成される.  \\</td>\n</tr>\n<tr>\n<td>* live: ライブデータはファイルに記録せずに発行される.</td>\n</tr>\n</tbody>\n</table>\n<p>応答メッセージ:</p>\n<table>\n<thead>\n<tr>\n<th>フィールド名</th>\n<th>データ型</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>コマンド名</td>\n<td>String</td>\n<td>onStatus</td>\n</tr>\n<tr>\n<td>トランザクション ID</td>\n<td>Number</td>\n<td>0</td>\n</tr>\n<tr>\n<td>コマンドオブジェクト</td>\n<td>Null</td>\n<td>onStatusメッセージにコマンドオブジェクトは存在しないので AMF における Null を入力する.</td>\n</tr>\n<tr>\n<td>インフォメーションオブジェクト</td>\n<td>Object</td>\n<td>少なくとも以下の 3 つのプロパティを持つオブジェクト:  \\</td>\n</tr>\n<tr>\n<td>* level: warning, status, error のいずれか.  \\</td>\n</tr>\n<tr>\n<td>* code: メッセージのステータスコード. 例えば NetStream.Play.Start.  \\</td>\n</tr>\n<tr>\n<td>* description: メッセージの人間が読める記述.  \\</td>\n</tr>\n<tr>\n<td>\\</td>\n</tr>\n<tr>\n<td>インフォメーションオブジェクトは code に応じて他のプロパティを含め<strong>てもよい</strong>.</td>\n</tr>\n</tbody>\n</table>\n<p>一方で, FFmpeg および <abbr title="Open Broadcaster Software">OBS</abbr> では以下の構造であるようだ.</p>\n<p>FFmpeg/rtmpproto.c#L838-L863<sup class="footnote-ref"><a href="#fn37" id="fnref37">[37]</a></sup>\nFFmpeg/rtmpproto.c#L1858-L1899<sup class="footnote-ref"><a href="#fn38" id="fnref38">[38]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-comment">/**\n * Generate \'publish\' call and send it to the server.\n */</span>\n<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gen_publish</span><span class="hljs-params">(URLContext *s, RTMPContext *rt)</span>\n</span>{\n    RTMPPacket pkt;\n    <span class="hljs-keyword">uint8_t</span> *p;\n    <span class="hljs-keyword">int</span> ret;\n\n    av_log(s, AV_LOG_DEBUG, <span class="hljs-string">"Sending publish command for \'%s\'\\n"</span>, rt-&gt;playpath);\n\n    <span class="hljs-keyword">if</span> ((ret = ff_rtmp_packet_create(&amp;pkt, RTMP_SOURCE_CHANNEL, RTMP_PT_INVOKE,\n                                     <span class="hljs-number">0</span>, <span class="hljs-number">30</span> + <span class="hljs-built_in">strlen</span>(rt-&gt;playpath))) &lt; <span class="hljs-number">0</span>)\n        <span class="hljs-keyword">return</span> ret;\n\n    pkt.extra = rt-&gt;stream_id;\n\n    p = pkt.data;\n    ff_amf_write_string(&amp;p, <span class="hljs-string">"publish"</span>);\n    ff_amf_write_number(&amp;p, ++rt-&gt;nb_invokes);\n    ff_amf_write_null(&amp;p);\n    ff_amf_write_string(&amp;p, rt-&gt;playpath);\n    ff_amf_write_string(&amp;p, <span class="hljs-string">"live"</span>);\n\n    <span class="hljs-keyword">return</span> rtmp_send_packet(rt, &amp;pkt, <span class="hljs-number">1</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">write_status</span><span class="hljs-params">(URLContext *s, RTMPPacket *pkt,\n                        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *status, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename)</span>\n</span>{\n    RTMPContext *rt = s-&gt;priv_data;\n    RTMPPacket spkt = { <span class="hljs-number">0</span> };\n    <span class="hljs-keyword">char</span> statusmsg[<span class="hljs-number">128</span>];\n    <span class="hljs-keyword">uint8_t</span> *pp;\n    <span class="hljs-keyword">int</span> ret;\n\n    <span class="hljs-keyword">if</span> ((ret = ff_rtmp_packet_create(&amp;spkt, RTMP_SYSTEM_CHANNEL,\n                                     RTMP_PT_INVOKE, <span class="hljs-number">0</span>,\n                                     RTMP_PKTDATA_DEFAULT_SIZE)) &lt; <span class="hljs-number">0</span>) {\n        av_log(s, AV_LOG_ERROR, <span class="hljs-string">"Unable to create response packet\\n"</span>);\n        <span class="hljs-keyword">return</span> ret;\n    }\n\n    pp = spkt.data;\n    spkt.extra = pkt-&gt;extra;\n    ff_amf_write_string(&amp;pp, <span class="hljs-string">"onStatus"</span>);\n    ff_amf_write_number(&amp;pp, <span class="hljs-number">0</span>);\n    ff_amf_write_null(&amp;pp);\n\n    ff_amf_write_object_start(&amp;pp);\n    ff_amf_write_field_name(&amp;pp, <span class="hljs-string">"level"</span>);\n    ff_amf_write_string(&amp;pp, <span class="hljs-string">"status"</span>);\n    ff_amf_write_field_name(&amp;pp, <span class="hljs-string">"code"</span>);\n    ff_amf_write_string(&amp;pp, status);\n    ff_amf_write_field_name(&amp;pp, <span class="hljs-string">"description"</span>);\n    <span class="hljs-built_in">snprintf</span>(statusmsg, <span class="hljs-keyword">sizeof</span>(statusmsg),\n             <span class="hljs-string">"%s is now published"</span>, filename);\n    ff_amf_write_string(&amp;pp, statusmsg);\n    ff_amf_write_field_name(&amp;pp, <span class="hljs-string">"details"</span>);\n    ff_amf_write_string(&amp;pp, filename);\n    ff_amf_write_object_end(&amp;pp);\n\n    spkt.<span class="hljs-built_in">size</span> = pp - spkt.data;\n    ret = ff_rtmp_packet_write(rt-&gt;stream, &amp;spkt, rt-&gt;out_chunk_size,\n                               &amp;rt-&gt;prev_pkt[<span class="hljs-number">1</span>], &amp;rt-&gt;nb_prev_pkt[<span class="hljs-number">1</span>]);\n    ff_rtmp_packet_destroy(&amp;spkt);\n\n    <span class="hljs-keyword">return</span> ret;\n}\n</code></pre>\n<p>obs-studio/rtmp.c#L2081-L2112<sup class="footnote-ref"><a href="#fn39" id="fnref39">[39]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>\n<span class="hljs-title">SendPublish</span><span class="hljs-params">(RTMP *r, <span class="hljs-keyword">int</span> streamIdx)</span>\n</span>{\n    RTMPPacket packet;\n    <span class="hljs-keyword">char</span> pbuf[<span class="hljs-number">1024</span>], *pend = pbuf + <span class="hljs-keyword">sizeof</span>(pbuf);\n    <span class="hljs-keyword">char</span> *enc;\n\n    packet.m_nChannel = <span class="hljs-number">0x04</span>;\t<span class="hljs-comment">/* source channel (invoke) */</span>\n    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;\n    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;\n    packet.m_nTimeStamp = <span class="hljs-number">0</span>;\n    packet.m_nInfoField2 = r-&gt;Link.streams[streamIdx].id;\n    packet.m_hasAbsTimestamp = <span class="hljs-number">0</span>;\n    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;\n\n    enc = packet.m_body;\n    enc = AMF_EncodeString(enc, pend, &amp;av_publish);\n    enc = AMF_EncodeNumber(enc, pend, ++r-&gt;m_numInvokes);\n    *enc++ = AMF_NULL;\n    enc = AMF_EncodeString(enc, pend, &amp;r-&gt;Link.streams[streamIdx].playpath);\n    <span class="hljs-keyword">if</span> (!enc)\n        <span class="hljs-keyword">return</span> FALSE;\n\n    <span class="hljs-comment">/* <span class="hljs-doctag">FIXME:</span> should we choose live based on Link.lFlags &amp; RTMP_LF_LIVE? */</span>\n    enc = AMF_EncodeString(enc, pend, &amp;av_live);\n    <span class="hljs-keyword">if</span> (!enc)\n        <span class="hljs-keyword">return</span> FALSE;\n\n    packet.m_nBodySize = enc - packet.m_body;\n\n    <span class="hljs-keyword">return</span> RTMP_SendPacket(r, &amp;packet, TRUE);\n}\n</code></pre>\n<p>要求メッセージ:</p>\n<table>\n<thead>\n<tr>\n<th>フィールド名</th>\n<th>データ型</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>コマンド名</td>\n<td>String</td>\n<td>publish</td>\n</tr>\n<tr>\n<td>トランザクション ID</td>\n<td>Number</td>\n<td>5.<br>Invoke(createStream) に割り振られた値より 1 多い値を割り振るようだ.</td>\n</tr>\n<tr>\n<td>コマンドオブジェクト</td>\n<td>Null</td>\n<td>AMF における Null.</td>\n</tr>\n<tr>\n<td>発行名</td>\n<td>String</td>\n<td>playpath と同じ値.</td>\n</tr>\n<tr>\n<td>発行の種類</td>\n<td>String</td>\n<td>live</td>\n</tr>\n</tbody>\n</table>\n<p>応答メッセージ:</p>\n<table>\n<thead>\n<tr>\n<th>フィールド名</th>\n<th>データ型</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>コマンド名</td>\n<td>String</td>\n<td>onStatus</td>\n</tr>\n<tr>\n<td>トランザクション ID</td>\n<td>Number</td>\n<td>0</td>\n</tr>\n<tr>\n<td>コマンドオブジェクト</td>\n<td>Null</td>\n<td>AMF における Null.</td>\n</tr>\n<tr>\n<td>インフォメーションオブジェクト</td>\n<td>Object</td>\n<td>以下の名前と値のペア.  \\</td>\n</tr>\n<tr>\n<td>* level: status  \\</td>\n</tr>\n<tr>\n<td>* code: 何らかのステータスコード. FFmpeg/rtmpproto.c#L1965-L1973<sup class="footnote-ref"><a href="#fn40" id="fnref40">[40]</a></sup> より, 今回は NetStream.Publish.Start が入力されている.  \\</td>\n</tr>\n<tr>\n<td>* description: “<strong>playpath</strong> is now published”.  \\</td>\n</tr>\n<tr>\n<td>* details: playpath と同じ値.</td>\n</tr>\n</tbody>\n</table>\n<p>Invoke(publish) チャンクの現在の仕様は, 要求メッセージのトランザクション ID が 0 でないことを除き <abbr title="Real-Time Messaging Protocol">RTMP</abbr> 1.0 当時と同じようだ.</p>\n<p>上記の仕様に従い, クライアント/サーバ側は当該要求/応答チャンクを送信する. その手順は公式ドキュメント<sup class="footnote-ref"><a href="#fn1" id="fnref1:10">[1:10]</a></sup>では以下のように定義されている.</p>\n<div id="rtmp-invoke-publish-sequences-official">\n<a href="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuRArLV3CAylFJjL8BafDB4aDBW5IkPeAZnjtF6vSztJ_dEThfpnkx7cwhkV9hhR7ZTCVDyxNKx2rvNhSjFvnyyh7JKiUDorwtBpvSNE7WgwTmkEchO-Rzpnkdc05CxMWD2adipX3amik1L67hjjA8RGujKZ1EJ-lf2W_HmFY30MdrFJCF4t2blccbYIc99Oa4bRfM9gIcKzOcND6QLwsGd1cLIfXXqDzcfyNN99OKbfCqBaAsjeALWfXcIcf-Q3WVzoq4wZYSVCgiEm2OAY_R6XyidyXKgZFVDpK_RXnt-F6vU2mTqZDIm767G00" target="_self"><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuRArLV3CAylFJjL8BafDB4aDBW5IkPeAZnjtF6vSztJ_dEThfpnkx7cwhkV9hhR7ZTCVDyxNKx2rvNhSjFvnyyh7JKiUDorwtBpvSNE7WgwTmkEchO-Rzpnkdc05CxMWD2adipX3amik1L67hjjA8RGujKZ1EJ-lf2W_HmFY30MdrFJCF4t2blccbYIc99Oa4bRfM9gIcKzOcND6QLwsGd1cLIfXXqDzcfyNN99OKbfCqBaAsjeALWfXcIcf-Q3WVzoq4wZYSVCgiEm2OAY_R6XyidyXKgZFVDpK_RXnt-F6vU2mTqZDIm767G00" alt=""></a></div>\n<p id="caption-rtmp-invoke-publish-sequences-official">図7. 公式が説明している Invoke(publish) のシーケンス</p>\n<ol>\n<li>クライアント側はサーバ側に Invoke(publish) チャンクを送信する.</li>\n<li>サーバ側はクライアント側に User Control(Stream Begin) チャンクを送信する.</li>\n<li>クライアント側はサーバ側に Metadata チャンク, Audio/Video チャンクおよび Chunk Size チャンクを送信する.</li>\n<li>サーバ側はクライアント側に Invoke(onStatus) チャンクを送信する.</li>\n<li>クライアント側はストリームの送信が完了するまでサーバ側に映像/音声データを送信する.</li>\n</ol>\n<p>一方で, FFmpeg では以下の実装を行っている.</p>\n<p>FFmpeg/rtmpproto.c#L1965-L1973<sup class="footnote-ref"><a href="#fn40" id="fnref40:1">[40:1]</a></sup></p>\n<pre class="hljs"><code><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(command, <span class="hljs-string">"publish"</span>)) {\n    ret = write_begin(s);\n    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)\n        <span class="hljs-keyword">return</span> ret;\n\n    <span class="hljs-comment">// Send onStatus(NetStream.Publish.Start)</span>\n    <span class="hljs-keyword">return</span> write_status(s, pkt, <span class="hljs-string">"NetStream.Publish.Start"</span>,\n                       filename);\n}\n</code></pre>\n<div id="rtmp-invoke-publish-sequences-ffmpeg">\n<a href="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuRArLV3CAylFJjL8BafDB4aDBW5IkPeAZnjtF6vSztJ_dEThfpnkx7cwhkV9hhR7ZTCVDyxNKx2rvNhSjFvnyyh7JKiUDorwtBpvSNE7WgwTmkEchO-Rzpnkdc05CxMWD2adipX3amik1L67hjjA8RGujKZ1EJ-lf2W_HmFY30MdrFJCF2BqGYtBpmikIImfBTO4UUlPZ0LFc_lrNyxV_7Jn1g1VNZOqFksV_cJ_miTDarvEwtwwlFjnuyp7JTt4U4T1Mrl1Ii4tjIGn9R4aaR3d7KjJClC9AmlBJ4dDn-5Ma4CHuGvowEF6VOyRbuETwv2QbmACFG00" target="_self"><img src="https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuRArLV3CAylFJjL8BafDB4aDBW5IkPeAZnjtF6vSztJ_dEThfpnkx7cwhkV9hhR7ZTCVDyxNKx2rvNhSjFvnyyh7JKiUDorwtBpvSNE7WgwTmkEchO-Rzpnkdc05CxMWD2adipX3amik1L67hjjA8RGujKZ1EJ-lf2W_HmFY30MdrFJCF2BqGYtBpmikIImfBTO4UUlPZ0LFc_lrNyxV_7Jn1g1VNZOqFksV_cJ_miTDarvEwtwwlFjnuyp7JTt4U4T1Mrl1Ii4tjIGn9R4aaR3d7KjJClC9AmlBJ4dDn-5Ma4CHuGvowEF6VOyRbuETwv2QbmACFG00" alt=""></a></div>\n<p id="caption-rtmp-invoke-publish-sequences-ffmpeg">図8. FFmpeg が行っている Invoke(publish) のシーケンス</p>\n<ol>\n<li>クライアント側はサーバ側に Invoke(publish) チャンクを送信する.</li>\n<li>サーバ側はクライアント側に User Control(Stream Begin) チャンクと Invoke(onStatus) チャンクを送信する.</li>\n<li>クライアント側はストリームの送信が完了するまでサーバ側に映像/音声データを送信する.</li>\n</ol>\n<p>こちらも <abbr title="Real-Time Messaging Protocol">RTMP</abbr> 1.0 当時に対して手順が変わっていることを確認できる. 上記の手順に従い Invoke(onStatus) チャンクの送信を終えると, クライアント側はサーバ側に Metadata チャンクを含めた Audio/Video チャンクの送信を開始する.</p>\n<p>ここで, 上記の各種接続手順より現在の <abbr title="Real-Time Messaging Protocol">RTMP</abbr> 層で映像/音声データを送受信するまでに必要な手順は以下に要約できる.</p>\n<h3 id="%E7%8F%BE%E5%9C%A8%E3%81%AE-rtmp-%E6%8E%A5%E7%B6%9A%E3%81%AE%E6%B5%81%E3%82%8C"><a class="header-anchor" href="#%E7%8F%BE%E5%9C%A8%E3%81%AE-rtmp-%E6%8E%A5%E7%B6%9A%E3%81%AE%E6%B5%81%E3%82%8C">¶</a> 現在の <abbr title="Real-Time Messaging Protocol">RTMP</abbr> 接続の流れ</h3>\n<div id="rtmp-connection-sequences-current">\n<a href="https://www.plantuml.com/plantuml/svg/hLHTQnD157tFhxYFBOlsup4GQRiYzA4Gt6eVPSrUcYMR6TcTRS4dPmQaccAAqARwaduemGgjKbe_AlfZRZOb_yBPRQrLa6nQN-VUS-uvvrvcAX9kAE9wK2YLODukG-_5szFZroJVzrRMakTjaYsIxPjGAXL87P1-H-eDgHtIXwHNuCOj87L4-XlfjIBOuvOzKRXuEAl-ZIc2Csuv4vOpcODmCbLrTtwk3AIRMSipKfz8TJBG0SdLP7-r-_NfC2fdsHAluKY5CuOLCJfOxpdWGOXH7EG1BFZCuyimNQanlXoWjuXrP08S_p7263WOBc48Coxp5dnFL7C4XWBAU1bZQEp0Jqc7eBaN6GgRCn7oOCGH8RfrcC55d-MmP5TZLiiS39-NMM5MRP7U8_Kn1PiTwexf_tLiLrzZY06w4PxP6SqDksENuuU17rNpGofcWhWqw7zVpJc0ip-qNI5hlKrQaph9WlvCwelfJADFYRPWzZQGtE-UR9wkxrqd-4UvDLxdxYv2SOGhuYWpsDlSIdHphDy-J7O_62_z9p9fjhe_jaczx6yqaaw3v2jIZJnsmBAW27CeNCyLxc3pqx7dyy5jztqF-J-qfa9_vvuA9VcTP2UJEuNCCv_nJm00" target="_self"><img src="https://www.plantuml.com/plantuml/svg/hLHTQnD157tFhxYFBOlsup4GQRiYzA4Gt6eVPSrUcYMR6TcTRS4dPmQaccAAqARwaduemGgjKbe_AlfZRZOb_yBPRQrLa6nQN-VUS-uvvrvcAX9kAE9wK2YLODukG-_5szFZroJVzrRMakTjaYsIxPjGAXL87P1-H-eDgHtIXwHNuCOj87L4-XlfjIBOuvOzKRXuEAl-ZIc2Csuv4vOpcODmCbLrTtwk3AIRMSipKfz8TJBG0SdLP7-r-_NfC2fdsHAluKY5CuOLCJfOxpdWGOXH7EG1BFZCuyimNQanlXoWjuXrP08S_p7263WOBc48Coxp5dnFL7C4XWBAU1bZQEp0Jqc7eBaN6GgRCn7oOCGH8RfrcC55d-MmP5TZLiiS39-NMM5MRP7U8_Kn1PiTwexf_tLiLrzZY06w4PxP6SqDksENuuU17rNpGofcWhWqw7zVpJc0ip-qNI5hlKrQaph9WlvCwelfJADFYRPWzZQGtE-UR9wkxrqd-4UvDLxdxYv2SOGhuYWpsDlSIdHphDy-J7O_62_z9p9fjhe_jaczx6yqaaw3v2jIZJnsmBAW27CeNCyLxc3pqx7dyy5jztqF-J-qfa9_vvuA9VcTP2UJEuNCCv_nJm00" alt=""></a></div>\n<p id="caption-rtmp-connection-sequences-current">図9. <abbr title="Real-Time Messaging Protocol">RTMP</abbr> 全体の現在の<em>大まかな</em>シーケンス</p>\n<ol>\n<li>クライアント側とサーバ側は <abbr title="Transmission Control Protocol">TCP</abbr> 層での接続の後, <abbr title="Real-Time Messaging Protocol">RTMP</abbr> 層でのハンドシェイクを行う.\n<ol>\n<li>クライアント側はサーバ側に C0 チャンクと C1 チャンクを送信する.</li>\n<li>サーバ側は, クライアント側から受信した C0 チャンクに入力されたプロトコルのバージョンに対応していれば S0 チャンクと S1 チャンク に C1 チャンクを添えて返送する.</li>\n<li>クライアント側は, サーバ側から返送された S0 チャンクに入力されたプロトコルのバージョンに対応しており, C1 チャンクの内容が返送前と同じであれば, S1 チャンクを返送する.</li>\n<li>サーバ側は, クライアント側から返送された S1 チャンクの内容が返送前と同じであればアプリケーション間接続を開始する.</li>\n<li>Flash Player 9 / Adobe Media Server 3 以降の場合, クライアント/サーバ側は, 返送チャンクの受信時に C1/S1 チャンクに埋め込んだ <a href="#fp9">HMAC-SHA256 ダイジェスト</a>と所定の鍵で求めたハッシュでも同一性を検証する必要がある.</li>\n</ol>\n</li>\n<li>1 で <abbr title="Real-Time Messaging Protocol">RTMP</abbr> 層でのハンドシェイクが成功したなら, アプリケーション間接続に必要な情報を相互に伝達しあう.\n<ol>\n<li>クライアント側はサーバ側に Invoke(connect) チャンクを送信する.</li>\n<li>サーバ側はクライアント側から受信した Invoke(connect) をデコードし, それが妥当であれば応答チャンクを送信する. 応答チャンクおよびそれに付随する各種チャンクの送信順序は以下の通りである.\n<ol>\n<li>Invoke(_result) チャンク</li>\n<li>Window Acknowledgement Size / Server BandWidth チャンク</li>\n<li>Set Peer BandWidth / Client BandWidth チャンク</li>\n<li>User Control (Stream Begin) チャンク</li>\n<li>Chunk Size チャンク</li>\n<li>Invoke(_result) チャンク</li>\n</ol>\n</li>\n<li>クライアント側はサーバ側から応答チャンクを受信したなら, 以下の手順で Invoke(createStream) チャンクとそれに付随するチャンクを同時に送信する.\n<ol>\n<li>Invoke(releaseStream) チャンク</li>\n<li>Invoke(FCPublish) チャンク</li>\n<li>Invoke(createStream) チャンク</li>\n</ol>\n</li>\n<li>サーバ側はクライアント側から受信した上記のチャンクをデコードし, それらが妥当であれば各種応答チャンクを送信し, メッセージに一意な値を付番する.</li>\n<li>クライアント側はサーバ側から Invoke(createStream) チャンクに対する応答チャンクを受信したなら, Invoke(publish) チャンクを送信し, サーバ側に映像/音声データの送受信開始を伝える.</li>\n<li>サーバ側はクライアント側から受信した Invoke(publish) チャンクをデコードし, それが妥当であれば User Control(StreamBegin) チャンクと Invoke(onStatus) チャンクをクライアント側に送信する.</li>\n</ol>\n</li>\n<li>映像/音声データの送受信を行う.</li>\n</ol>\n<h3 id="%E3%83%91%E3%82%B1%E3%83%83%E3%83%88%E3%81%AE%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%83%E3%83%88"><a class="header-anchor" href="#%E3%83%91%E3%82%B1%E3%83%83%E3%83%88%E3%81%AE%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%83%E3%83%88">¶</a> パケットのメッセージフォーマット</h3>\n<p>Invoke, Metadata および Shared Object の 3 種のチャンクデータには, AMF0 もしくは AMF3 のメッセージフォーマットが適用されている. それらの内訳は AMF のドキュメントでは以下のように定義されている.</p>\n<h4 id="amf0"><a class="header-anchor" href="#amf0">¶</a> AMF0</h4>\n<ul>\n<li>AMF0<sup class="footnote-ref"><a href="#fn41" id="fnref41">[41]</a></sup></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>ID</th>\n<th>データ型</th>\n<th>サイズ</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>Number</td>\n<td>8 bytes</td>\n<td>8 bytes 浮動小数点数のバイナリ表記.<br>受信時は 8 bytes のバイト列なので, それを浮動小数点数に変換する工夫が必要である.</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Boolean</td>\n<td>1 byte</td>\n<td>1 byte 整数.<br>0 を false, それ以外(一般的には 1)を true として扱う.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>String</td>\n<td>2 bytes<br>+<br>可変(最大 (2<sup>16</sup> - 1) bytes)</td>\n<td>UTF-8 の文字列.<br>最初の 2 bytes には続く文字列の長さを入力する.</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Anonymous Object</td>\n<td>可変</td>\n<td>名前と値(どちらも AMF0 でエンコードされたもの)のペア.</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Movieclip</td>\n<td></td>\n<td>サポートされておらず未来の使用のために予約されている.</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Null</td>\n<td>0 bytes</td>\n<td>なし.<br>ID のみを入力する.</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Undefined</td>\n<td>0 bytes</td>\n<td>なし.<br>ID のみを入力する.</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Reference</td>\n<td>2 bytes</td>\n<td>符号なし整数.<br>以下の 4 つのデータ型は複合することができる.  \\</td>\n</tr>\n<tr>\n<td>* Anonymous Object  \\</td>\n</tr>\n<tr>\n<td>* Typed Object  \\</td>\n</tr>\n<tr>\n<td>* Strict Array \\</td>\n</tr>\n<tr>\n<td>* ECMA Array  \\</td>\n</tr>\n<tr>\n<td>\\</td>\n</tr>\n<tr>\n<td>複合オブジェクトの同じ実体が 1 つのオブジェクトグラフとして複数回現れるなら, それは参照として送られなければならない.<br>Reference 型は直列化されたオブジェクトのテーブル内でのインデックスを指す 2 bytes の符号なし整数である.<br>0 オリジンである.</td>\n</tr>\n<tr>\n<td>8</td>\n<td>ECMA Array</td>\n<td>4 bytes<br>+<br>可変(最大 (2<sup>32</sup> - 1) 要素)</td>\n<td>要素の総数(4 bytes)とその数と等しい数の名前と値(どちらも AMF0 でエンコードされたもの)のペア.<br>ECMA 配列もしくは連想配列である.<br>順序やすべてのインデックスはすべて文字列のキーとして扱われる.<br>シリアライズの観点で当該データ型は Anonymous Object 型と類似している.</td>\n</tr>\n<tr>\n<td>9</td>\n<td>Object End</td>\n<td>0 byte</td>\n<td>なし.<br>ID のみを入力する.<br>以下の 4 つのデータ型はそれ自体の終わりの印として当該データ型の ID をその末尾に入力する.  \\</td>\n</tr>\n<tr>\n<td>* Anonymous Object  \\</td>\n</tr>\n<tr>\n<td>* Typed Object  \\</td>\n</tr>\n<tr>\n<td>* ECMA Array  \\</td>\n</tr>\n<tr>\n<td>* Strict Array  \\</td>\n</tr>\n<tr>\n<td>\\</td>\n</tr>\n<tr>\n<td>ただし, 当該データ型は <strong>ID の直前の 2 bytes に空白(0x0000)が存在しており, 3 bytes の ID として評価しないと Number 型と混同してしまう</strong>ので注意が必要である.</td>\n</tr>\n<tr>\n<td>10</td>\n<td>Strict Array</td>\n<td>4 bytes<br>+<br>可変(最大 (2<sup>32</sup> - 1) 要素)</td>\n<td>要素の総数(4 bytes)とその数と等しい数の(AMF0 でエンコードされた)値.<br>当該データ型は順序インデックスを持つ厳密な配列として扱う.</td>\n</tr>\n<tr>\n<td>11</td>\n<td>Date</td>\n<td>2 bytes<br>+<br>8 bytes</td>\n<td>8 bytes 浮動小数点数のバイナリ表記.<br>UTC 基準のタイムスタンプを浮動小数点数として入力する.<br>最初の 2 bytes はタイムゾーンであるが, 予約済でありサポートされていないため 0 で埋めるべきである.</td>\n</tr>\n<tr>\n<td>12</td>\n<td>Long String</td>\n<td>4 bytes<br>+<br>可変(最大 (2<sup>32</sup> - 1) bytes)</td>\n<td>UTF-8 の文字列.<br>最初の 4 bytes には続く文字列の長さを入力する.</td>\n</tr>\n<tr>\n<td>13</td>\n<td>Unsupported</td>\n<td>0 byte</td>\n<td>なし.<br>ID のみを入力する.<br>直列化できないデータ型に対して, 当該データ型の ID をそのデータ型の場所で使うことができる.</td>\n</tr>\n<tr>\n<td>14</td>\n<td>RecordSet</td>\n<td></td>\n<td>サポートされておらず未来の使用のために予約されている.</td>\n</tr>\n<tr>\n<td>15</td>\n<td>XML</td>\n<td>4 bytes<br>+<br>可変(最大 (2<sup>32</sup> - 1) bytes)</td>\n<td>UTF-8 の文字列.<br>ActionScript 1.0, 2.0 での XMLDocument および ActionScript 3.0 での flash.xml.XMLDocument が XML ドキュメントの DOM 表現を提供する.<br>ただし, 直列化ではドキュメントの文字列表現が使用される.</td>\n</tr>\n<tr>\n<td>16</td>\n<td>Typed Object</td>\n<td>可変</td>\n<td>オブジェクトの名前(AMF0 での String)と名前と値(どちらも AMF0 でエンコードされたもの)のペア.</td>\n</tr>\n<tr>\n<td>17</td>\n<td><abbr title="ActionScript Virtual Machine">AVM</abbr>+</td>\n<td>可変</td>\n<td><strong>AMF3</strong> の値.<br>AMF0 のフォーマットの中で AMF3 のデータを扱う時に入力する.</td>\n</tr>\n</tbody>\n</table>\n<h4 id="amf3"><a class="header-anchor" href="#amf3">¶</a> AMF3</h4>\n<ul>\n<li>AMF3<sup class="footnote-ref"><a href="#fn42" id="fnref42">[42]</a></sup></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>ID</th>\n<th>データ型</th>\n<th>サイズ</th>\n<th>入力内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>Undefined</td>\n<td>0 byte</td>\n<td>なし.<br>ID のみを入力する.<br><abbr title="ActionScript Virtual Machine">AVM</abbr> 以外のエンドポイントでは未定義の概念がなく, 当該データ型をAMF での Null として扱う場合があることに注意が必要である.</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Null</td>\n<td>0 byte</td>\n<td>なし.<br>ID のみを入力する.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>False</td>\n<td>0 byte</td>\n<td>なし.<br>ID のみを入力する.<br>当該データ型は AMF3 における真偽値の<strong>偽</strong>として扱う.</td>\n</tr>\n<tr>\n<td>3</td>\n<td>True</td>\n<td>0 byte</td>\n<td>なし.<br>ID のみを入力する.<br>当該データ型は AMF3 における真偽値の<strong>真</strong>として扱う.</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Integer</td>\n<td>29 <strong>bits</strong></td>\n<td><a href="#integer-%E5%9E%8B%2C-%E9%95%B7%E3%81%95%2C-%E8%A6%81%E7%B4%A0%E3%81%AE%E7%B7%8F%E6%95%B0">29 bits</a> の整数.<br>28 bits の範囲を上回ったり下回ったりする場合は, AMF3 の Double 型を用いてシリアライズされる.</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Double</td>\n<td>8 bytes</td>\n<td>8 bytes の浮動小数点数.<br>エンコード/デコードの方法は AMF0 の Number 型と同じである.</td>\n</tr>\n<tr>\n<td>6</td>\n<td>String</td>\n<td>29 bits<br>+<br>可変(最大 (2<sup>28</sup> - 1) bytes)</td>\n<td>UTF-8 の文字列.<br>最初の <a href="#integer-%E5%9E%8B%2C-%E9%95%B7%E3%81%95%2C-%E8%A6%81%E7%B4%A0%E3%81%AE%E7%B7%8F%E6%95%B0">29 bits</a> には参照値または文字列の長さを入力する.</td>\n</tr>\n<tr>\n<td>7</td>\n<td>XMLDocument</td>\n<td>29 bits<br>+<br>可変(最大 (2<sup>28</sup> - 1) bytes)</td>\n<td>UTF-8 でエンコードされた XML の文字列表現.<br>ActionScript 3 では新しい XML 型があるが, 古い XMLDocument 型が flash.xml.XMLDocument として言語に残されている.</td>\n</tr>\n<tr>\n<td>8</td>\n<td>Date</td>\n<td>29 bits<br>+<br>8 bytes</td>\n<td>8 bytes の浮動小数点数のバイナリ表記.<br>UTC 基準のタイムスタンプを浮動小数点数として入力する.<br>最初の <a href="#integer-%E5%9E%8B%2C-%E9%95%B7%E3%81%95%2C-%E8%A6%81%E7%B4%A0%E3%81%AE%E7%B7%8F%E6%95%B0">29 bits</a> は AMF3 の Integer の値や String の長さと同じフォーマットであるが, 値(最下位ビットのフラグが 1)として入力する場合は残りの 28 bits には何も入力しない.</td>\n</tr>\n<tr>\n<td>9</td>\n<td>Array</td>\n<td>29 bits<br>+<br>可変</td>\n<td>当該データ型には以下の 3 つのフォーマットがある.  \\</td>\n</tr>\n<tr>\n<td>* 参照であることを示す <a href="#integer-%E5%9E%8B%2C-%E9%95%B7%E3%81%95%2C-%E8%A6%81%E7%B4%A0%E3%81%AE%E7%B7%8F%E6%95%B0">29 bits</a> のフォーマット  \\</td>\n</tr>\n<tr>\n<td>* 要素の総数(<a href="#integer-%E5%9E%8B%2C-%E9%95%B7%E3%81%95%2C-%E8%A6%81%E7%B4%A0%E3%81%AE%E7%B7%8F%E6%95%B0">29 bits</a>)と, 空要素(1 -&gt; 値なし)のみの場合も含む ECMA (連想)配列<br>(名前と値(どちらも AMF3 でエンコードされたもの)のペア)  \\</td>\n</tr>\n<tr>\n<td>* 順序インデックスによる厳密な配列  \\</td>\n</tr>\n<tr>\n<td>\\</td>\n</tr>\n<tr>\n<td>ECMA 配列フォーマットの場合は空要素を最後の要素として 1 つ置かなければならない.<br>また, 厳密な配列フォーマットは ECMA 配列フォーマットの末尾の空要素に続いて入力し, 要素の総数を ECMA 配列フォーマットの要素の総数に加える.</td>\n</tr>\n<tr>\n<td>10</td>\n<td>Object</td>\n<td>可変</td>\n<td>当該データ型には以下の 6 つのフォーマットがある.  \\</td>\n</tr>\n<tr>\n<td>* 当該データ型の参照であることを示す <a href="#integer-%E5%9E%8B%2C-%E9%95%B7%E3%81%95%2C-%E8%A6%81%E7%B4%A0%E3%81%AE%E7%B7%8F%E6%95%B0">29 bits</a> のフォーマット  \\</td>\n</tr>\n<tr>\n<td>* トレイトのメンバのバイナリであることを示す(<a href="#%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%81%AE%E3%83%90%E3%82%A4%E3%83%8A%E3%83%AA%2C-%E3%83%A1%E3%83%B3%E3%83%90%E3%81%AE%E7%B7%8F%E6%95%B0%2C-%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%81%AE%E5%8F%82%E7%85%A7">29 bits</a>) + トレイトの特質とメンバのバイナリのペア  \\</td>\n</tr>\n<tr>\n<td>* トレイトの参照であることを示す <a href="#%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%81%AE%E3%83%90%E3%82%A4%E3%83%8A%E3%83%AA%2C-%E3%83%A1%E3%83%B3%E3%83%90%E3%81%AE%E7%B7%8F%E6%95%B0%2C-%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%81%AE%E5%8F%82%E7%85%A7">29 bits</a> のフォーマット  \\</td>\n</tr>\n<tr>\n<td>* トレイトのメンバの総数(<a href="#%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%81%AE%E3%83%90%E3%82%A4%E3%83%8A%E3%83%AA%2C-%E3%83%A1%E3%83%B3%E3%83%90%E3%81%AE%E7%B7%8F%E6%95%B0%2C-%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%81%AE%E5%8F%82%E7%85%A7">29 bits</a>) + トレイトの特質と(AMF3 でエンコードされた)メンバ名のペア  \\</td>\n</tr>\n<tr>\n<td>* 1 つ以上のトレイトのメンバの(AMF3 でエンコードされた)値  \\</td>\n</tr>\n<tr>\n<td>* 1 つ以上の<strong>動的な</strong>メンバ<br>(名前と値(どちらも AMF3 でエンコードされたもの)のペア)  \\</td>\n</tr>\n<tr>\n<td>\\</td>\n</tr>\n<tr>\n<td>ここで, トレイトの特質とは以下の 4 つの内 1 つを指す AMF3 の文字列である.  \\</td>\n</tr>\n<tr>\n<td>* anonymous<br>匿名のオブジェクト. 空文字(&quot;&quot;)を入力する.  \\</td>\n</tr>\n<tr>\n<td>* typed<br>名前付きのオブジェクト.  \\</td>\n</tr>\n<tr>\n<td>* dynamic<br>名前付き かつ 動的なメンバを持つオブジェクト.  \\</td>\n</tr>\n<tr>\n<td>* externalizable<br><strong>外部のプログラムが変換可能な</strong>名前を持つオブジェクト.  \\</td>\n</tr>\n<tr>\n<td>\\</td>\n</tr>\n<tr>\n<td><strong>Object 型としての</strong>参照値もしくはトレイトのフォーマットの直後にメンバの実際の値が続き, 動的なメンバがあれば更にその直後にそれが続く形になる.</td>\n</tr>\n<tr>\n<td>11</td>\n<td>XML</td>\n<td>29 bits<br>+<br>可変(最大 (2<sup>28</sup> - 1) bytes)</td>\n<td>UTF-8 でエンコードされた XML の文字列表現.</td>\n</tr>\n<tr>\n<td>12</td>\n<td>ByteArray</td>\n<td>29 bits<br>+<br>可変(最大 (2<sup>28</sup> - 1) bytes)</td>\n<td>1 byte 符号なし整数の配列.</td>\n</tr>\n<tr>\n<td>13</td>\n<td>Vector(Int)</td>\n<td>29 bits<br>+<br>1 byte<br>+<br>可変(最大 (2<sup>28</sup> - 1) 要素)</td>\n<td>4 byte <strong>符号付き</strong> 整数の配列.<br><a href="#integer-%E5%9E%8B%2C-%E9%95%B7%E3%81%95%2C-%E8%A6%81%E7%B4%A0%E3%81%AE%E7%B7%8F%E6%95%B0">29 bits</a> の直後の 1 byte は 1 ならその配列が固定長であることを, 0 なら可変長であることを意味する.</td>\n</tr>\n<tr>\n<td>14</td>\n<td>Vector(UInt)</td>\n<td>^^</td>\n<td>4 byte <strong>符号なし</strong> 整数の配列.<br>〃</td>\n</tr>\n<tr>\n<td>15</td>\n<td>Vector(Double)</td>\n<td>^^</td>\n<td>8 byte <strong>浮動小数点数</strong>(のバイナリ表記)の配列.<br>〃</td>\n</tr>\n<tr>\n<td>16</td>\n<td>Vector(Object)</td>\n<td>^^</td>\n<td><strong>AMF3 のデータ型</strong>の配列.<br>固定長かどうかのフラグの直後に AMF3 のデータ型の名前(AMF3 でエンコードされた文字列)を入力し, 以降にその名前で表現される AMF3 データの実体を入力する.<br>〃</td>\n</tr>\n<tr>\n<td>17</td>\n<td>Dictionary</td>\n<td>29 bits<br>+<br>1 byte<br>+<br>可変(最大 (2^28 - 1) 要素)</td>\n<td>名前と値(どちらも AMF3 でエンコードされたもの)のペア.<br>Object 型との違いは<strong>キーを任意の AMF3 データ型にできる</strong>ことである.<br><a href="#integer-%E5%9E%8B%2C-%E9%95%B7%E3%81%95%2C-%E8%A6%81%E7%B4%A0%E3%81%AE%E7%B7%8F%E6%95%B0">29 bits</a> の直後の 1 byte は 1 ならキーが弱参照であることを, 0 ならそうでないことを意味する.</td>\n</tr>\n</tbody>\n</table>\n<p>なお, AMF3 における 29 bits のフィールドの内訳は以下の通りである.</p>\n<h5 id="integer-%E5%9E%8B%2C-%E9%95%B7%E3%81%95%2C-%E8%A6%81%E7%B4%A0%E3%81%AE%E7%B7%8F%E6%95%B0"><a class="header-anchor" href="#integer-%E5%9E%8B%2C-%E9%95%B7%E3%81%95%2C-%E8%A6%81%E7%B4%A0%E3%81%AE%E7%B7%8F%E6%95%B0">¶</a> Integer 型, 長さ, 要素の総数</h5>\n<ul>\n<li>最下位ビットが 0 の場合</li>\n</ul>\n<p>そのデータは参照であり, 残りの 28 bits は参照テーブルのインデックス(整数)を入力する.</p>\n<ul>\n<li>〃 1 の場合</li>\n</ul>\n<p>そのデータは実際の値であり, 残りの 28 bits には続く文字列の長さなどの整数を入力する.</p>\n<h5 id="%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%81%AE%E3%83%90%E3%82%A4%E3%83%8A%E3%83%AA%2C-%E3%83%A1%E3%83%B3%E3%83%90%E3%81%AE%E7%B7%8F%E6%95%B0%2C-%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%81%AE%E5%8F%82%E7%85%A7"><a class="header-anchor" href="#%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%81%AE%E3%83%90%E3%82%A4%E3%83%8A%E3%83%AA%2C-%E3%83%A1%E3%83%B3%E3%83%90%E3%81%AE%E7%B7%8F%E6%95%B0%2C-%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%81%AE%E5%8F%82%E7%85%A7">¶</a> トレイトのバイナリ, メンバの総数, トレイトの参照</h5>\n<ul>\n<li>バイナリの場合</li>\n</ul>\n<p>最下位 <strong>3 bits</strong> に <strong>0b111</strong> を入力する. メンバの総数として常に 0 を入力することになるため, 残りの 26 bits には意味がない.</p>\n<ul>\n<li><strong>トレイトの</strong>参照の場合</li>\n</ul>\n<p>最下位 <strong>2 bits</strong> に <strong>0b01</strong> を入力する. 2 bit 目は <strong>Object 型のトレイトが</strong>参照で送られていることを意味する値(0)である. 残りの 27 bits にはトレイトの参照のインデックスを入力する.</p>\n<ul>\n<li>メンバの総数の場合</li>\n</ul>\n<p>最下位 <strong>4 bits</strong> に <strong>0bX011</strong> を入力する. X は 1 なら動的なトレイトである(動的なメンバを持つ)ことを, 0 ならそうでないことを意味する. 残りの 25 bits にはトレイト名の直後に入力する<strong>静的なメンバの</strong>総数を入力する.</p>\n<h2 id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><a class="header-anchor" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">¶</a> 参考文献</h2>\n<hr class="footnotes-sep">\n<section class="footnotes">\n<ol class="footnotes-list">\n<li id="fn1" class="footnote-item"><p>Adobe Systems Inc., “<abbr title="Real-Time Messaging Protocol">RTMP</abbr> Specification 1.0”, <a href="http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/rtmp/pdf/rtmp_specification_1.0.pdf">http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/rtmp/pdf/rtmp_specification_1.0.pdf</a> <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a> <a href="#fnref1:2" class="footnote-backref">↩︎</a> <a href="#fnref1:3" class="footnote-backref">↩︎</a> <a href="#fnref1:4" class="footnote-backref">↩︎</a> <a href="#fnref1:5" class="footnote-backref">↩︎</a> <a href="#fnref1:6" class="footnote-backref">↩︎</a> <a href="#fnref1:7" class="footnote-backref">↩︎</a> <a href="#fnref1:8" class="footnote-backref">↩︎</a> <a href="#fnref1:9" class="footnote-backref">↩︎</a> <a href="#fnref1:10" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn2" class="footnote-item"><p>FFmpeg, “FFmpeg/rtmpproto.c#L1200-L1236”, <a href="https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L1200-L1236">https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L1200-L1236</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn3" class="footnote-item"><p>obsproject, “obs-studio/rtmp.c#L4062”, <a href="https://github.com/obsproject/obs-studio/blob/23.2.1/plugins/obs-outputs/librtmp/rtmp.c#L4062">https://github.com/obsproject/obs-studio/blob/23.2.1/plugins/obs-outputs/librtmp/rtmp.c#L4062</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn4" class="footnote-item"><p>obsproject, “obs-studio/handshake.h#L831-L837”, <a href="https://github.com/obsproject/obs-studio/blob/23.2.1/plugins/obs-outputs/librtmp/handshake.h#L831-L837">https://github.com/obsproject/obs-studio/blob/23.2.1/plugins/obs-outputs/librtmp/handshake.h#L831-L837</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn5" class="footnote-item"><p>Red5, “red5-server-common/RTMPHandshake.java#L56”, <a href="https://github.com/Red5/red5-server-common/blob/v1.2.2/src/main/java/org/red5/server/net/rtmp/RTMPHandshake.java#L56">https://github.com/Red5/red5-server-common/blob/v1.2.2/src/main/java/org/red5/server/net/rtmp/RTMPHandshake.java#L56</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn6" class="footnote-item"><p>FFmpeg, “FFmpeg/rtmpproto.c#L1200-L1207”, <a href="https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L1200-L1207">https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L1200-L1207</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn7" class="footnote-item"><p>FFmpeg, “FFmpeg/rtmp.h#L32-L41”, <a href="https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmp.h#L32-L41">https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmp.h#L32-L41</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn8" class="footnote-item"><p>obsproject, “obs-studio/handshake.h#L842-L865”, <a href="https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/handshake.h#L842-L865">https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/handshake.h#L842-L865</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn9" class="footnote-item"><p>Red5, “red5-server/InboundHandshake.java#L337-L341”, <a href="https://github.com/Red5/red5-server/blob/v1.2.3/src/main/java/org/red5/server/net/rtmp/InboundHandshake.java#L337-L341">https://github.com/Red5/red5-server/blob/v1.2.3/src/main/java/org/red5/server/net/rtmp/InboundHandshake.java#L337-L341</a> <a href="#fnref9" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn10" class="footnote-item"><p>FFmpeg, “FFmpeg/rtmpproto.c#L1248-L1258”, <a href="https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L1248-L1258">https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L1248-L1258</a> <a href="#fnref10" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn11" class="footnote-item"><p>obsproject, “obs-studio/rtmp.c#L4089-L4112”, <a href="https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L4089-L4112">https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L4089-L4112</a> <a href="#fnref11" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn12" class="footnote-item"><p>obsproject, “obs-studio/handshake.h#L936-L945”, <a href="https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/handshake.h#L936-L945">https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/handshake.h#L936-L945</a> <a href="#fnref12" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn13" class="footnote-item"><p>obsproject, “obs-studio/handshake.h#L1078-L1083”, <a href="https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/handshake.h#L1078-L1083">https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/handshake.h#L1078-L1083</a> <a href="#fnref13" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn14" class="footnote-item"><p>obsproject, “obs-studio/handshake.h#L1170-L1174”, <a href="https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/handshake.h#L1170-L10174">https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/handshake.h#L1170-L10174</a> <a href="#fnref14" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn15" class="footnote-item"><p>FFmpeg, “FFmpeg/rtmpproto.c#L1452-L1472”, <a href="https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L1452-L1472">https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L1452-L1472</a> <a href="#fnref15" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn16" class="footnote-item"><p>obsproject, “obs-studio/rtmp.c#L4152-L4178”, <a href="https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L4152-L4178">https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L4152-L4178</a> <a href="#fnref16" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn17" class="footnote-item"><p>obsproject, “obs-studio/handshake.h#L1442-L1447”, <a href="https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/handshake.h#L1442-L1447">https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/handshake.h#L1442-L1447</a> <a href="#fnref17" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn18" class="footnote-item"><p>obsproject, “obs-studio/handshake.h#L1524-L1528”, <a href="https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/handshake.h#L1524-L1528">https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/handshake.h#L1524-L1528</a> <a href="#fnref18" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn19" class="footnote-item"><p>Red5, “red5-server/InboundHandshake.java#L202-L213”, <a href="https://github.com/Red5/red5-server/blob/v1.2.3/src/main/java/org/red5/server/net/rtmp/InboundHandshake.java#L202-L213">https://github.com/Red5/red5-server/blob/v1.2.3/src/main/java/org/red5/server/net/rtmp/InboundHandshake.java#L202-L213</a> <a href="#fnref19" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn20" class="footnote-item"><p>Red5, “red5-server/InboundHandshake.java#L293-L295”, <a href="https://github.com/Red5/red5-server/blob/v1.2.3/src/main/java/org/red5/server/net/rtmp/InboundHandshake.java#L293-L295">https://github.com/Red5/red5-server/blob/v1.2.3/src/main/java/org/red5/server/net/rtmp/InboundHandshake.java#L293-L295</a> <a href="#fnref20" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn21" class="footnote-item"><p>FFmpeg, “FFmpeg/rtmpproto.c#L2347-L2395”, <a href="https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L2347-L2395">https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L2347-L2395</a> <a href="#fnref21" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn22" class="footnote-item"><p>obsproject, “obs-studio/rtmp.c#L1490-L1523”, <a href="https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L1490-L1523">https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L1490-L1523</a> <a href="#fnref22" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn23" class="footnote-item"><p>obsproject, “obs-studio/rtmp.c#L4972-L5059”, <a href="https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L4972-L5059">https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L4972-L5059</a> <a href="#fnref23" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn24" class="footnote-item"><p>Red5, “red5-server-common/Aggregate.java#L108-L198”, <a href="https://github.com/Red5/red5-server-common/blob/v1.2.2/src/main/java/org/red5/server/net/rtmp/event/Aggregate.java#L108-L198">https://github.com/Red5/red5-server-common/blob/v1.2.2/src/main/java/org/red5/server/net/rtmp/event/Aggregate.java#L108-L198</a> <a href="#fnref24" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn25" class="footnote-item"><p>FFmpeg, “FFmpeg/rtmpproto.c#L542-L575”, <a href="https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L542-L575">https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L542-L575</a> <a href="#fnref25" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn26" class="footnote-item"><p>FFmpeg, “FFmpeg/rtmpproto.c#L485-L588”, <a href="https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L485-L588">https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L485-L588</a> <a href="#fnref26" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn27" class="footnote-item"><p>FFmpeg, “FFmpeg/rtmppkt.c#L238-L244”, <a href="https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmppkt.c#L238-L244">https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmppkt.c#L238-L244</a> <a href="#fnref27" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn28" class="footnote-item"><p>obsproject, “obs-studio/rtmp.c#L3857-L4049”, <a href="https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L3857-L4049">https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L3857-L4049</a> <a href="#fnref28" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn29" class="footnote-item"><p>FFmpeg, “FFmpeg/rtmpproto.c#L593-L615”, <a href="https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L593-L615">https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L593-L615</a> <a href="#fnref29" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn30" class="footnote-item"><p>FFmpeg, “FFmpeg/rtmpproto.c#L1981-L1999”, <a href="https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L1981-L1999">https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L1981-L1999</a> <a href="#fnref30" class="footnote-backref">↩︎</a> <a href="#fnref30:1" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn31" class="footnote-item"><p>obsproject, “obs-studio/rtmp.c#L1990-L2016”, <a href="https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L1990-L2016">https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L1990-L2016</a> <a href="#fnref31" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn32" class="footnote-item"><p>FFmpeg, “FFmpeg/rtmpproto.c#L641-L663”, <a href="https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L641-L663">https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L641-L663</a> <a href="#fnref32" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn33" class="footnote-item"><p>FFmpeg, “FFmpeg/rtmpproto.c#L1956-L1965”, <a href="https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L1956-L1965">https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L1956-L1965</a> <a href="#fnref33" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn34" class="footnote-item"><p>obsproject, “obs-studio/rtmp.c#L2020-L2046”, <a href="https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L2020-L2046">https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L2020-L2046</a> <a href="#fnref34" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn35" class="footnote-item"><p>FFmpeg, “FFmpeg/rtmpproto.c#L665-L687”, <a href="https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L665-L687">https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L665-L687</a> <a href="#fnref35" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn36" class="footnote-item"><p>obsproject, “obs-studio/rtmp.c#L1899-L1922”, <a href="https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L1899-L1922">https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L1899-L1922</a> <a href="#fnref36" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn37" class="footnote-item"><p>FFmpeg, “FFmpeg/rtmpproto.c#L838-L863”, <a href="https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L838-L863">https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L838-L863</a> <a href="#fnref37" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn38" class="footnote-item"><p>FFmpeg, “FFmpeg/rtmpproto.c#L1858-L1899”, <a href="https://github.com/FFmpeg/FFmpeg/blob/n4.2.1/libavformat/rtmpproto.c#L1858-L1899">https://github.com/FFmpeg/FFmpeg/blob/n4.2.1/libavformat/rtmpproto.c#L1858-L1899</a> <a href="#fnref38" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn39" class="footnote-item"><p>obsproject, “obs-studio/rtmp.c#L2081-L2112”, <a href="https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L2081-L2112">https://github.com/obsproject/obs-studio/blob/24.0.6/plugins/obs-outputs/librtmp/rtmp.c#L2081-L2112</a> <a href="#fnref39" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn40" class="footnote-item"><p>FFmpeg, “FFmpeg/rtmpproto.c#L1965-L1973”, <a href="https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L1965-L1973">https://github.com/FFmpeg/FFmpeg/blob/n4.2.2/libavformat/rtmpproto.c#L1965-L1973</a> <a href="#fnref40" class="footnote-backref">↩︎</a> <a href="#fnref40:1" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn41" class="footnote-item"><p>Adobe Systems Inc., “AMF0 File Format Specification”, <a href="https://www.adobe.com/content/dam/acom/en/devnet/pdf/amf0-file-format-specification.pdf">https://www.adobe.com/content/dam/acom/en/devnet/pdf/amf0-file-format-specification.pdf</a> <a href="#fnref41" class="footnote-backref">↩︎</a></p>\n</li>\n<li id="fn42" class="footnote-item"><p>Adobe Systems Inc., “AMF File Format Spec”, <a href="https://www.adobe.com/content/dam/acom/en/devnet/pdf/amf-file-format-spec.pdf">https://www.adobe.com/content/dam/acom/en/devnet/pdf/amf-file-format-spec.pdf</a> <a href="#fnref42" class="footnote-backref">↩︎</a></p>\n</li>\n</ol>\n</section>\n'}),mounted(){f.a.parse("start=>start: TCP(1935) ポートを\n開放する.\nend=>end: 接続を閉じる.\nhandshake_tcp=>operation: TCP ハンドシェイク\nを行う.\nhandshake_rtmp=>operation: RTMP ハンドシェイク\nを行う.\napplication_connection=>operation: アプリケーション接続\nを行う.\nmessage_id_allocation=>operation: メッセージストリームに\nID を割り当てる.\npublishing=>operation: 映像/音声データを\n送受信する.\nhas_publishing_done=>condition: 映像/音声の送受信が\n完了した.\n\nstart->handshake_tcp->handshake_rtmp->application_connection->message_id_allocation->publishing->has_publishing_done\nhas_publishing_done(true)->end\nhas_publishing_done(false)->publishing\n").drawSVG("rtmp-connection-flows")},beforeRouteLeave(n,t,e){document.getElementById("submenu").outerHTML=null,e()},head(){return{title:this.title,meta:[{hid:"description",name:"description",content:this.description},{hid:"title",property:"og:title",content:this.title},{hid:"og:description",property:"og:description",content:this.description},{hid:"url",property:"og:url",content:"https://t-matsudate.github.io/rtmp-reports/articles/overview"},{hid:"type",property:"og:type",content:"article"},{hid:"published_time",property:"og:article:published_time",content:this.published},{hid:"modified_time",property:"og:article:modified_time",content:this.modified},{hid:"section",property:"og:article:section",content:"Overview"},{hid:"author",property:"og:article:author",content:this.author},{hid:"tag1",property:"og:article:tag",content:"RTMP"},{hid:"tag2",property:"og:article:tag",content:"実装"},{hid:"tag3",property:"og:article:tag",content:"FFmpeg"},{hid:"tag4",property:"og:article:tag",content:"Open Broadcaster Software"},{hid:"tag5",property:"og:article:tag",content:"OBS"},{hid:"tag6",property:"og:article:tag",content:"Red5"}]}}},E=(e(130),Object(d.a)(_,(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("article",{attrs:{id:"report"}},[e("Author",{attrs:{author:n.author,published:n.published,modified:n.modified}}),n._v(" "),e("ReportTitle",{attrs:{"report-title":n.title}}),n._v(" "),e("Markdown",{attrs:{source:n.source}}),n._v(" "),e("ShareButtons",{attrs:{text:n.title,path:n.$route.path}})],1)}),[],!1,null,null,null));t.default=E.exports},36:function(n,t,e){var r=e(6),content=e(40);"string"==typeof(content=content.__esModule?content.default:content)&&(content=[[n.i,content,""]]);var l={insert:"head",singleton:!1},o=(r(n.i,content,l),content.locals?content.locals:{});n.exports=o},37:function(n,t,e){var r=e(6),content=e(42);"string"==typeof(content=content.__esModule?content.default:content)&&(content=[[n.i,content,""]]);var l={insert:"head",singleton:!1},o=(r(n.i,content,l),content.locals?content.locals:{});n.exports=o},39:function(n,t,e){"use strict";var r=e(36);e.n(r).a},40:function(n,t,e){(t=e(5)(!1)).push([n.i,"#grids #main main article #author {\n  text-align: right;\n}\n#grids #main main article #author .datetime {\n  list-style: none;\n}\n#grids #main main article #author .datetime .published,\n#grids #main main article #author .datetime .modified {\n  font-family: sans-serif;\n}\n#grids #main main article #author .datetime .published time,\n#grids #main main article #author .datetime .modified time {\n  font-family: sans-serif;\n}\n",""]),n.exports=t},41:function(n,t,e){"use strict";var r=e(37);e.n(r).a},42:function(n,t,e){(t=e(5)(!1)).push([n.i,"#grids #main main article #report-title {\n  padding: 1em;\n  text-align: center;\n  font-size: 200%;\n  font-style: normal;\n  font-weight: bold;\n  font-family: sans-serif;\n}\n",""]),n.exports=t},43:function(n,t,e){var r=e(6),content=e(54);"string"==typeof(content=content.__esModule?content.default:content)&&(content=[[n.i,content,""]]);var l={insert:"head",singleton:!1},o=(r(n.i,content,l),content.locals?content.locals:{});n.exports=o},45:function(n,t,e){var r=e(6),content=e(131);"string"==typeof(content=content.__esModule?content.default:content)&&(content=[[n.i,content,""]]);var l={insert:"head",singleton:!1},o=(r(n.i,content,l),content.locals?content.locals:{});n.exports=o},47:function(n,t,e){"use strict";var r={props:{author:{type:String,required:!0},published:{type:String,required:!0,validator:n=>!isNaN(new Date(n))},modified:{type:String,validator:n=>!isNaN(new Date(n))}}},l=(e(39),e(2)),component=Object(l.a)(r,(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("p",{attrs:{id:"author"}},[n._v("\n  "+n._s(n.author)+"\n  "),e("ul",{staticClass:"datetime"},[n.modified?e("li",{staticClass:"modified"},[n._v("更新日: "),e("time",{attrs:{datetime:n.modified}},[n._v(n._s(n.modified))])]):n._e(),n._v(" "),e("li",{staticClass:"published"},[n._v("投稿日: "),e("time",{attrs:{datetime:n.published}},[n._v(n._s(n.published))])])])])}),[],!1,null,null,null);t.a=component.exports},48:function(n,t,e){"use strict";var r={props:{reportTitle:{type:String,required:!0}}},l=(e(41),e(2)),component=Object(l.a)(r,(function(){var n=this.$createElement;return(this._self._c||n)("h1",{attrs:{id:"report-title"}},[this._v(this._s(this.reportTitle))])}),[],!1,null,null,null);t.a=component.exports},49:function(n,t,e){"use strict";var r={props:{text:{type:String,required:!0},path:{type:String,required:!0}},computed:{url(){return"https://t-matsudate.github.io/rtmp-reports"+this.path}}},l=e(2),component=Object(l.a)(r,(function(){var n=this.$createElement,t=this._self._c||n;return t("div",{attrs:{id:"share-buttons"}},[t("a",{staticClass:"twitter-share-button",attrs:{href:"https://twitter.com/share?ref_src=twsrc%5Etfw","data-text":this.text,"data-url":this.url,"data-show-count":"true"}},[this._v("Tweet")])])}),[],!1,null,null,null);t.a=component.exports},53:function(n,t,e){"use strict";var r=e(43);e.n(r).a},54:function(n,t,e){var r=e(5),l=e(55),o=e(56),d=e(118);(t=r(!1)).i(l),t.i(o),t.i(d),t.push([n.i,"#grids #main main #report {\n  padding: 1em;\n  font-family: serif;\n}\n#grids #main main #report strong {\n  font-weight: bold;\n}\n#grids #main main #report em {\n  font-style: italic;\n}\n#grids #main main #report .footnotes {\n  word-break: break-word;\n}\n#grids #main main #report .hljs {\n  /* 4K */\n  /* WQHD */\n  /* Desktop or Laptop (Full HD) */\n  /* iPad (up to 12 inchs) */\n  /* iPhone (up to X) */\n  /* Android (based on Pixel XL) */\n}\n@media (orientation: landscape) and (max-width: 3840px) {\n#grids #main main #report .hljs {\n    max-width: 3072px;\n}\n}\n@media (orientation: portrait) and (max-width: 2160px) {\n#grids #main main #report .hljs {\n    max-width: 1728px;\n}\n}\n@media (orientation: landscape) and (max-width: 2560px) {\n#grids #main main #report .hljs {\n    max-width: 2048px;\n}\n}\n@media (orientation: portrait) and (max-width: 1440px) {\n#grids #main main #report .hljs {\n    max-width: 1152px;\n}\n}\n@media (orientation: landscape) and (max-width: 1920px) {\n#grids #main main #report .hljs {\n    max-width: 1536px;\n}\n}\n@media (orientation: portrait) and (max-width: 1080px) {\n#grids #main main #report .hljs {\n    max-width: 864px;\n}\n}\n@media (orientation: landscape) and (max-width: 1366px) {\n#grids #main main #report .hljs {\n    max-width: 1092px;\n}\n}\n@media (orientation: portrait) and (max-width: 1024px) {\n#grids #main main #report .hljs {\n    max-width: 819px;\n}\n}\n@media (orientation: landscape) and (max-width: 812px) {\n#grids #main main #report .hljs {\n    max-width: 649px;\n}\n}\n@media (orientation: portrait) and (max-width: 375px) {\n#grids #main main #report .hljs {\n    max-width: 300px;\n}\n}\n@media (orientation: landscape) and (max-width: 640px) {\n#grids #main main #report .hljs {\n    max-width: 512px;\n}\n}\n@media (orientation: portrait) and (max-width: 360px) {\n#grids #main main #report .hljs {\n    max-width: 288px;\n}\n}\n",""]),n.exports=t}}]);